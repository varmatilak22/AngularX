{
  "scrapeId": "173fc063-ce23-4f93-a910-a790b513207a",
  "sourceURL": "https://angular.dev/guide/forms/form-validation",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backForms\n  - [Overview](https://angular.dev/guide/forms)\n  - [Reactive forms](https://angular.dev/guide/forms/reactive-forms)\n  - [Strictly typed reactive forms](https://angular.dev/guide/forms/typed-forms)\n  - [Template-driven forms](https://angular.dev/guide/forms/template-driven-forms)\n  - [Validate form input](https://angular.dev/guide/forms/form-validation)\n  - [Building dynamic forms](https://angular.dev/guide/forms/dynamic-forms)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nYou can improve overall data quality by validating user input for accuracy and completeness.\nThis page shows how to validate user input from the UI and display useful validation messages, in both reactive and template-driven forms.\n\n## [Validating input in template-driven forms](https://angular.dev/guide/forms/form-validation\\#validating-input-in-template-driven-forms)\n\nTo add validation to a template-driven form, you add the same validation attributes as you would with [native HTML form validation](https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation).\nAngular uses directives to match these attributes with validator functions in the framework.\n\nEvery time the value of a form control changes, Angular runs validation and generates either a list of validation errors that results in an `INVALID` status, or null, which results in a VALID status.\n\nYou can then inspect the control's state by exporting `ngModel` to a local template variable.\nThe following example exports `NgModel` into a variable called `name`:\n\ncheck\n\n```\n      <div>  <h2>Template-Driven Form</h2>  <form #actorForm=\"ngForm\" appUnambiguousRole>    <div [hidden]=\"actorForm.submitted\">      <div class=\"cross-validation\"           [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\">        <div class=\"form-group\">          <label for=\"name\">Name</label>          <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\"                 required minlength=\"4\" appForbiddenName=\"bob\"                 [(ngModel)]=\"actor.name\" #name=\"ngModel\">          @if (name.invalid && (name.dirty || name.touched)) {            <div class=\"alert\">              @if (name.hasError('required')) {                <div>                  Name is required.                </div>              }              @if (name.hasError('minlength')) {                <div>                  Name must be at least 4 characters long.                </div>              }              @if (name.hasError('forbiddenName')) {                <div>                  Name cannot be Bob.                </div>              }            </div>          }        </div>        <div class=\"form-group\">          <label for=\"role\">Role</label>          <input type=\"text\"                 id=\"role\"                 name=\"role\"                 #role=\"ngModel\"                 [(ngModel)]=\"actor.role\"                 [ngModelOptions]=\"{ updateOn: 'blur' }\"                 appUniqueRole>          @if (role.pending) {            <div>Validating...</div>          }          @if (role.invalid) {            <div class=\"alert role-errors\">              @if (role.hasError('uniqueRole')) {                <div>                  Role is already taken.                </div>              }            </div>          }        </div>        @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) {          <div class=\"cross-validation-error-message alert\">            Name cannot match role.          </div>        }      </div>      <div class=\"form-group\">        <label for=\"skill\">Skill</label>        <select id=\"skill\"                name=\"skill\"                required [(ngModel)]=\"actor.skill\"                #skill=\"ngModel\">          @for (skill of skills; track $index) {            <option [value]=\"skill\">{{ skill }}</option>          }        </select>        @if (skill.errors && skill.touched) {          <div class=\"alert\">            @if (skill.errors['required']) {              <div>Skill is required.</div>            }          </div>        }      </div>      <p>Complete the form to enable the Submit button.</p>      <button type=\"submit\"              [disabled]=\"actorForm.invalid\">Submit      </button>      <button type=\"button\"              (click)=\"actorForm.resetForm({})\">Reset      </button>    </div>    @if (actorForm.submitted) {      <div class=\"submitted-message\">        <p>You've submitted your actor, {{ actorForm.value.name }}!</p>        <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button>      </div>    }  </form></div>\n\n```\n\nNotice the following features illustrated by the example.\n\n- The `<input>` element carries the HTML validation attributes: `required` and `minlength`.\nIt also carries a custom validator directive, `forbiddenName`.\nFor more information, see the [Custom validators](https://angular.dev/guide/forms/form-validation#defining-custom-validators) section.\n\n- `#name=\"ngModel\"` exports `NgModel` into a local variable called `name`.\n`NgModel` mirrors many of the properties of its underlying `FormControl` instance, so you can use this in the template to check for control states such as `valid` and `dirty`.\nFor a full list of control properties, see the [AbstractControl](https://angular.dev/guide/forms/api/forms/AbstractControl) API reference.\n\n  - The `*ngIf` on the `<div>` element reveals a set of nested message `divs` but only if the `name` is invalid and the control is either `dirty` or `touched`.\n\n  - Each nested `<div>` can present a custom message for one of the possible validation errors.\n    There are messages for `required`, `minlength`, and `forbiddenName`.\n\n**HELPFUL:** To prevent the validator from displaying errors before the user has a chance to edit the form, you should check for either the `dirty` or `touched` states in a control.\n\n- When the user changes the value in the watched field, the control is marked as \"dirty\"\n- When the user blurs the form control element, the control is marked as \"touched\"\n\n## [Validating input in reactive forms](https://angular.dev/guide/forms/form-validation\\#validating-input-in-reactive-forms)\n\nIn a reactive form, the source of truth is the component class.\nInstead of adding validators through attributes in the template, you add validator functions directly to the form control model in the component class.\nAngular then calls these functions whenever the value of the control changes.\n\n### [Validator functions](https://angular.dev/guide/forms/form-validation\\#validator-functions)\n\nValidator functions can be either synchronous or asynchronous.\n\n| Validator type | Details |\n| :-- | :-- |\n| Sync validators | Synchronous functions that take a control instance and immediately return either a set of validation errors or `null`. Pass these in as the second argument when you instantiate a `FormControl`. |\n| Async validators | Asynchronous functions that take a control instance and return a Promise or Observable that later emits a set of validation errors or `null`. Pass these in as the third argument when you instantiate a `FormControl`. |\n\nFor performance reasons, Angular only runs async validators if all sync validators pass.\nEach must complete before errors are set.\n\n### [Built-in validator functions](https://angular.dev/guide/forms/form-validation\\#built-in-validator-functions)\n\nYou can choose to [write your own validator functions](https://angular.dev/guide/forms/form-validation#defining-custom-validators), or you can use some of Angular's built-in validators.\n\nThe same built-in validators that are available as attributes in template-driven forms, such as `required` and `minlength`, are all available to use as functions from the `Validators` class.\nFor a full list of built-in validators, see the [Validators](https://angular.dev/guide/forms/api/forms/Validators) API reference.\n\nTo update the actor form to be a reactive form, use some of the same\nbuilt-in validators â€”this time, in function form, as in the following example.\n\ncheck\n\n```\n      import {Component} from '@angular/core';import {FormControl, FormGroup, Validators, ReactiveFormsModule} from '@angular/forms';import {forbiddenNameValidator} from '../shared/forbidden-name.directive';@Component({  selector: 'app-actor-form-reactive',  templateUrl: './actor-form-reactive.component.html',  styleUrls: ['./actor-form-reactive.component.css'],  imports: [ReactiveFormsModule],})export class HeroFormReactiveComponent {  skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting'];  actor = {name: 'Tom Cruise', role: 'Romeo', skill: this.skills[3]};  actorForm: FormGroup = new FormGroup({    name: new FormControl(this.actor.name, [      Validators.required,      Validators.minLength(4),      forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.    ]),    role: new FormControl(this.actor.role),    skill: new FormControl(this.actor.skill, Validators.required),  });  get name() {    return this.actorForm.get('name');  }  get skill() {    return this.actorForm.get('skill');  }}\n\n```\n\nIn this example, the `name` control sets up two built-in validators â€” `Validators.required` and `Validators.minLength(4)`â€” and one custom validator, `forbiddenNameValidator`.\n\nAll of these validators are synchronous, so they are passed as the second argument.\nNotice that you can support multiple validators by passing the functions in as an array.\n\nThis example also adds a few getter methods.\nIn a reactive form, you can always access any form control through the `get` method on its parent group, but sometimes it's useful to define getters as shorthand for the template.\n\nIf you look at the template for the `name` input again, it is fairly similar to the template-driven example.\n\ncheck\n\n```\n      <div class=\"container\">  <h2>Reactive Form</h2>  <form [formGroup]=\"actorForm\" #formDir=\"ngForm\">    <div [hidden]=\"formDir.submitted\">      <div class=\"cross-validation\"           [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\">        <div class=\"form-group\">          <label for=\"name\">Name</label>          <input type=\"text\" id=\"name\" class=\"form-control\"                 formControlName=\"name\" required>          @if (name.invalid && (name.dirty || name.touched)) {            <div class=\"alert alert-danger\">              @if (name.hasError('required')) {                <div>                  Name is required.                </div>              }              @if (name.hasError('minlength')) {                <div>                  Name must be at least 4 characters long.                </div>              }              @if (name.hasError('forbiddenName')) {                <div>                  Name cannot be Bob.                </div>              }            </div>          }        </div>        <div class=\"form-group\">          <label for=\"role\">Role</label>          <input type=\"text\" id=\"role\" class=\"form-control\"                 formControlName=\"role\">          @if (role.pending) {            <div>Validating...</div>          }          @if (role.invalid) {            <div class=\"alert alert-danger role-errors\">              @if (role.hasError('uniqueRole')) {                <div>                  Role is already taken.                </div>              }            </div>          }        </div>        @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) {          <div class=\"cross-validation-error-message alert alert-danger\">            Name cannot match role or audiences will be confused.          </div>        }      </div>      <div class=\"form-group\">        <label for=\"skill\">Skill</label>        <select id=\"skill\" class=\"form-control\"                formControlName=\"skill\" required>          @for (skill of skills; track $index) {            <option [value]=\"skill\">{{ skill }}</option>          }        </select>        @if (skill.invalid && skill.touched) {          <div class=\"alert alert-danger\">            @if (skill.hasError('required')) {              <div>Skill is required.</div>            }          </div>        }      </div>      <p>Complete the form to enable the Submit button.</p>      <button type=\"submit\"              class=\"btn btn-default\"              [disabled]=\"actorForm.invalid\">Submit      </button>      <button type=\"button\" class=\"btn btn-default\"              (click)=\"formDir.resetForm({})\">Reset      </button>    </div>  </form>  @if (formDir.submitted) {    <div class=\"submitted-message\">      <p>You've submitted your actor, {{ actorForm.value.name }}!</p>      <button type=\"button\" (click)=\"formDir.resetForm({})\">Add new actor</button>    </div>  }</div>\n\n```\n\nThis form differs from the template-driven version in that it no longer exports any directives. Instead, it uses the `name` getter defined in the component class.\n\nNotice that the `required` attribute is still present in the template. Although it's not necessary for validation, it should be retained for accessibility purposes.\n\n## [Defining custom validators](https://angular.dev/guide/forms/form-validation\\#defining-custom-validators)\n\nThe built-in validators don't always match the exact use case of your application, so you sometimes need to create a custom validator.\n\nConsider the `forbiddenNameValidator` function from the previous example.\nHere's what the definition of that function looks like.\n\ncheck\n\n```\n      import {Directive, input} from '@angular/core';import {  AbstractControl,  NG_VALIDATORS,  ValidationErrors,  Validator,  ValidatorFn,} from '@angular/forms';/** An actor's name can't match the given regular expression */export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {  return (control: AbstractControl): ValidationErrors | null => {    const forbidden = nameRe.test(control.value);    return forbidden ? {forbiddenName: {value: control.value}} : null;  };}@Directive({  selector: '[appForbiddenName]',  providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}],})export class ForbiddenValidatorDirective implements Validator {  forbiddenName = input<string>('', {alias: 'appForbiddenName'});  validate(control: AbstractControl): ValidationErrors | null {    return this.forbiddenName      ? forbiddenNameValidator(new RegExp(this.forbiddenName(), 'i'))(control)      : null;  }}\n\n```\n\nThe function is a factory that takes a regular expression to detect a _specific_ forbidden name and returns a validator function.\n\nIn this sample, the forbidden name is \"bob\", so the validator rejects any actor name containing \"bob\".\nElsewhere it could reject \"alice\" or any name that the configuring regular expression matches.\n\nThe `forbiddenNameValidator` factory returns the configured validator function.\nThat function takes an Angular control object and returns _either_ null if the control value is valid _or_ a validation error object.\nThe validation error object typically has a property whose name is the validation key, `'forbiddenName'`, and whose value is an arbitrary dictionary of values that you could insert into an error message, `{name}`.\n\nCustom async validators are similar to sync validators, but they must instead return a Promise or observable that later emits null or a validation error object.\nIn the case of an observable, the observable must complete, at which point the form uses the last value emitted for validation.\n\n### [Adding custom validators to reactive forms](https://angular.dev/guide/forms/form-validation\\#adding-custom-validators-to-reactive-forms)\n\nIn reactive forms, add a custom validator by passing the function directly to the `FormControl`.\n\ncheck\n\n```\n      import {Component} from '@angular/core';import {FormControl, FormGroup, Validators, ReactiveFormsModule} from '@angular/forms';import {forbiddenNameValidator} from '../shared/forbidden-name.directive';@Component({  selector: 'app-actor-form-reactive',  templateUrl: './actor-form-reactive.component.html',  styleUrls: ['./actor-form-reactive.component.css'],  imports: [ReactiveFormsModule],})export class HeroFormReactiveComponent {  skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting'];  actor = {name: 'Tom Cruise', role: 'Romeo', skill: this.skills[3]};  actorForm: FormGroup = new FormGroup({    name: new FormControl(this.actor.name, [      Validators.required,      Validators.minLength(4),      forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.    ]),    role: new FormControl(this.actor.role),    skill: new FormControl(this.actor.skill, Validators.required),  });  get name() {    return this.actorForm.get('name');  }  get skill() {    return this.actorForm.get('skill');  }}\n\n```\n\n### [Adding custom validators to template-driven forms](https://angular.dev/guide/forms/form-validation\\#adding-custom-validators-to-template-driven-forms)\n\nIn template-driven forms, add a directive to the template, where the directive wraps the validator function.\nFor example, the corresponding `ForbiddenValidatorDirective` serves as a wrapper around the `forbiddenNameValidator`.\n\nAngular recognizes the directive's role in the validation process because the directive registers itself with the `NG_VALIDATORS` provider, as shown in the following example.\n`NG_VALIDATORS` is a predefined provider with an extensible collection of validators.\n\ncheck\n\n```\n      import {Directive, input} from '@angular/core';import {  AbstractControl,  NG_VALIDATORS,  ValidationErrors,  Validator,  ValidatorFn,} from '@angular/forms';/** An actor's name can't match the given regular expression */export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {  return (control: AbstractControl): ValidationErrors | null => {    const forbidden = nameRe.test(control.value);    return forbidden ? {forbiddenName: {value: control.value}} : null;  };}@Directive({  selector: '[appForbiddenName]',  providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}],})export class ForbiddenValidatorDirective implements Validator {  forbiddenName = input<string>('', {alias: 'appForbiddenName'});  validate(control: AbstractControl): ValidationErrors | null {    return this.forbiddenName      ? forbiddenNameValidator(new RegExp(this.forbiddenName(), 'i'))(control)      : null;  }}\n\n```\n\nThe directive class then implements the `Validator` interface, so that it can easily integrate with Angular forms.\nHere is the rest of the directive to help you get an idea of how it all comes together.\n\ncheck\n\n```\n      import {Directive, input} from '@angular/core';import {  AbstractControl,  NG_VALIDATORS,  ValidationErrors,  Validator,  ValidatorFn,} from '@angular/forms';/** An actor's name can't match the given regular expression */export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {  return (control: AbstractControl): ValidationErrors | null => {    const forbidden = nameRe.test(control.value);    return forbidden ? {forbiddenName: {value: control.value}} : null;  };}@Directive({  selector: '[appForbiddenName]',  providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}],})export class ForbiddenValidatorDirective implements Validator {  forbiddenName = input<string>('', {alias: 'appForbiddenName'});  validate(control: AbstractControl): ValidationErrors | null {    return this.forbiddenName      ? forbiddenNameValidator(new RegExp(this.forbiddenName(), 'i'))(control)      : null;  }}\n\n```\n\nOnce the `ForbiddenValidatorDirective` is ready, you can add its selector, `appForbiddenName`, to any input element to activate it.\nFor example:\n\ncheck\n\n```\n      <div>  <h2>Template-Driven Form</h2>  <form #actorForm=\"ngForm\" appUnambiguousRole>    <div [hidden]=\"actorForm.submitted\">      <div class=\"cross-validation\"           [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\">        <div class=\"form-group\">          <label for=\"name\">Name</label>          <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\"                 required minlength=\"4\" appForbiddenName=\"bob\"                 [(ngModel)]=\"actor.name\" #name=\"ngModel\">          @if (name.invalid && (name.dirty || name.touched)) {            <div class=\"alert\">              @if (name.hasError('required')) {                <div>                  Name is required.                </div>              }              @if (name.hasError('minlength')) {                <div>                  Name must be at least 4 characters long.                </div>              }              @if (name.hasError('forbiddenName')) {                <div>                  Name cannot be Bob.                </div>              }            </div>          }        </div>        <div class=\"form-group\">          <label for=\"role\">Role</label>          <input type=\"text\"                 id=\"role\"                 name=\"role\"                 #role=\"ngModel\"                 [(ngModel)]=\"actor.role\"                 [ngModelOptions]=\"{ updateOn: 'blur' }\"                 appUniqueRole>          @if (role.pending) {            <div>Validating...</div>          }          @if (role.invalid) {            <div class=\"alert role-errors\">              @if (role.hasError('uniqueRole')) {                <div>                  Role is already taken.                </div>              }            </div>          }        </div>        @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) {          <div class=\"cross-validation-error-message alert\">            Name cannot match role.          </div>        }      </div>      <div class=\"form-group\">        <label for=\"skill\">Skill</label>        <select id=\"skill\"                name=\"skill\"                required [(ngModel)]=\"actor.skill\"                #skill=\"ngModel\">          @for (skill of skills; track $index) {            <option [value]=\"skill\">{{ skill }}</option>          }        </select>        @if (skill.errors && skill.touched) {          <div class=\"alert\">            @if (skill.errors['required']) {              <div>Skill is required.</div>            }          </div>        }      </div>      <p>Complete the form to enable the Submit button.</p>      <button type=\"submit\"              [disabled]=\"actorForm.invalid\">Submit      </button>      <button type=\"button\"              (click)=\"actorForm.resetForm({})\">Reset      </button>    </div>    @if (actorForm.submitted) {      <div class=\"submitted-message\">        <p>You've submitted your actor, {{ actorForm.value.name }}!</p>        <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button>      </div>    }  </form></div>\n\n```\n\n**HELPFUL:** Notice that the custom validation directive is instantiated with `useExisting` rather than `useClass`.\nThe registered validator must be _this instance_ of the `ForbiddenValidatorDirective` â€”the instance in the form with its `forbiddenName` property bound to \"bob\".\n\nIf you were to replace `useExisting` with `useClass`, then you'd be registering a new class instance, one that doesn't have a `forbiddenName`.\n\n## [Control status CSS classes](https://angular.dev/guide/forms/form-validation\\#control-status-css-classes)\n\nAngular automatically mirrors many control properties onto the form control element as CSS classes.\nUse these classes to style form control elements according to the state of the form.\nThe following classes are currently supported.\n\n- `.ng-valid`\n- `.ng-invalid`\n- `.ng-pending`\n- `.ng-pristine`\n- `.ng-dirty`\n- `.ng-untouched`\n- `.ng-touched`\n- `.ng-submitted` (enclosing form element only)\n\nIn the following example, the actor form uses the `.ng-valid` and `.ng-invalid` classes to\nset the color of each form control's border.\n\n### forms.css (status classes)\n\n```\n      .ng-valid[required], .ng-valid.required  {  border-left: 5px solid #42A948; /* green */}.ng-invalid:not(form)  {  border-left: 5px solid #a94442; /* red */}.alert div {  background-color: #fed3d3;  color: #820000;  padding: 1rem;  margin-bottom: 1rem;}.form-group {  margin-bottom: 1rem;}label {  display: block;  margin-bottom: .5rem;}select {  width: 100%;  padding: .5rem;}\n\n```\n\ncheck\n\n## [Cross-field validation](https://angular.dev/guide/forms/form-validation\\#cross-field-validation)\n\nA cross-field validator is a [custom validator](https://angular.dev/guide/forms/form-validation#defining-custom-validators \"Read\") that compares the values of different fields in a form and accepts or rejects them in combination.\nFor example, you might have a form that offers mutually incompatible options, so that if the user can choose A or B, but not both.\nSome field values might also depend on others; a user might be allowed to choose B only if A is also chosen.\n\nThe following cross validation examples show how to do the following:\n\n- Validate reactive or template-based form input based on the values of two sibling controls,\n- Show a descriptive error message after the user interacted with the form and the validation failed.\n\nThe examples use cross-validation to ensure that actors do not reuse the same name in their role by filling out the Actor Form.\nThe validators do this by checking that the actor names and roles do not match.\n\n### [Adding cross-validation to reactive forms](https://angular.dev/guide/forms/form-validation\\#adding-cross-validation-to-reactive-forms)\n\nThe form has the following structure:\n\n```\n      const actorForm = new FormGroup({  'name': new FormControl(),  'role': new FormControl(),  'skill': new FormControl()});\n\n```\n\ncheck\n\nNotice that the `name` and `role` are sibling controls.\nTo evaluate both controls in a single custom validator, you must perform the validation in a common ancestor control: the `FormGroup`.\nYou query the `FormGroup` for its child controls so that you can compare their values.\n\nTo add a validator to the `FormGroup`, pass the new validator in as the second argument on creation.\n\n```\n      const actorForm = new FormGroup({  'name': new FormControl(),  'role': new FormControl(),  'skill': new FormControl()}, { validators: unambiguousRoleValidator });\n\n```\n\ncheck\n\nThe validator code is as follows.\n\ncheck\n\n```\n      import {Directive} from '@angular/core';import {  AbstractControl,  NG_VALIDATORS,  ValidationErrors,  Validator,  ValidatorFn,} from '@angular/forms';/** An actor's name can't match the actor's role */export const unambiguousRoleValidator: ValidatorFn = (  control: AbstractControl,): ValidationErrors | null => {  const name = control.get('name');  const role = control.get('role');  return name && role && name.value === role.value ? {unambiguousRole: true} : null;};@Directive({  selector: '[appUnambiguousRole]',  providers: [    {provide: NG_VALIDATORS, useExisting: UnambiguousRoleValidatorDirective, multi: true},  ],})export class UnambiguousRoleValidatorDirective implements Validator {  validate(control: AbstractControl): ValidationErrors | null {    return unambiguousRoleValidator(control);  }}\n\n```\n\nThe `unambiguousRoleValidator` validator implements the `ValidatorFn` interface.\nIt takes an Angular control object as an argument and returns either null if the form is valid, or `ValidationErrors` otherwise.\n\nThe validator retrieves the child controls by calling the `FormGroup`'s [get](https://angular.dev/guide/forms/api/forms/AbstractControl#get) method, then compares the values of the `name` and `role` controls.\n\nIf the values do not match, the role is unambiguous, both are valid, and the validator returns null.\nIf they do match, the actor's role is ambiguous and the validator must mark the form as invalid by returning an error object.\n\nTo provide better user experience, the template shows an appropriate error message when the form is invalid.\n\ncheck\n\n```\n      <div class=\"container\">  <h2>Reactive Form</h2>  <form [formGroup]=\"actorForm\" #formDir=\"ngForm\">    <div [hidden]=\"formDir.submitted\">      <div class=\"cross-validation\"           [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\">        <div class=\"form-group\">          <label for=\"name\">Name</label>          <input type=\"text\" id=\"name\" class=\"form-control\"                 formControlName=\"name\" required>          @if (name.invalid && (name.dirty || name.touched)) {            <div class=\"alert alert-danger\">              @if (name.hasError('required')) {                <div>                  Name is required.                </div>              }              @if (name.hasError('minlength')) {                <div>                  Name must be at least 4 characters long.                </div>              }              @if (name.hasError('forbiddenName')) {                <div>                  Name cannot be Bob.                </div>              }            </div>          }        </div>        <div class=\"form-group\">          <label for=\"role\">Role</label>          <input type=\"text\" id=\"role\" class=\"form-control\"                 formControlName=\"role\">          @if (role.pending) {            <div>Validating...</div>          }          @if (role.invalid) {            <div class=\"alert alert-danger role-errors\">              @if (role.hasError('uniqueRole')) {                <div>                  Role is already taken.                </div>              }            </div>          }        </div>        @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) {          <div class=\"cross-validation-error-message alert alert-danger\">            Name cannot match role or audiences will be confused.          </div>        }      </div>      <div class=\"form-group\">        <label for=\"skill\">Skill</label>        <select id=\"skill\" class=\"form-control\"                formControlName=\"skill\" required>          @for (skill of skills; track $index) {            <option [value]=\"skill\">{{ skill }}</option>          }        </select>        @if (skill.invalid && skill.touched) {          <div class=\"alert alert-danger\">            @if (skill.hasError('required')) {              <div>Skill is required.</div>            }          </div>        }      </div>      <p>Complete the form to enable the Submit button.</p>      <button type=\"submit\"              class=\"btn btn-default\"              [disabled]=\"actorForm.invalid\">Submit      </button>      <button type=\"button\" class=\"btn btn-default\"              (click)=\"formDir.resetForm({})\">Reset      </button>    </div>  </form>  @if (formDir.submitted) {    <div class=\"submitted-message\">      <p>You've submitted your actor, {{ actorForm.value.name }}!</p>      <button type=\"button\" (click)=\"formDir.resetForm({})\">Add new actor</button>    </div>  }</div>\n\n```\n\nThis `*ngIf` displays the error if the `FormGroup` has the cross validation error returned by the `unambiguousRoleValidator` validator, but only if the user finished [interacting with the form](https://angular.dev/guide/forms/form-validation#control-status-css-classes).\n\n### [Adding cross-validation to template-driven forms](https://angular.dev/guide/forms/form-validation\\#adding-cross-validation-to-template-driven-forms)\n\nFor a template-driven form, you must create a directive to wrap the validator function.\nYou provide that directive as the validator using the [`NG_VALIDATORS` token](https://angular.dev/api/forms/NG_VALIDATORS), as shown in the following example.\n\ncheck\n\n```\n      import {Directive} from '@angular/core';import {  AbstractControl,  NG_VALIDATORS,  ValidationErrors,  Validator,  ValidatorFn,} from '@angular/forms';/** An actor's name can't match the actor's role */export const unambiguousRoleValidator: ValidatorFn = (  control: AbstractControl,): ValidationErrors | null => {  const name = control.get('name');  const role = control.get('role');  return name && role && name.value === role.value ? {unambiguousRole: true} : null;};@Directive({  selector: '[appUnambiguousRole]',  providers: [    {provide: NG_VALIDATORS, useExisting: UnambiguousRoleValidatorDirective, multi: true},  ],})export class UnambiguousRoleValidatorDirective implements Validator {  validate(control: AbstractControl): ValidationErrors | null {    return unambiguousRoleValidator(control);  }}\n\n```\n\nYou must add the new directive to the HTML template.\nBecause the validator must be registered at the highest level in the form, the following template puts the directive on the `form` tag.\n\ncheck\n\n```\n      <div>  <h2>Template-Driven Form</h2>  <form #actorForm=\"ngForm\" appUnambiguousRole>    <div [hidden]=\"actorForm.submitted\">      <div class=\"cross-validation\"           [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\">        <div class=\"form-group\">          <label for=\"name\">Name</label>          <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\"                 required minlength=\"4\" appForbiddenName=\"bob\"                 [(ngModel)]=\"actor.name\" #name=\"ngModel\">          @if (name.invalid && (name.dirty || name.touched)) {            <div class=\"alert\">              @if (name.hasError('required')) {                <div>                  Name is required.                </div>              }              @if (name.hasError('minlength')) {                <div>                  Name must be at least 4 characters long.                </div>              }              @if (name.hasError('forbiddenName')) {                <div>                  Name cannot be Bob.                </div>              }            </div>          }        </div>        <div class=\"form-group\">          <label for=\"role\">Role</label>          <input type=\"text\"                 id=\"role\"                 name=\"role\"                 #role=\"ngModel\"                 [(ngModel)]=\"actor.role\"                 [ngModelOptions]=\"{ updateOn: 'blur' }\"                 appUniqueRole>          @if (role.pending) {            <div>Validating...</div>          }          @if (role.invalid) {            <div class=\"alert role-errors\">              @if (role.hasError('uniqueRole')) {                <div>                  Role is already taken.                </div>              }            </div>          }        </div>        @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) {          <div class=\"cross-validation-error-message alert\">            Name cannot match role.          </div>        }      </div>      <div class=\"form-group\">        <label for=\"skill\">Skill</label>        <select id=\"skill\"                name=\"skill\"                required [(ngModel)]=\"actor.skill\"                #skill=\"ngModel\">          @for (skill of skills; track $index) {            <option [value]=\"skill\">{{ skill }}</option>          }        </select>        @if (skill.errors && skill.touched) {          <div class=\"alert\">            @if (skill.errors['required']) {              <div>Skill is required.</div>            }          </div>        }      </div>      <p>Complete the form to enable the Submit button.</p>      <button type=\"submit\"              [disabled]=\"actorForm.invalid\">Submit      </button>      <button type=\"button\"              (click)=\"actorForm.resetForm({})\">Reset      </button>    </div>    @if (actorForm.submitted) {      <div class=\"submitted-message\">        <p>You've submitted your actor, {{ actorForm.value.name }}!</p>        <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button>      </div>    }  </form></div>\n\n```\n\nTo provide better user experience, an appropriate error message appears when the form is invalid.\n\ncheck\n\n```\n      <div>  <h2>Template-Driven Form</h2>  <form #actorForm=\"ngForm\" appUnambiguousRole>    <div [hidden]=\"actorForm.submitted\">      <div class=\"cross-validation\"           [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\">        <div class=\"form-group\">          <label for=\"name\">Name</label>          <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\"                 required minlength=\"4\" appForbiddenName=\"bob\"                 [(ngModel)]=\"actor.name\" #name=\"ngModel\">          @if (name.invalid && (name.dirty || name.touched)) {            <div class=\"alert\">              @if (name.hasError('required')) {                <div>                  Name is required.                </div>              }              @if (name.hasError('minlength')) {                <div>                  Name must be at least 4 characters long.                </div>              }              @if (name.hasError('forbiddenName')) {                <div>                  Name cannot be Bob.                </div>              }            </div>          }        </div>        <div class=\"form-group\">          <label for=\"role\">Role</label>          <input type=\"text\"                 id=\"role\"                 name=\"role\"                 #role=\"ngModel\"                 [(ngModel)]=\"actor.role\"                 [ngModelOptions]=\"{ updateOn: 'blur' }\"                 appUniqueRole>          @if (role.pending) {            <div>Validating...</div>          }          @if (role.invalid) {            <div class=\"alert role-errors\">              @if (role.hasError('uniqueRole')) {                <div>                  Role is already taken.                </div>              }            </div>          }        </div>        @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) {          <div class=\"cross-validation-error-message alert\">            Name cannot match role.          </div>        }      </div>      <div class=\"form-group\">        <label for=\"skill\">Skill</label>        <select id=\"skill\"                name=\"skill\"                required [(ngModel)]=\"actor.skill\"                #skill=\"ngModel\">          @for (skill of skills; track $index) {            <option [value]=\"skill\">{{ skill }}</option>          }        </select>        @if (skill.errors && skill.touched) {          <div class=\"alert\">            @if (skill.errors['required']) {              <div>Skill is required.</div>            }          </div>        }      </div>      <p>Complete the form to enable the Submit button.</p>      <button type=\"submit\"              [disabled]=\"actorForm.invalid\">Submit      </button>      <button type=\"button\"              (click)=\"actorForm.resetForm({})\">Reset      </button>    </div>    @if (actorForm.submitted) {      <div class=\"submitted-message\">        <p>You've submitted your actor, {{ actorForm.value.name }}!</p>        <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button>      </div>    }  </form></div>\n\n```\n\nThis is the same in both template-driven and reactive forms.\n\n## [Creating asynchronous validators](https://angular.dev/guide/forms/form-validation\\#creating-asynchronous-validators)\n\nAsynchronous validators implement the `AsyncValidatorFn` and `AsyncValidator` interfaces.\nThese are very similar to their synchronous counterparts, with the following differences.\n\n- The `validate()` functions must return a Promise or an observable,\n- The observable returned must be finite, meaning it must complete at some point.\nTo convert an infinite observable into a finite one, pipe the observable through a filtering operator such as `first`, `last`, `take`, or `takeUntil`.\n\nAsynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful.\nThis check lets forms avoid potentially expensive async validation processes (such as an HTTP request) if the more basic validation methods have already found invalid input.\n\nAfter asynchronous validation begins, the form control enters a `pending` state.\nInspect the control's `pending` property and use it to give visual feedback about the ongoing validation operation.\n\nA common UI pattern is to show a spinner while the async validation is being performed.\nThe following example shows how to achieve this in a template-driven form.\n\n```\n      <input [(ngModel)]=\"name\" #model=\"ngModel\" appSomeAsyncValidator><app-spinner *ngIf=\"model.pending\"></app-spinner>\n\n```\n\ncheck\n\n### [Implementing a custom async validator](https://angular.dev/guide/forms/form-validation\\#implementing-a-custom-async-validator)\n\nIn the following example, an async validator ensures that actors are cast for a role that is not already taken.\nNew actors are constantly auditioning and old actors are retiring, so the list of available roles cannot be retrieved ahead of time.\nTo validate the potential role entry, the validator must initiate an asynchronous operation to consult a central database of all currently cast actors.\n\nThe following code creates the validator class, `UniqueRoleValidator`, which implements the `AsyncValidator` interface.\n\ncheck\n\n```\n      import {Directive, forwardRef, inject, Injectable} from '@angular/core';import {  AsyncValidator,  AbstractControl,  NG_ASYNC_VALIDATORS,  ValidationErrors,} from '@angular/forms';import {catchError, map} from 'rxjs/operators';import {ActorsService} from './actors.service';import {Observable, of} from 'rxjs';@Injectable({providedIn: 'root'})export class UniqueRoleValidator implements AsyncValidator {  private readonly actorsService = inject(ActorsService);  validate(control: AbstractControl): Observable<ValidationErrors | null> {    return this.actorsService.isRoleTaken(control.value).pipe(      map((isTaken) => (isTaken ? {uniqueRole: true} : null)),      catchError(() => of(null)),    );  }}@Directive({  selector: '[appUniqueRole]',  providers: [    {      provide: NG_ASYNC_VALIDATORS,      useExisting: forwardRef(() => UniqueRoleValidatorDirective),      multi: true,    },  ],})export class UniqueRoleValidatorDirective implements AsyncValidator {  private readonly validator = inject(UniqueRoleValidator);  validate(control: AbstractControl): Observable<ValidationErrors | null> {    return this.validator.validate(control);  }}\n\n```\n\nThe `actorsService` property is initialized with an instace of the `ActorsService` token, which defines the following interface.\n\n```\n      interface ActorsService {  isRoleTaken: (role: string) => Observable<boolean>;}\n\n```\n\ncheck\n\nIn a real world application, the `ActorsService` would be responsible for making an HTTP request to the actor database to check if the role is available.\nFrom the validator's point of view, the actual implementation of the service is not important, so the example can just code against the `ActorsService` interface.\n\nAs the validation begins, the `UnambiguousRoleValidator` delegates to the `ActorsService` `isRoleTaken()` method with the current control value.\nAt this point the control is marked as `pending` and remains in this state until the observable chain returned from the `validate()` method completes.\n\nThe `isRoleTaken()` method dispatches an HTTP request that checks if the role is available, and returns `Observable<boolean>` as the result.\nThe `validate()` method pipes the response through the `map` operator and transforms it into a validation result.\n\nThe method then, like any validator, returns `null` if the form is valid, and `ValidationErrors` if it is not.\nThis validator handles any potential errors with the `catchError` operator.\nIn this case, the validator treats the `isRoleTaken()` error as a successful validation, because failure to make a validation request does not necessarily mean that the role is invalid.\nYou could handle the error differently and return the `ValidationError` object instead.\n\nAfter some time passes, the observable chain completes and the asynchronous validation is done.\nThe `pending` flag is set to `false`, and the form validity is updated.\n\n### [Adding async validators to reactive forms](https://angular.dev/guide/forms/form-validation\\#adding-async-validators-to-reactive-forms)\n\nTo use an async validator in reactive forms, begin by injecting the validator into a property of the component class.\n\ncheck\n\n```\n      import {Component, inject} from '@angular/core';import {FormControl, FormGroup, ReactiveFormsModule, Validators} from '@angular/forms';import {forbiddenNameValidator} from '../shared/forbidden-name.directive';import {UniqueRoleValidator} from '../shared/role.directive';@Component({  selector: 'app-actor-form-reactive',  templateUrl: './actor-form-reactive.component.html',  styleUrls: ['./actor-form-reactive.component.css'],  imports: [ReactiveFormsModule],})export class HeroFormReactiveComponent {  roleValidator = inject(UniqueRoleValidator);  skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting'];  actor = {name: 'Tom Cruise', role: 'Romeo', skill: this.skills[3]};  actorForm!: FormGroup;  ngOnInit(): void {    const roleControl = new FormControl('', {      asyncValidators: [this.roleValidator.validate.bind(this.roleValidator)],      updateOn: 'blur',    });    roleControl.setValue(this.actor.role);    this.actorForm = new FormGroup({      name: new FormControl(this.actor.name, [        Validators.required,        Validators.minLength(4),        forbiddenNameValidator(/bob/i),      ]),      role: roleControl,      skill: new FormControl(this.actor.skill, Validators.required),    });  }  get name() {    return this.actorForm.get('name');  }  get skill() {    return this.actorForm.get('skill');  }  get role() {    return this.actorForm.get('role');  }}\n\n```\n\nThen, pass the validator function directly to the `FormControl` to apply it.\n\nIn the following example, the `validate` function of `UnambiguousRoleValidator` is applied to `roleControl` by passing it to the control's `asyncValidators` option and binding it to the instance of `UnambiguousRoleValidator` that was injected into `ActorFormReactiveComponent`.\nThe value of `asyncValidators` can be either a single async validator function, or an array of functions.\nTo learn more about `FormControl` options, see the [AbstractControlOptions](https://angular.dev/guide/forms/api/forms/AbstractControlOptions) API reference.\n\ncheck\n\n```\n      import {Component, inject} from '@angular/core';import {FormControl, FormGroup, ReactiveFormsModule, Validators} from '@angular/forms';import {forbiddenNameValidator} from '../shared/forbidden-name.directive';import {UniqueRoleValidator} from '../shared/role.directive';@Component({  selector: 'app-actor-form-reactive',  templateUrl: './actor-form-reactive.component.html',  styleUrls: ['./actor-form-reactive.component.css'],  imports: [ReactiveFormsModule],})export class HeroFormReactiveComponent {  roleValidator = inject(UniqueRoleValidator);  skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting'];  actor = {name: 'Tom Cruise', role: 'Romeo', skill: this.skills[3]};  actorForm!: FormGroup;  ngOnInit(): void {    const roleControl = new FormControl('', {      asyncValidators: [this.roleValidator.validate.bind(this.roleValidator)],      updateOn: 'blur',    });    roleControl.setValue(this.actor.role);    this.actorForm = new FormGroup({      name: new FormControl(this.actor.name, [        Validators.required,        Validators.minLength(4),        forbiddenNameValidator(/bob/i),      ]),      role: roleControl,      skill: new FormControl(this.actor.skill, Validators.required),    });  }  get name() {    return this.actorForm.get('name');  }  get skill() {    return this.actorForm.get('skill');  }  get role() {    return this.actorForm.get('role');  }}\n\n```\n\n### [Adding async validators to template-driven forms](https://angular.dev/guide/forms/form-validation\\#adding-async-validators-to-template-driven-forms)\n\nTo use an async validator in template-driven forms, create a new directive and register the `NG_ASYNC_VALIDATORS` provider on it.\n\nIn the example below, the directive injects the `UniqueRoleValidator` class that contains the actual validation logic and invokes it in the `validate` function, triggered by Angular when validation should happen.\n\ncheck\n\n```\n      import {Directive, forwardRef, inject, Injectable} from '@angular/core';import {  AsyncValidator,  AbstractControl,  NG_ASYNC_VALIDATORS,  ValidationErrors,} from '@angular/forms';import {catchError, map} from 'rxjs/operators';import {ActorsService} from './actors.service';import {Observable, of} from 'rxjs';@Injectable({providedIn: 'root'})export class UniqueRoleValidator implements AsyncValidator {  private readonly actorsService = inject(ActorsService);  validate(control: AbstractControl): Observable<ValidationErrors | null> {    return this.actorsService.isRoleTaken(control.value).pipe(      map((isTaken) => (isTaken ? {uniqueRole: true} : null)),      catchError(() => of(null)),    );  }}@Directive({  selector: '[appUniqueRole]',  providers: [    {      provide: NG_ASYNC_VALIDATORS,      useExisting: forwardRef(() => UniqueRoleValidatorDirective),      multi: true,    },  ],})export class UniqueRoleValidatorDirective implements AsyncValidator {  private readonly validator = inject(UniqueRoleValidator);  validate(control: AbstractControl): Observable<ValidationErrors | null> {    return this.validator.validate(control);  }}\n\n```\n\nThen, as with synchronous validators, add the directive's selector to an input to activate it.\n\ncheck\n\n```\n      <div>  <h2>Template-Driven Form</h2>  <form #actorForm=\"ngForm\" appUnambiguousRole>    <div [hidden]=\"actorForm.submitted\">      <div class=\"cross-validation\"           [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\">        <div class=\"form-group\">          <label for=\"name\">Name</label>          <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\"                 required minlength=\"4\" appForbiddenName=\"bob\"                 [(ngModel)]=\"actor.name\" #name=\"ngModel\">          @if (name.invalid && (name.dirty || name.touched)) {            <div class=\"alert\">              @if (name.hasError('required')) {                <div>                  Name is required.                </div>              }              @if (name.hasError('minlength')) {                <div>                  Name must be at least 4 characters long.                </div>              }              @if (name.hasError('forbiddenName')) {                <div>                  Name cannot be Bob.                </div>              }            </div>          }        </div>        <div class=\"form-group\">          <label for=\"role\">Role</label>          <input type=\"text\"                 id=\"role\"                 name=\"role\"                 #role=\"ngModel\"                 [(ngModel)]=\"actor.role\"                 [ngModelOptions]=\"{ updateOn: 'blur' }\"                 appUniqueRole>          @if (role.pending) {            <div>Validating...</div>          }          @if (role.invalid) {            <div class=\"alert role-errors\">              @if (role.hasError('uniqueRole')) {                <div>                  Role is already taken.                </div>              }            </div>          }        </div>        @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) {          <div class=\"cross-validation-error-message alert\">            Name cannot match role.          </div>        }      </div>      <div class=\"form-group\">        <label for=\"skill\">Skill</label>        <select id=\"skill\"                name=\"skill\"                required [(ngModel)]=\"actor.skill\"                #skill=\"ngModel\">          @for (skill of skills; track $index) {            <option [value]=\"skill\">{{ skill }}</option>          }        </select>        @if (skill.errors && skill.touched) {          <div class=\"alert\">            @if (skill.errors['required']) {              <div>Skill is required.</div>            }          </div>        }      </div>      <p>Complete the form to enable the Submit button.</p>      <button type=\"submit\"              [disabled]=\"actorForm.invalid\">Submit      </button>      <button type=\"button\"              (click)=\"actorForm.resetForm({})\">Reset      </button>    </div>    @if (actorForm.submitted) {      <div class=\"submitted-message\">        <p>You've submitted your actor, {{ actorForm.value.name }}!</p>        <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button>      </div>    }  </form></div>\n\n```\n\n### [Optimizing performance of async validators](https://angular.dev/guide/forms/form-validation\\#optimizing-performance-of-async-validators)\n\nBy default, all validators run after every form value change.\nWith synchronous validators, this does not normally have a noticeable impact on application performance.\nAsync validators, however, commonly perform some kind of HTTP request to validate the control.\nDispatching an HTTP request after every keystroke could put a strain on the backend API, and should be avoided if possible.\n\nYou can delay updating the form validity by changing the `updateOn` property from `change` (default) to `submit` or `blur`.\n\nWith template-driven forms, set the property in the template.\n\n```\n      <input [(ngModel)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\">\n\n```\n\ncheck\n\nWith reactive forms, set the property in the `FormControl` instance.\n\n```\n      new FormControl('', {updateOn: 'blur'});\n\n```\n\ncheck\n\n## [Interaction with native HTML form validation](https://angular.dev/guide/forms/form-validation\\#interaction-with-native-html-form-validation)\n\nBy default, Angular disables [native HTML form validation](https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation) by adding the `novalidate` attribute on the enclosing `<form>` and uses directives to match these attributes with validator functions in the framework.\nIf you want to use native validation **in combination** with Angular-based validation, you can re-enable it with the `ngNativeValidate` directive.\nSee the [API docs](https://angular.dev/guide/forms/api/forms/NgForm#native-dom-validation-ui) for details.",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-c1f46fb6-7e6a-49db-8c19-e6d1bf507184.png"
  },
  "metadata": {
    "og:description": "The web development framework for building modern apps.",
    "application-name": "Angular",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:url": "https://angular.dev/",
    "twitter:description": "The web development framework for building modern apps.",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "og:url": "https://angular.dev/",
    "msapplication-TileColor": "#e90464",
    "ogDescription": "The web development framework for building modern apps.",
    "ogTitle": "Angular",
    "viewport": "width=device-width, initial-scale=1",
    "title": "Validate form input â€¢ Angular",
    "og:type": "website",
    "og:title": "Angular",
    "language": "en",
    "apple-mobile-web-app-title": "Angular",
    "twitter:title": "Angular",
    "ogUrl": "https://angular.dev/",
    "twitter:card": "summary_large_image",
    "description": "The web development framework for building modern apps.",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "theme-color": "#ffffff",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "scrapeId": "173fc063-ce23-4f93-a910-a790b513207a",
    "sourceURL": "https://angular.dev/guide/forms/form-validation",
    "url": "https://angular.dev/guide/forms/form-validation",
    "statusCode": 200
  }
}