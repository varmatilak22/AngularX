{
  "scrapeId": "412a8195-0603-41df-8ca8-03146f29ab9d",
  "sourceURL": "https://angular.dev/guide/animations/transition-and-triggers",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backAnimations\n  - [Overview](https://angular.dev/guide/animations)\n  - [Transition and Triggers](https://angular.dev/guide/animations/transition-and-triggers)\n  - [Complex Sequences](https://angular.dev/guide/animations/complex-sequences)\n  - [Reusable Animations](https://angular.dev/guide/animations/reusable-animations)\n  - [Route transition animations](https://angular.dev/guide/animations/route-animations)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nThis guide goes into depth on special transition states such as the `*` wildcard and `void`. It shows how these special states are used for elements entering and leaving a view.\nThis section also explores multiple animation triggers, animation callbacks, and sequence-based animation using keyframes.\n\n## [Predefined states and wildcard matching](https://angular.dev/guide/animations/transition-and-triggers\\#predefined-states-and-wildcard-matching)\n\nIn Angular, transition states can be defined explicitly through the [`state()`](https://angular.dev/guide/animations/api/animations/state) function, or using the predefined `*` wildcard and `void` states.\n\n### [Wildcard state](https://angular.dev/guide/animations/transition-and-triggers\\#wildcard-state)\n\nAn asterisk `*` or _wildcard_ matches any animation state.\nThis is useful for defining transitions that apply regardless of the HTML element's start or end state.\n\nFor example, a transition of `open => *` applies when the element's state changes from open to anything else.\n\n![wildcard state expressions](https://angular.dev/guide/animations/assets/images/guide/animations/wildcard-state-500.png)\n\nThe following is another code sample using the wildcard state together with the previous example using the `open` and `closed` states.\nInstead of defining each state-to-state transition pair, any transition to `closed` takes 1 second, and any transition to `open` takes 0.5 seconds.\n\nThis allows the addition of new states without having to include separate transitions for each one.\n\ncheck\n\n```\n      import {Component, Input} from '@angular/core';import {trigger, transition, state, animate, style, AnimationEvent} from '@angular/animations';@Component({  selector: 'app-open-close',  animations: [    trigger('openClose', [      // ...      state(        'open',        style({          height: '200px',          opacity: 1,          backgroundColor: 'yellow',        }),      ),      state(        'closed',        style({          height: '100px',          opacity: 0.8,          backgroundColor: 'blue',        }),      ),      transition('open => closed', [animate('1s')]),      transition('closed => open', [animate('0.5s')]),\\\n...      transition('* => closed', [animate('1s')]),      transition('* => open', [animate('0.5s')]),      transition('open <=> closed', [animate('0.5s')]),      transition('* => open', [animate('1s', style({opacity: '*'}))]),      transition('* => *', [animate('1s')]),\\\n...    ]),  ],  templateUrl: 'open-close.component.html',  styleUrls: ['open-close.component.css'],})export class OpenCloseComponent {  @Input() logging = false;  isOpen = true;  toggle() {    this.isOpen = !this.isOpen;  }  onAnimationEvent(event: AnimationEvent) {    if (!this.logging) {      return;    }    // openClose is trigger name in this example    console.warn(`Animation Trigger: ${event.triggerName}`);    // phaseName is \"start\" or \"done\"    console.warn(`Phase: ${event.phaseName}`);    // in our example, totalTime is 1000 (number of milliseconds in a second)    console.warn(`Total time: ${event.totalTime}`);    // in our example, fromState is either \"open\" or \"closed\"    console.warn(`From: ${event.fromState}`);    // in our example, toState either \"open\" or \"closed\"    console.warn(`To: ${event.toState}`);    // the HTML element itself, the button in this case    console.warn(`Element: ${event.element}`);  }}\n\n```\n\nUse a double arrow syntax to specify state-to-state transitions in both directions.\n\ncheck\n\n```\n      import {Component, Input} from '@angular/core';import {trigger, transition, state, animate, style, AnimationEvent} from '@angular/animations';@Component({  selector: 'app-open-close',  animations: [    trigger('openClose', [      // ...      state(        'open',        style({          height: '200px',          opacity: 1,          backgroundColor: 'yellow',        }),      ),      state(        'closed',        style({          height: '100px',          opacity: 0.8,          backgroundColor: 'blue',        }),      ),      transition('open => closed', [animate('1s')]),      transition('closed => open', [animate('0.5s')]),      transition('* => closed', [animate('1s')]),      transition('* => open', [animate('0.5s')]),      transition('open <=> closed', [animate('0.5s')]),      transition('* => open', [animate('1s', style({opacity: '*'}))]),      transition('* => *', [animate('1s')]),    ]),  ],  templateUrl: 'open-close.component.html',  styleUrls: ['open-close.component.css'],})export class OpenCloseComponent {  @Input() logging = false;  isOpen = true;  toggle() {    this.isOpen = !this.isOpen;  }  onAnimationEvent(event: AnimationEvent) {    if (!this.logging) {      return;    }    // openClose is trigger name in this example    console.warn(`Animation Trigger: ${event.triggerName}`);    // phaseName is \"start\" or \"done\"    console.warn(`Phase: ${event.phaseName}`);    // in our example, totalTime is 1000 (number of milliseconds in a second)    console.warn(`Total time: ${event.totalTime}`);    // in our example, fromState is either \"open\" or \"closed\"    console.warn(`From: ${event.fromState}`);    // in our example, toState either \"open\" or \"closed\"    console.warn(`To: ${event.toState}`);    // the HTML element itself, the button in this case    console.warn(`Element: ${event.element}`);  }}\n\n```\n\n### [Use wildcard state with multiple transition states](https://angular.dev/guide/animations/transition-and-triggers\\#use-wildcard-state-with-multiple-transition-states)\n\nIn the two-state button example, the wildcard isn't that useful because there are only two possible states, `open` and `closed`.\nIn general, use wildcard states when an element has multiple potential states that it can change to.\nIf the button can change from `open` to either `closed` or something like `inProgress`, using a wildcard state could reduce the amount of coding needed.\n\n![wildcard state with 3 states](https://angular.dev/guide/animations/assets/images/guide/animations/wildcard-3-states.png)\n\ncheck\n\n```\n      import {Component, Input} from '@angular/core';import {trigger, transition, state, animate, style, AnimationEvent} from '@angular/animations';@Component({  selector: 'app-open-close',  animations: [    trigger('openClose', [      // ...      state(        'open',        style({          height: '200px',          opacity: 1,          backgroundColor: 'yellow',        }),      ),      state(        'closed',        style({          height: '100px',          opacity: 0.8,          backgroundColor: 'blue',        }),      ),      transition('open => closed', [animate('1s')]),      transition('closed => open', [animate('0.5s')]),      transition('* => closed', [animate('1s')]),      transition('* => open', [animate('0.5s')]),      transition('open <=> closed', [animate('0.5s')]),      transition('* => open', [animate('1s', style({opacity: '*'}))]),      transition('* => *', [animate('1s')]),    ]),  ],  templateUrl: 'open-close.component.html',  styleUrls: ['open-close.component.css'],})export class OpenCloseComponent {  @Input() logging = false;  isOpen = true;  toggle() {    this.isOpen = !this.isOpen;  }  onAnimationEvent(event: AnimationEvent) {    if (!this.logging) {      return;    }    // openClose is trigger name in this example    console.warn(`Animation Trigger: ${event.triggerName}`);    // phaseName is \"start\" or \"done\"    console.warn(`Phase: ${event.phaseName}`);    // in our example, totalTime is 1000 (number of milliseconds in a second)    console.warn(`Total time: ${event.totalTime}`);    // in our example, fromState is either \"open\" or \"closed\"    console.warn(`From: ${event.fromState}`);    // in our example, toState either \"open\" or \"closed\"    console.warn(`To: ${event.toState}`);    // the HTML element itself, the button in this case    console.warn(`Element: ${event.element}`);  }}\n\n```\n\nThe `* => *` transition applies when any change between two states takes place.\n\nTransitions are matched in the order in which they are defined.\nThus, you can apply other transitions on top of the `* => *` transition.\nFor example, define style changes or animations that would apply just to `open => closed`, then use `* => *` as a fallback for state pairings that aren't otherwise called out.\n\nTo do this, list the more specific transitions _before_ `* => *`.\n\n### [Use wildcards with styles](https://angular.dev/guide/animations/transition-and-triggers\\#use-wildcards-with-styles)\n\nUse the wildcard `*` with a style to tell the animation to use whatever the current style value is, and animate with that.\nWildcard is a fallback value that's used if the state being animated isn't declared within the trigger.\n\ncheck\n\n```\n      import {Component, Input} from '@angular/core';import {trigger, transition, state, animate, style, AnimationEvent} from '@angular/animations';@Component({  selector: 'app-open-close',  animations: [    trigger('openClose', [      // ...      state(        'open',        style({          height: '200px',          opacity: 1,          backgroundColor: 'yellow',        }),      ),      state(        'closed',        style({          height: '100px',          opacity: 0.8,          backgroundColor: 'blue',        }),      ),      transition('open => closed', [animate('1s')]),      transition('closed => open', [animate('0.5s')]),      transition('* => closed', [animate('1s')]),      transition('* => open', [animate('0.5s')]),      transition('open <=> closed', [animate('0.5s')]),      transition('* => open', [animate('1s', style({opacity: '*'}))]),      transition('* => *', [animate('1s')]),    ]),  ],  templateUrl: 'open-close.component.html',  styleUrls: ['open-close.component.css'],})export class OpenCloseComponent {  @Input() logging = false;  isOpen = true;  toggle() {    this.isOpen = !this.isOpen;  }  onAnimationEvent(event: AnimationEvent) {    if (!this.logging) {      return;    }    // openClose is trigger name in this example    console.warn(`Animation Trigger: ${event.triggerName}`);    // phaseName is \"start\" or \"done\"    console.warn(`Phase: ${event.phaseName}`);    // in our example, totalTime is 1000 (number of milliseconds in a second)    console.warn(`Total time: ${event.totalTime}`);    // in our example, fromState is either \"open\" or \"closed\"    console.warn(`From: ${event.fromState}`);    // in our example, toState either \"open\" or \"closed\"    console.warn(`To: ${event.toState}`);    // the HTML element itself, the button in this case    console.warn(`Element: ${event.element}`);  }}\n\n```\n\n### [Void state](https://angular.dev/guide/animations/transition-and-triggers\\#void-state)\n\nUse the `void` state to configure transitions for an element that is entering or leaving a page.\nSee [Animating entering and leaving a view](https://angular.dev/guide/animations/guide/animations/transition-and-triggers#aliases-enter-and-leave).\n\n### [Combine wildcard and void states](https://angular.dev/guide/animations/transition-and-triggers\\#combine-wildcard-and-void-states)\n\nCombine wildcard and void states in a transition to trigger animations that enter and leave the page:\n\n- A transition of `* => void` applies when the element leaves a view, regardless of what state it was in before it left\n- A transition of `void => *` applies when the element enters a view, regardless of what state it assumes when entering\n- The wildcard state `*` matches to _any_ state, including `void`\n\n## [Animate entering and leaving a view](https://angular.dev/guide/animations/transition-and-triggers\\#animate-entering-and-leaving-a-view)\n\nThis section shows how to animate elements entering or leaving a page.\n\nAdd a new behavior:\n\n- When you add a hero to the list of heroes, it appears to fly onto the page from the left\n- When you remove a hero from the list, it appears to fly out to the right\n\ncheck\n\n```\n      import {Component, Input, Output, EventEmitter} from '@angular/core';import {trigger, state, style, animate, transition} from '@angular/animations';import {Hero} from './hero';@Component({  selector: 'app-hero-list-enter-leave',  template: `    <ul class=\"heroes\">      @for (hero of heroes; track hero) {        <li [@flyInOut]=\"'in'\">          <button class=\"inner\" type=\"button\" (click)=\"removeHero(hero.id)\">            <span class=\"badge\">{{ hero.id }}</span>            <span class=\"name\">{{ hero.name }}</span>          </button>        </li>      }    </ul>  `,  styleUrls: ['./hero-list-page.component.css'],  animations: [    trigger('flyInOut', [      state('in', style({transform: 'translateX(0)'})),      transition('void => *', [style({transform: 'translateX(-100%)'}), animate(100)]),      transition('* => void', [animate(100, style({transform: 'translateX(100%)'}))]),    ]),  ],})export class HeroListEnterLeaveComponent {  @Input() heroes: Hero[] = [];  @Output() remove = new EventEmitter<number>();  removeHero(id: number) {    this.remove.emit(id);  }}\n\n```\n\nIn the preceding code, you applied the `void` state when the HTML element isn't attached to a view.\n\n## [Aliases :enter and :leave](https://angular.dev/guide/animations/transition-and-triggers\\#aliases-enter-and-leave)\n\n`:enter` and `:leave` are aliases for the `void => *` and `* => void` transitions.\nThese aliases are used by several animation functions.\n\n```\n      transition ( ':enter', [ â€¦ ] );  // alias for void => *transition ( ':leave', [ â€¦ ] );  // alias for * => void\n\n```\n\ncheck\n\nIt's harder to target an element that is entering a view because it isn't in the DOM yet.\nUse the aliases `:enter` and `:leave` to target HTML elements that are inserted or removed from a view.\n\n### [Use `*ngIf` and `*ngFor` with :enter and :leave](https://angular.dev/guide/animations/transition-and-triggers\\#use-ngif-and-ngfor-with-enter-and-leave)\n\nThe `:enter` transition runs when any `*ngIf` or `*ngFor` views are placed on the page, and `:leave` runs when those views are removed from the page.\n\n**IMPORTANT:** Entering/leaving behaviors can sometime be confusing.\nAs a rule of thumb consider that any element being added to the DOM by Angular passes via the `:enter` transition. Only elements being directly removed from the DOM by Angular pass via the `:leave` transition. For example, an element's view is removed from the DOM because its parent is being removed from the DOM.\n\nThis example has a special trigger for the enter and leave animation called `myInsertRemoveTrigger`.\nThe HTML template contains the following code.\n\ncheck\n\n```\n      <h2>Insert/Remove</h2><nav>  <button type=\"button\" (click)=\"toggle()\">Toggle Insert/Remove</button></nav>@if (isShown) {  <div @myInsertRemoveTrigger class=\"insert-remove-container\">    <p>The box is inserted</p>  </div>}\n\n```\n\nIn the component file, the `:enter` transition sets an initial opacity of 0. It then animates it to change that opacity to 1 as the element is inserted into the view.\n\ncheck\n\n```\n      import {Component} from '@angular/core';import {trigger, transition, animate, style} from '@angular/animations';@Component({  selector: 'app-insert-remove',  animations: [    trigger('myInsertRemoveTrigger', [      transition(':enter', [style({opacity: 0}), animate('100ms', style({opacity: 1}))]),      transition(':leave', [animate('100ms', style({opacity: 0}))]),    ]),  ],  templateUrl: 'insert-remove.component.html',  styleUrls: ['insert-remove.component.css'],})export class InsertRemoveComponent {  isShown = false;  toggle() {    this.isShown = !this.isShown;  }}\n\n```\n\nNote that this example doesn't need to use [`state()`](https://angular.dev/guide/animations/api/animations/state).\n\n## [Transition :increment and :decrement](https://angular.dev/guide/animations/transition-and-triggers\\#transition-increment-and-decrement)\n\nThe `transition()` function takes other selector values, `:increment` and `:decrement`.\nUse these to kick off a transition when a numeric value has increased or decreased in value.\n\n**HELPFUL:** The following example uses `query()` and `stagger()` methods.\nFor more information on these methods, see the [complex sequences](https://angular.dev/guide/animations/guide/animations/complex-sequences) page.\n\ncheck\n\n```\n      import {Component, HostBinding, OnInit} from '@angular/core';import {trigger, transition, animate, style, query, stagger} from '@angular/animations';import {HEROES} from './mock-heroes';import {Hero} from './hero';@Component({  selector: 'app-hero-list-page',  templateUrl: 'hero-list-page.component.html',  styleUrls: ['hero-list-page.component.css'],  animations: [    trigger('pageAnimations', [      transition(':enter', [        query('.hero', [          style({opacity: 0, transform: 'translateY(-100px)'}),          stagger(30, [            animate('500ms cubic-bezier(0.35, 0, 0.25, 1)', style({opacity: 1, transform: 'none'})),          ]),        ]),      ]),    ]),    trigger('filterAnimation', [      transition(':enter, * => 0, * => -1', []),      transition(':increment', [        query(          ':enter',          [            style({opacity: 0, width: 0}),            stagger(50, [animate('300ms ease-out', style({opacity: 1, width: '*'}))]),          ],          {optional: true},        ),      ]),      transition(':decrement', [        query(':leave', [stagger(50, [animate('300ms ease-out', style({opacity: 0, width: 0}))])]),      ]),    ]),  ],})export class HeroListPageComponent implements OnInit {  @HostBinding('@pageAnimations')  public animatePage = true;  heroesTotal = -1;  get heroes() {    return this._heroes;  }  private _heroes: Hero[] = [];  ngOnInit() {    this._heroes = HEROES;  }  updateCriteria(criteria: string) {    criteria = criteria ? criteria.trim() : '';    this._heroes = HEROES.filter((hero) =>      hero.name.toLowerCase().includes(criteria.toLowerCase()),    );    const newTotal = this.heroes.length;    if (this.heroesTotal !== newTotal) {      this.heroesTotal = newTotal;    } else if (!criteria) {      this.heroesTotal = -1;    }  }}\n\n```\n\n## [Boolean values in transitions](https://angular.dev/guide/animations/transition-and-triggers\\#boolean-values-in-transitions)\n\nIf a trigger contains a Boolean value as a binding value, then this value can be matched using a `transition()` expression that compares `true` and `false`, or `1` and `0`.\n\ncheck\n\n```\n      <nav>  <button type=\"button\" (click)=\"toggle()\">Toggle Boolean/Close</button></nav><div [@openClose]=\"isOpen ? true : false\" class=\"open-close-container\">  <p>The box is now {{ isOpen ? 'Open' : 'Closed' }}!</p>\n...</div>\n\n```\n\nIn the code snippet above, the HTML template binds a `<div>` element to a trigger named `openClose` with a status expression of `isOpen`, and with possible values of `true` and `false`.\nThis pattern is an alternative to the practice of creating two named states like `open` and `close`.\n\nInside the `@Component` metadata under the `animations:` property, when the state evaluates to `true`, the associated HTML element's height is a wildcard style or default.\nIn this case, the animation uses whatever height the element already had before the animation started.\nWhen the element is `closed`, the element gets animated to a height of 0, which makes it invisible.\n\ncheck\n\n```\n      import {Component} from '@angular/core';import {trigger, transition, state, animate, style} from '@angular/animations';@Component({  selector: 'app-open-close-boolean',  animations: [    trigger('openClose', [      state('true', style({height: '*'})),      state('false', style({height: '0px'})),      transition('false <=> true', animate(500)),    ]),  ],  templateUrl: 'open-close.component.2.html',  styleUrls: ['open-close.component.css'],})export class OpenCloseBooleanComponent {  isOpen = false;  toggle() {    this.isOpen = !this.isOpen;  }}\n\n```\n\n## [Multiple animation triggers](https://angular.dev/guide/animations/transition-and-triggers\\#multiple-animation-triggers)\n\nYou can define more than one animation trigger for a component.\nAttach animation triggers to different elements, and the parent-child relationships among the elements affect how and when the animations run.\n\n### [Parent-child animations](https://angular.dev/guide/animations/transition-and-triggers\\#parent-child-animations)\n\nEach time an animation is triggered in Angular, the parent animation always gets priority and child animations are blocked.\nFor a child animation to run, the parent animation must query each of the elements containing child animations. It then lets the animations run using the [`animateChild()`](https://angular.dev/guide/animations/api/animations/animateChild) function.\n\n#### [Disable an animation on an HTML element](https://angular.dev/guide/animations/transition-and-triggers\\#disable-an-animation-on-an-html-element)\n\nA special animation control binding called `@.disabled` can be placed on an HTML element to turn off animations on that element, as well as any nested elements.\nWhen true, the `@.disabled` binding prevents all animations from rendering.\n\nThe following code sample shows how to use this feature.\n\ncheck\n\n### src/app/open-close.component.html\n\n```\n      <nav>  <button type=\"button\" (click)=\"toggleAnimations()\">Toggle Animations</button>  <button type=\"button\" (click)=\"toggle()\">Toggle Open/Closed</button></nav><div [@.disabled]=\"isDisabled\">  <div [@childAnimation]=\"isOpen ? 'open' : 'closed'\"    class=\"open-close-container\">    <p>The box is now {{ isOpen ? 'Open' : 'Closed' }}!</p>  </div></div>\n\n```\n\nWhen the `@.disabled` binding is true, the `@childAnimation` trigger doesn't kick off.\n\nWhen an element within an HTML template has animations turned off using the `@.disabled` host binding, animations are turned off on all inner elements as well.\nYou can't selectively turn off multiple animations on a single element.\n\nA selective child animations can still be run on a disabled parent in one of the following ways:\n\n- A parent animation can use the [`query()`](https://angular.dev/guide/animations/api/animations/query) function to collect inner elements located in disabled areas of the HTML template.\nThose elements can still animate.\n\n- A child animation can be queried by a parent and then later animated with the `animateChild()` function\n\n#### [Disable all animations](https://angular.dev/guide/animations/transition-and-triggers\\#disable-all-animations)\n\nTo turn off all animations for an Angular application, place the `@.disabled` host binding on the topmost Angular component.\n\ncheck\n\n```\n      import {Component, HostBinding, inject} from '@angular/core';import {  trigger,  state,  style,  animate,  transition,  // ...} from '@angular/animations';import {ChildrenOutletContexts, RouterLink, RouterOutlet} from '@angular/router';import {slideInAnimation} from './animations';@Component({  selector: 'app-root',  templateUrl: 'app.component.html',  styleUrls: ['app.component.css'],  imports: [RouterLink, RouterOutlet],  animations: [    slideInAnimation,    // animation triggers go here\\\n...  ],})export class AppComponent {  @HostBinding('@.disabled')  public animationsDisabled = false;  private contexts = inject(ChildrenOutletContexts);  getRouteAnimationData() {    return this.contexts.getContext('primary')?.route?.snapshot?.data?.['animation'];  }  toggleAnimations() {    this.animationsDisabled = !this.animationsDisabled;  }\n...}\n\n```\n\n**HELPFUL:** Disabling animations application-wide is useful during end-to-end (E2E) testing.\n\n## [Animation callbacks](https://angular.dev/guide/animations/transition-and-triggers\\#animation-callbacks)\n\nThe animation `trigger()` function emits _callbacks_ when it starts and when it finishes.\nThe following example features a component that contains an `openClose` trigger.\n\ncheck\n\n```\n      import {Component, Input} from '@angular/core';import {trigger, transition, state, animate, style, AnimationEvent} from '@angular/animations';@Component({  selector: 'app-open-close',  animations: [    trigger('openClose', [      // ...      state(        'open',        style({          height: '200px',          opacity: 1,          backgroundColor: 'yellow',        }),      ),      state(        'closed',        style({          height: '100px',          opacity: 0.8,          backgroundColor: 'blue',        }),      ),      transition('open => closed', [animate('1s')]),      transition('closed => open', [animate('0.5s')]),      transition('* => closed', [animate('1s')]),      transition('* => open', [animate('0.5s')]),      transition('open <=> closed', [animate('0.5s')]),      transition('* => open', [animate('1s', style({opacity: '*'}))]),      transition('* => *', [animate('1s')]),\\\n...    ]),  ],  templateUrl: 'open-close.component.html',  styleUrls: ['open-close.component.css'],})export class OpenCloseComponent {  @Input() logging = false;  isOpen = true;  toggle() {    this.isOpen = !this.isOpen;  }\n...  onAnimationEvent(event: AnimationEvent) {    if (!this.logging) {      return;    }    // openClose is trigger name in this example    console.warn(`Animation Trigger: ${event.triggerName}`);    // phaseName is \"start\" or \"done\"    console.warn(`Phase: ${event.phaseName}`);    // in our example, totalTime is 1000 (number of milliseconds in a second)    console.warn(`Total time: ${event.totalTime}`);    // in our example, fromState is either \"open\" or \"closed\"    console.warn(`From: ${event.fromState}`);    // in our example, toState either \"open\" or \"closed\"    console.warn(`To: ${event.toState}`);    // the HTML element itself, the button in this case    console.warn(`Element: ${event.element}`);\n...  }}\n\n```\n\nIn the HTML template, the animation event is passed back via `$event`, as `@triggerName.start` and `@triggerName.done`, where `triggerName` is the name of the trigger being used.\nIn this example, the trigger `openClose` appears as follows.\n\ncheck\n\n```\n      <nav>  <button type=\"button\" (click)=\"toggle()\">Toggle Open/Close</button></nav>  <div [@openClose]=\"isOpen ? 'open' : 'closed'\"    (@openClose.start)=\"onAnimationEvent($event)\"    (@openClose.done)=\"onAnimationEvent($event)\"    class=\"open-close-container\">  <p>The box is now {{ isOpen ? 'Open' : 'Closed' }}!</p>\n...</div>\n\n```\n\nA potential use for animation callbacks could be to cover for a slow API call, such as a database lookup.\nFor example, an **InProgress** button can be set up to have its own looping animation while the backend system operation finishes.\n\nAnother animation can be called when the current animation finishes.\nFor example, the button goes from the `inProgress` state to the `closed` state when the API call is completed.\n\nAn animation can influence an end user to _perceive_ the operation as faster, even when it is not.\n\nCallbacks can serve as a debugging tool, for example in conjunction with `console.warn()` to view the application's progress in a browser's Developer JavaScript Console.\nThe following code snippet creates console log output for the original example, a button with the two states of `open` and `closed`.\n\ncheck\n\n```\n      import {Component, Input} from '@angular/core';import {trigger, transition, state, animate, style, AnimationEvent} from '@angular/animations';@Component({  selector: 'app-open-close',  animations: [    trigger('openClose', [      // ...      state(        'open',        style({          height: '200px',          opacity: 1,          backgroundColor: 'yellow',        }),      ),      state(        'closed',        style({          height: '100px',          opacity: 0.8,          backgroundColor: 'blue',        }),      ),      transition('open => closed', [animate('1s')]),      transition('closed => open', [animate('0.5s')]),      transition('* => closed', [animate('1s')]),      transition('* => open', [animate('0.5s')]),      transition('open <=> closed', [animate('0.5s')]),      transition('* => open', [animate('1s', style({opacity: '*'}))]),      transition('* => *', [animate('1s')]),    ]),  ],  templateUrl: 'open-close.component.html',  styleUrls: ['open-close.component.css'],})export class OpenCloseComponent {  @Input() logging = false;  isOpen = true;  toggle() {    this.isOpen = !this.isOpen;  }\n...  onAnimationEvent(event: AnimationEvent) {    if (!this.logging) {      return;    }\n...    // openClose is trigger name in this example    console.warn(`Animation Trigger: ${event.triggerName}`);    // phaseName is \"start\" or \"done\"    console.warn(`Phase: ${event.phaseName}`);    // in our example, totalTime is 1000 (number of milliseconds in a second)    console.warn(`Total time: ${event.totalTime}`);    // in our example, fromState is either \"open\" or \"closed\"    console.warn(`From: ${event.fromState}`);    // in our example, toState either \"open\" or \"closed\"    console.warn(`To: ${event.toState}`);    // the HTML element itself, the button in this case    console.warn(`Element: ${event.element}`);  }}\n\n```\n\n## [Keyframes](https://angular.dev/guide/animations/transition-and-triggers\\#keyframes)\n\nTo create an animation with multiple steps run in sequence, use _keyframes_.\n\nAngular's `keyframe()` function allows several style changes within a single timing segment.\nFor example, the button, instead of fading, could change color several times over a single 2-second time span.\n\n![keyframes](https://angular.dev/guide/animations/assets/images/guide/animations/keyframes-500.png)\n\nThe code for this color change might look like this.\n\ncheck\n\n```\n      import {Component} from '@angular/core';import {trigger, transition, state, animate, style, keyframes} from '@angular/animations';@Component({  selector: 'app-status-slider',  templateUrl: 'status-slider.component.html',  styleUrls: ['status-slider.component.css'],  animations: [    trigger('slideStatus', [      state('inactive', style({backgroundColor: 'blue'})),      state('active', style({backgroundColor: '#754600'})),      transition('* => active', [        animate(          '2s',          keyframes([            style({backgroundColor: 'blue', offset: 0}),            style({backgroundColor: 'red', offset: 0.8}),            style({backgroundColor: '#754600', offset: 1.0}),          ]),        ),      ]),      transition('* => inactive', [        animate(          '2s',          keyframes([            style({backgroundColor: '#754600', offset: 0}),            style({backgroundColor: 'red', offset: 0.2}),            style({backgroundColor: 'blue', offset: 1.0}),          ]),        ),      ]),      transition('* => active', [        animate(          '2s',          keyframes([            style({backgroundColor: 'blue'}),            style({backgroundColor: 'red'}),            style({backgroundColor: 'orange'}),          ]),        ),      ]),    ]),  ],})export class StatusSliderComponent {  status: 'active' | 'inactive' = 'inactive';  toggle() {    if (this.status === 'active') {      this.status = 'inactive';    } else {      this.status = 'active';    }  }}\n\n```\n\n### [Offset](https://angular.dev/guide/animations/transition-and-triggers\\#offset)\n\nKeyframes include an `offset` that defines the point in the animation where each style change occurs.\nOffsets are relative measures from zero to one, marking the beginning and end of the animation. They should be applied to each of the keyframe steps if used at least once.\n\nDefining offsets for keyframes is optional.\nIf you omit them, evenly spaced offsets are automatically assigned.\nFor example, three keyframes without predefined offsets receive offsets of 0, 0.5, and 1.\nSpecifying an offset of 0.8 for the middle transition in the preceding example might look like this.\n\n![keyframes with offset](https://angular.dev/guide/animations/assets/images/guide/animations/keyframes-offset-500.png)\n\nThe code with offsets specified would be as follows.\n\ncheck\n\n```\n      import {Component} from '@angular/core';import {trigger, transition, state, animate, style, keyframes} from '@angular/animations';@Component({  selector: 'app-status-slider',  templateUrl: 'status-slider.component.html',  styleUrls: ['status-slider.component.css'],  animations: [    trigger('slideStatus', [      state('inactive', style({backgroundColor: 'blue'})),      state('active', style({backgroundColor: '#754600'})),      transition('* => active', [        animate(          '2s',          keyframes([            style({backgroundColor: 'blue', offset: 0}),            style({backgroundColor: 'red', offset: 0.8}),            style({backgroundColor: '#754600', offset: 1.0}),          ]),        ),      ]),      transition('* => inactive', [        animate(          '2s',          keyframes([            style({backgroundColor: '#754600', offset: 0}),            style({backgroundColor: 'red', offset: 0.2}),            style({backgroundColor: 'blue', offset: 1.0}),          ]),        ),      ]),      transition('* => active', [        animate(          '2s',          keyframes([            style({backgroundColor: 'blue'}),            style({backgroundColor: 'red'}),            style({backgroundColor: 'orange'}),          ]),        ),      ]),    ]),  ],})export class StatusSliderComponent {  status: 'active' | 'inactive' = 'inactive';  toggle() {    if (this.status === 'active') {      this.status = 'inactive';    } else {      this.status = 'active';    }  }}\n\n```\n\nYou can combine keyframes with `duration`, `delay`, and `easing` within a single animation.\n\n### [Keyframes with a pulsation](https://angular.dev/guide/animations/transition-and-triggers\\#keyframes-with-a-pulsation)\n\nUse keyframes to create a pulse effect in your animations by defining styles at specific offset throughout the animation.\n\nHere's an example of using keyframes to create a pulse effect:\n\n- The original `open` and `closed` states, with the original changes in height, color, and opacity, occurring over a timeframe of 1 second\n- A keyframes sequence inserted in the middle that causes the button to appear to pulsate irregularly over the course of that same 1 second timeframe\n\n![keyframes with irregular pulsation](https://angular.dev/guide/animations/assets/images/guide/animations/keyframes-pulsation.png)\n\nThe code snippet for this animation might look like this.\n\ncheck\n\n```\n      import {Component, Input} from '@angular/core';import {  trigger,  transition,  state,  animate,  style,  keyframes,  AnimationEvent,} from '@angular/animations';@Component({  selector: 'app-open-close',  animations: [    trigger('openClose', [      state(        'open',        style({          height: '200px',          opacity: 1,          backgroundColor: 'yellow',        }),      ),      state(        'close',        style({          height: '100px',          opacity: 0.5,          backgroundColor: 'green',        }),      ),      // ...      transition('* => *', [        animate(          '1s',          keyframes([            style({opacity: 0.1, offset: 0.1}),            style({opacity: 0.6, offset: 0.2}),            style({opacity: 1, offset: 0.5}),            style({opacity: 0.2, offset: 0.7}),          ]),        ),      ]),    ]),  ],  templateUrl: 'open-close.component.html',  styleUrls: ['open-close.component.css'],})export class OpenCloseKeyframeComponent {  isOpen = false;  toggle() {    this.isOpen = !this.isOpen;  }  @Input() logging = false;  onAnimationEvent(event: AnimationEvent) {    if (!this.logging) {      return;    }  }}\n\n```\n\n### [Animatable properties and units](https://angular.dev/guide/animations/transition-and-triggers\\#animatable-properties-and-units)\n\nAngular animations support builds on top of web animations, so you can animate any property that the browser considers animatable.\nThis includes positions, sizes, transforms, colors, borders, and more.\nThe W3C maintains a list of animatable properties on its [CSS Transitions](https://www.w3.org/TR/css-transitions-1) page.\n\nFor properties with a numeric value, define a unit by providing the value as a string, in quotes, with the appropriate suffix:\n\n- 50 pixels:\n`'50px'`\n\n- Relative font size:\n`'3em'`\n\n- Percentage:\n`'100%'`\n\n\nYou can also provide the value as a number. In such cases Angular assumes a default unit of pixels, or `px`.\nExpressing 50 pixels as `50` is the same as saying `'50px'`.\n\n**HELPFUL:** The string `\"50\"` would instead not be considered valid).\n\n### [Automatic property calculation with wildcards](https://angular.dev/guide/animations/transition-and-triggers\\#automatic-property-calculation-with-wildcards)\n\nSometimes, the value of a dimensional style property isn't known until runtime.\nFor example, elements often have widths and heights that depend on their content or the screen size.\nThese properties are often challenging to animate using CSS.\n\nIn these cases, you can use a special wildcard `*` property value under `style()`. The value of that particular style property is computed at runtime and then plugged into the animation.\n\nThe following example has a trigger called `shrinkOut`, used when an HTML element leaves the page.\nThe animation takes whatever height the element has before it leaves, and animates from that height to zero.\n\ncheck\n\n```\n      import {Component, Input, Output, EventEmitter} from '@angular/core';import {trigger, state, style, animate, transition} from '@angular/animations';import {Hero} from './hero';@Component({  selector: 'app-hero-list-auto',  templateUrl: 'hero-list-auto.component.html',  styleUrls: ['./hero-list-page.component.css'],  animations: [    trigger('shrinkOut', [      state('in', style({height: '*'})),      transition('* => void', [style({height: '*'}), animate(250, style({height: 0}))]),    ]),  ],})export class HeroListAutoComponent {  @Input() heroes: Hero[] = [];  @Output() remove = new EventEmitter<number>();  removeHero(id: number) {    this.remove.emit(id);  }}\n\n```\n\n### [Keyframes summary](https://angular.dev/guide/animations/transition-and-triggers\\#keyframes-summary)\n\nThe `keyframes()` function in Angular allows you to specify multiple interim styles within a single transition. An optional `offset` can be used to define the point in the animation where each style change should occur.\n\n## [More on Angular animations](https://angular.dev/guide/animations/transition-and-triggers\\#more-on-angular-animations)\n\nYou might also be interested in the following:",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-8fcffa2e-d6c6-47dd-a0dc-8bbc54982718.png"
  },
  "metadata": {
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:url": "https://angular.dev/",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "title": "Transition and Triggers â€¢ Angular",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "language": "en",
    "msapplication-TileColor": "#e90464",
    "twitter:description": "The web development framework for building modern apps.",
    "ogTitle": "Angular",
    "og:url": "https://angular.dev/",
    "twitter:card": "summary_large_image",
    "ogUrl": "https://angular.dev/",
    "application-name": "Angular",
    "og:type": "website",
    "twitter:title": "Angular",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "viewport": "width=device-width, initial-scale=1",
    "theme-color": "#ffffff",
    "og:title": "Angular",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "ogDescription": "The web development framework for building modern apps.",
    "description": "The web development framework for building modern apps.",
    "apple-mobile-web-app-title": "Angular",
    "og:description": "The web development framework for building modern apps.",
    "scrapeId": "412a8195-0603-41df-8ca8-03146f29ab9d",
    "sourceURL": "https://angular.dev/guide/animations/transition-and-triggers",
    "url": "https://angular.dev/guide/animations/transition-and-triggers",
    "statusCode": 200
  }
}