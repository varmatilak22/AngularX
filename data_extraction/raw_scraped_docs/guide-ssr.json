{
  "scrapeId": "db1e1413-b23e-431a-b587-f99d755bf91e",
  "sourceURL": "https://angular.dev/guide/ssr",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backServer-side & hybrid-rendering\n  - [Overview](https://angular.dev/guide/performance)\n  - [Server-side rendering](https://angular.dev/guide/ssr)\n  - [Build-time prerendering](https://angular.dev/guide/prerendering)\n  - [Hybrid rendering with server routing](https://angular.dev/guide/hybrid-rendering)\n  - [Hydration](https://angular.dev/guide/hydration)\n  - [Incremental Hydration](https://angular.dev/guide/incremental-hydration)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nServer-side rendering (SSR) is a process that involves rendering pages on the server, resulting in initial HTML content which contains initial page state. Once the HTML content is delivered to a browser, Angular initializes the application and utilizes the data contained within the HTML.\n\n## [Why use SSR?](https://angular.dev/guide/ssr\\#why-use-ssr)\n\nThe main advantages of SSR as compared to client-side rendering (CSR) are:\n\n- **Improved performance**: SSR can improve the performance of web applications by delivering fully rendered HTML to the client, which the browser can parse and display even before it downloads the application JavaScript. This can be especially beneficial for users on low-bandwidth connections or mobile devices.\n- **Improved Core Web Vitals**: SSR results in performance improvements that can be measured using [Core Web Vitals (CWV)](https://web.dev/learn-core-web-vitals/) statistics, such as reduced First Contentful Paint ( [FCP](https://developer.chrome.com/en/docs/lighthouse/performance/first-contentful-paint/)) and Largest Contentful Paint ( [LCP](https://web.dev/lcp/)), as well as Cumulative Layout Shift ( [CLS](https://web.dev/cls/)).\n- **Better SEO**: SSR can improve the search engine optimization (SEO) of web applications by making it easier for search engines to crawl and index the content of the application.\n\n## [Enable server-side rendering](https://angular.dev/guide/ssr\\#enable-server-side-rendering)\n\nTo create a **new** project with SSR, run:\n\n```\n      ng new --ssr\n\n```\n\ncheck\n\nTo add SSR to an **existing** project, use the Angular CLI `ng add` command.\n\n```\n      ng add @angular/ssr\n\n```\n\ncheck\n\n**NOTE:** Interested in the latest SSR advancements in Angular? Take a look at the developer preview [hybrid rendering APIs](https://angular.dev/guide/guide/hybrid-rendering).\n\nThese commands create and update application code to enable SSR and adds extra files to the project structure.\n\n```\nmy-app\n|-- server.ts                       # application server\nâ””â”€â”€ src\n    |-- app\n    |   â””â”€â”€ app.config.server.ts    # server application configuration\n    â””â”€â”€ main.server.ts              # main server application bootstrapping\n\n```\n\nTo verify that the application is server-side rendered, run it locally with `ng serve`. The initial HTML request should contain application content.\n\n## [Configure server-side rendering](https://angular.dev/guide/ssr\\#configure-server-side-rendering)\n\n**NOTE:** In Angular v17 and later, `server.ts` is no longer used by `ng serve`. The dev server will use `main.server.ts` directly to perform server side rendering.\n\nThe `server.ts` file configures a Node.js Express server and Angular server-side rendering. `CommonEngine` is used to render an Angular application.\n\ncheck\n\n```\n      import {APP_BASE_HREF} from '@angular/common';import {CommonEngine} from '@angular/ssr/node';import express from 'express';import {fileURLToPath} from 'node:url';import {dirname, join, resolve} from 'node:path';import bootstrap from './src/main.server';// The Express app is exported so that it can be used by serverless Functions.export function app(): express.Express {  const server = express();  const serverDistFolder = dirname(fileURLToPath(import.meta.url));  const browserDistFolder = resolve(serverDistFolder, '../browser');  const indexHtml = join(serverDistFolder, 'index.server.html');  const commonEngine = new CommonEngine();  server.set('view engine', 'html');  server.set('views', browserDistFolder);  // TODO: implement data requests securely  // Serve data from URLS that begin \"/api/\"  server.get('/api/**', (req, res) => {    res.status(404).send('data requests are not yet supported');  });  // Serve static files from /browser  server.get(    '*.*',    express.static(browserDistFolder, {      maxAge: '1y',    }),  );  // All regular routes use the Angular engine  server.get('*', (req, res, next) => {    const {protocol, originalUrl, baseUrl, headers} = req;    commonEngine      .render({        bootstrap,        documentFilePath: indexHtml,        url: `${protocol}://${headers.host}${originalUrl}`,        publicPath: browserDistFolder,        providers: [{provide: APP_BASE_HREF, useValue: req.baseUrl}],      })      .then((html) => res.send(html))      .catch((err) => next(err));  });  return server;}function run(): void {  const port = process.env['PORT'] || 4000;  // Start up the Node server  const server = app();  server.listen(port, () => {    console.log(`Node Express server listening on http://localhost:${port}`);  });}run();\n\n```\n\nAngular CLI will scaffold an initial server implementation focused on server-side rendering your Angular application. This server can be extended to support other features such as API routes, redirects, static assets, and more. See [Express documentation](https://expressjs.com/) for more details.\n\nFor more information on the APIs, refer to the [`CommonEngine` API reference](https://angular.dev/guide/api/ssr/node/CommonEngineRenderOptions).\n\n## [Hydration](https://angular.dev/guide/ssr\\#hydration)\n\nHydration is the process that restores the server side rendered application on the client. This includes things like reusing the server rendered DOM structures, persisting the application state, transferring application data that was retrieved already by the server, and other processes. Hydration is enabled by default when you use SSR. You can find more info in [the hydration guide](https://angular.dev/guide/guide/hydration).\n\n## [Caching data when using HttpClient](https://angular.dev/guide/ssr\\#caching-data-when-using-httpclient)\n\n[`HttpClient`](https://angular.dev/guide/api/common/http/HttpClient) cached outgoing network requests when running on the server. This information is serialized and transferred to the browser as part of the initial HTML sent from the server. In the browser, `HttpClient` checks whether it has data in the cache and if so, reuses it instead of making a new HTTP request during initial application rendering. `HttpClient` stops using the cache once an application becomes [stable](https://angular.dev/guide/api/core/ApplicationRef#isStable) while running in a browser.\n\nBy default, `HttpClient` caches all `HEAD` and `GET` requests which don't contain `Authorization` or `Proxy-Authorization` headers. You can override those settings by using [`withHttpTransferCacheOptions`](https://angular.dev/guide/api/platform-browser/withHttpTransferCacheOptions) when providing hydration.\n\n```\n      bootstrapApplication(AppComponent, {  providers: [    provideClientHydration(withHttpTransferCacheOptions({      includePostRequests: true    }))  ]});\n\n```\n\ncheck\n\n## [Authoring server-compatible components](https://angular.dev/guide/ssr\\#authoring-server-compatible-components)\n\nSome common browser APIs and capabilities might not be available on the server. Applications cannot make use of browser-specific global objects like `window`, `document`, `navigator`, or `location` as well as certain properties of `HTMLElement`.\n\nIn general, code which relies on browser-specific symbols should only be executed in the browser, not on the server. This can be enforced through the [`afterRender`](https://angular.dev/guide/api/core/afterRender) and [`afterNextRender`](https://angular.dev/guide/api/core/afterNextRender) lifecycle hooks. These are only executed on the browser and skipped on the server.\n\n```\n      import { Component, ViewChild, afterNextRender } from '@angular/core';@Component({  selector: 'my-cmp',  template: `<span #content>{{ ... }}</span>`,})export class MyComponent {  @ViewChild('content') contentRef: ElementRef;  constructor() {    afterNextRender(() => {      // Safe to check `scrollHeight` because this will only run in the browser, not the server.      console.log('content height: ' + this.contentRef.nativeElement.scrollHeight);    });  }}\n\n```\n\ncheck\n\n## [Using Angular Service Worker](https://angular.dev/guide/ssr\\#using-angular-service-worker)\n\nIf you are using Angular on the server in combination with the Angular service worker, the behavior deviates from the normal server-side rendering behavior. The initial server request will be rendered on the server as expected. However, after that initial request, subsequent requests are handled by the service worker and always client-side rendered.",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-fb239755-f65a-4466-b016-5c193233bb44.png"
  },
  "metadata": {
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:url": "https://angular.dev/",
    "language": "en",
    "ogTitle": "Angular",
    "description": "The web development framework for building modern apps.",
    "twitter:description": "The web development framework for building modern apps.",
    "ogDescription": "The web development framework for building modern apps.",
    "apple-mobile-web-app-title": "Angular",
    "title": "Server-side rendering â€¢ Angular",
    "msapplication-TileColor": "#e90464",
    "twitter:card": "summary_large_image",
    "og:url": "https://angular.dev/",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "og:title": "Angular",
    "twitter:title": "Angular",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "viewport": "width=device-width, initial-scale=1",
    "theme-color": "#ffffff",
    "application-name": "Angular",
    "og:description": "The web development framework for building modern apps.",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "ogUrl": "https://angular.dev/",
    "og:type": "website",
    "scrapeId": "db1e1413-b23e-431a-b587-f99d755bf91e",
    "sourceURL": "https://angular.dev/guide/ssr",
    "url": "https://angular.dev/guide/ssr",
    "statusCode": 200
  }
}