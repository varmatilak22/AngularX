{
  "scrapeId": "3221cd95-257c-4b93-8e2a-020a2594f83e",
  "sourceURL": "https://angular.dev/best-practices/security",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nThis topic describes Angular's built-in protections against common web application vulnerabilities and attacks such as cross-site scripting attacks.\nIt doesn't cover application-level security, such as authentication and authorization.\n\nFor more information about the attacks and mitigations described below, see the [Open Web Application Security Project (OWASP) Guide](https://www.owasp.org/index.php/Category:OWASP_Guide_Project).\n\n### Reporting vulnerabilities\n\nAngular is part of Google [Open Source Software Vulnerability Reward Program](https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules). For vulnerabilities in Angular, please submit your report at [https://bughunters.google.com](https://bughunters.google.com/report).\n\nFor more information about how Google handles security issues, see [Google's security philosophy](https://www.google.com/about/appsecurity).\n\n## [Best practices](https://angular.dev/best-practices/security\\#best-practices)\n\nThese are some best practices to ensure that your Angular application is secure.\n\n1. **Keep current with the latest Angular library releases** \\- The Angular libraries get regular updates, and these updates might fix security defects discovered in previous versions. Check the Angular [change log](https://github.com/angular/angular/blob/main/CHANGELOG.md) for security-related updates.\n2. **Don't alter your copy of Angular** \\- Private, customized versions of Angular tend to fall behind the current version and might not include important security fixes and enhancements. Instead, share your Angular improvements with the community and make a pull request.\n3. **Avoid Angular APIs marked in the documentation as \" _Security Risk_\"** \\- For more information, see the [Trusting safe values](https://angular.dev/best-practices/security#trusting-safe-values) section of this page.\n\n## [Preventing cross-site scripting (XSS)](https://angular.dev/best-practices/security\\#preventing-cross-site-scripting-xss)\n\n[Cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) enables attackers to inject malicious code into web pages.\nSuch code can then, for example, steal user and login data, or perform actions that impersonate the user.\nThis is one of the most common attacks on the web.\n\nTo block XSS attacks, you must prevent malicious code from entering the Document Object Model (DOM).\nFor example, if attackers can trick you into inserting a `<script>` tag in the DOM, they can run arbitrary code on your website.\nThe attack isn't limited to `<script>` tags â€”many elements and properties in the DOM allow code execution, for example, `<img alt=\"\" onerror=\"...\">` and `<a href=\"javascript:...\">`.\nIf attacker-controlled data enters the DOM, expect security vulnerabilities.\n\n### [Angular's cross-site scripting security model](https://angular.dev/best-practices/security\\#angulars-cross-site-scripting-security-model)\n\nTo systematically block XSS bugs, Angular treats all values as untrusted by default.\nWhen a value is inserted into the DOM from a template binding, or interpolation, Angular sanitizes and escapes untrusted values.\nIf a value was already sanitized outside of Angular and is considered safe, communicate this to Angular by marking the [value as trusted](https://angular.dev/best-practices/security#trusting-safe-values).\n\nUnlike values to be used for rendering, Angular templates are considered trusted by default, and should be treated as executable code.\nNever create templates by concatenating user input and template syntax.\nDoing this would enable attackers to [inject arbitrary code](https://en.wikipedia.org/wiki/Code_injection) into your application.\nTo prevent these vulnerabilities, always use the default [Ahead-Of-Time (AOT) template compiler](https://angular.dev/best-practices/security#use-the-aot-template-compiler) in production deployments.\n\nAn extra layer of protection can be provided through the use of Content security policy and Trusted Types.\nThese web platform features operate at the DOM level which is the most effective place to prevent XSS issues. Here they can't be bypassed using other, lower-level APIs.\nFor this reason, it is strongly encouraged to take advantage of these features. To do this, configure the [content security policy](https://angular.dev/best-practices/security#content-security-policy) for the application and enable [trusted types enforcement](https://angular.dev/best-practices/security#enforcing-trusted-types).\n\n### [Sanitization and security contexts](https://angular.dev/best-practices/security\\#sanitization-and-security-contexts)\n\n_Sanitization_ is the inspection of an untrusted value, turning it into a value that's safe to insert into the DOM.\nIn many cases, sanitization doesn't change a value at all.\nSanitization depends on a context.\nFor example, a value that's harmless in CSS is potentially dangerous in a URL.\n\nAngular defines the following security contexts:\n\n| Security contexts | Details |\n| :-- | :-- |\n| HTML | Used when interpreting a value as HTML, for example, when binding to `innerHtml`. |\n| Style | Used when binding CSS into the `style` property. |\n| URL | Used for URL properties, such as `<a href>`. |\n| Resource URL | A URL that is loaded and executed as code, for example, in `<script src>`. |\n\nAngular sanitizes untrusted values for HTML and URLs. Sanitizing resource URLs isn't possible because they contain arbitrary code.\nIn development mode, Angular prints a console warning when it has to change a value during sanitization.\n\n### [Sanitization example](https://angular.dev/best-practices/security\\#sanitization-example)\n\nThe following template binds the value of `htmlSnippet`. Once by interpolating it into an element's content, and once by binding it to the `innerHTML` property of an element:\n\n### src/app/inner-html-binding.component.html\n\n```\n      <h3>Binding innerHTML</h3><p>Bound value:</p><p class=\"e2e-inner-html-interpolated\">{{ htmlSnippet }}</p><p>Result of binding to innerHTML:</p><p class=\"e2e-inner-html-bound\" [innerHTML]=\"htmlSnippet\"></p>\n\n```\n\ncheck\n\nInterpolated content is always escaped â€”the HTML isn't interpreted and the browser displays angle brackets in the element's text content.\n\nFor the HTML to be interpreted, bind it to an HTML property such as `innerHTML`.\nBe aware that binding a value that an attacker might control into `innerHTML` normally causes an XSS vulnerability.\nFor example, one could run JavaScript in a following way:\n\ncheck\n\n```\n      import {Component} from '@angular/core';@Component({  selector: 'app-inner-html-binding',  templateUrl: './inner-html-binding.component.html',})export class InnerHtmlBindingComponent {  // For example, a user/attacker-controlled value from a URL.  htmlSnippet = 'Template <script>alert(\"0wned\")</script> <b>Syntax</b>';}\n\n```\n\nAngular recognizes the value as unsafe and automatically sanitizes it, which removes the `script` element but keeps safe content such as the `<b>` element.\n\n![A screenshot showing interpolated and bound HTML values](https://angular.dev/best-practices/assets/images/guide/security/binding-inner-html.png#small)\n\n### [Direct use of the DOM APIs and explicit sanitization calls](https://angular.dev/best-practices/security\\#direct-use-of-the-dom-apis-and-explicit-sanitization-calls)\n\nUnless you enforce Trusted Types, the built-in browser DOM APIs don't automatically protect you from security vulnerabilities.\nFor example, `document`, the node available through `ElementRef`, and many third-party APIs contain unsafe methods.\nLikewise, if you interact with other libraries that manipulate the DOM, you likely won't have the same automatic sanitization as with Angular interpolations.\nAvoid directly interacting with the DOM and instead use Angular templates where possible.\n\nFor cases where this is unavoidable, use the built-in Angular sanitization functions.\nSanitize untrusted values with the [DomSanitizer.sanitize](https://angular.dev/best-practices/api/platform-browser/DomSanitizer#sanitize) method and the appropriate `SecurityContext`.\nThat function also accepts values that were marked as trusted using the `bypassSecurityTrust` functions, and does not sanitize them, as [described below](https://angular.dev/best-practices/security#trusting-safe-values).\n\n### [Trusting safe values](https://angular.dev/best-practices/security\\#trusting-safe-values)\n\nSometimes applications genuinely need to include executable code, display an `<iframe>` from some URL, or construct potentially dangerous URLs.\nTo prevent automatic sanitization in these situations, tell Angular that you inspected a value, checked how it was created, and made sure it is secure.\nDo _be careful_.\nIf you trust a value that might be malicious, you are introducing a security vulnerability into your application.\nIf in doubt, find a professional security reviewer.\n\nTo mark a value as trusted, inject `DomSanitizer` and call one of the following methods:\n\n- `bypassSecurityTrustHtml`\n- `bypassSecurityTrustScript`\n- `bypassSecurityTrustStyle`\n- `bypassSecurityTrustUrl`\n- `bypassSecurityTrustResourceUrl`\n\nRemember, whether a value is safe depends on context, so choose the right context for your intended use of the value.\nImagine that the following template needs to bind a URL to a `javascript:alert(...)` call:\n\ncheck\n\n```\n      <h3>Bypass Security Component</h3><h4>An untrusted URL:</h4><p><a class=\"e2e-dangerous-url\" [href]=\"dangerousUrl\">Click me</a></p><h4>A trusted URL:</h4><p><a class=\"e2e-trusted-url\" [href]=\"trustedUrl\">Click me</a></p><h4>Resource URL:</h4><p>Showing: {{ dangerousVideoUrl }}</p><p>Trusted:</p><iframe class=\"e2e-iframe-trusted-src\" width=\"640\" height=\"390\" [src]=\"videoUrl\" title=\"trusted video url\"></iframe><p>Untrusted:</p><iframe class=\"e2e-iframe-untrusted-src\" width=\"640\" height=\"390\" [src]=\"dangerousVideoUrl\" title=\"unTrusted video url\"></iframe>\n\n```\n\nNormally, Angular automatically sanitizes the URL, disables the dangerous code, and in development mode, logs this action to the console.\nTo prevent this, mark the URL value as a trusted URL using the `bypassSecurityTrustUrl` call:\n\ncheck\n\n```\n      import {Component, inject} from '@angular/core';import {DomSanitizer, SafeResourceUrl, SafeUrl} from '@angular/platform-browser';@Component({  selector: 'app-bypass-security',  templateUrl: './bypass-security.component.html',})export class BypassSecurityComponent {  dangerousUrl: string;  trustedUrl: SafeUrl;  dangerousVideoUrl!: string;  videoUrl!: SafeResourceUrl;  private sanitizer = inject(DomSanitizer);  constructor() {    // javascript: URLs are dangerous if attacker controlled.    // Angular sanitizes them in data binding, but you can    // explicitly tell Angular to trust this value:    this.dangerousUrl = 'javascript:alert(\"Hi there\")';    this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);    this.updateVideoUrl('PUBnlbjZFAI');  }  updateVideoUrl(id: string) {    // Appending an ID to a YouTube URL is safe.    // Always make sure to construct SafeValue objects as    // close as possible to the input data so    // that it's easier to check if the value is safe.    this.dangerousVideoUrl = 'https://www.youtube.com/embed/' + id;    this.videoUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.dangerousVideoUrl);  }}\n\n```\n\n![A screenshot showing an alert box created from a trusted URL](https://angular.dev/best-practices/assets/images/guide/security/bypass-security-component.png#medium)\n\nIf you need to convert user input into a trusted value, use a component method.\nThe following template lets users enter a YouTube video ID and load the corresponding video in an `<iframe>`.\nThe `<iframe src>` attribute is a resource URL security context, because an untrusted source can, for example, smuggle in file downloads that unsuspecting users could run.\nTo prevent this, call a method on the component to construct a trusted video URL, which causes Angular to let binding into `<iframe src>`:\n\ncheck\n\n```\n      <h3>Bypass Security Component</h3><h4>An untrusted URL:</h4><p><a class=\"e2e-dangerous-url\" [href]=\"dangerousUrl\">Click me</a></p><h4>A trusted URL:</h4><p><a class=\"e2e-trusted-url\" [href]=\"trustedUrl\">Click me</a></p><h4>Resource URL:</h4><p>Showing: {{ dangerousVideoUrl }}</p><p>Trusted:</p><iframe class=\"e2e-iframe-trusted-src\" width=\"640\" height=\"390\" [src]=\"videoUrl\" title=\"trusted video url\"></iframe><p>Untrusted:</p><iframe class=\"e2e-iframe-untrusted-src\" width=\"640\" height=\"390\" [src]=\"dangerousVideoUrl\" title=\"unTrusted video url\"></iframe>\n\n```\n\ncheck\n\n```\n      import {Component, inject} from '@angular/core';import {DomSanitizer, SafeResourceUrl, SafeUrl} from '@angular/platform-browser';@Component({  selector: 'app-bypass-security',  templateUrl: './bypass-security.component.html',})export class BypassSecurityComponent {  dangerousUrl: string;  trustedUrl: SafeUrl;  dangerousVideoUrl!: string;  videoUrl!: SafeResourceUrl;  private sanitizer = inject(DomSanitizer);  constructor() {    // javascript: URLs are dangerous if attacker controlled.    // Angular sanitizes them in data binding, but you can    // explicitly tell Angular to trust this value:    this.dangerousUrl = 'javascript:alert(\"Hi there\")';    this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);    this.updateVideoUrl('PUBnlbjZFAI');  }  updateVideoUrl(id: string) {    // Appending an ID to a YouTube URL is safe.    // Always make sure to construct SafeValue objects as    // close as possible to the input data so    // that it's easier to check if the value is safe.    this.dangerousVideoUrl = 'https://www.youtube.com/embed/' + id;    this.videoUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.dangerousVideoUrl);  }}\n\n```\n\n### [Content security policy](https://angular.dev/best-practices/security\\#content-security-policy)\n\nContent Security Policy (CSP) is a defense-in-depth technique to prevent XSS.\nTo enable CSP, configure your web server to return an appropriate `Content-Security-Policy` HTTP header.\nRead more about content security policy at the [Web Fundamentals guide](https://developers.google.com/web/fundamentals/security/csp) on the Google Developers website.\n\nThe minimal policy required for a brand-new Angular application is:\n\n```\n      default-src 'self'; style-src 'self' 'nonce-randomNonceGoesHere'; script-src 'self' 'nonce-randomNonceGoesHere';\n\n```\n\ncheck\n\nWhen serving your Angular application, the server should include a randomly-generated nonce in the HTTP header for each request.\nYou must provide this nonce to Angular so that the framework can render `<style>` elements.\nYou can set the nonce for Angular in one of two ways:\n\n1. Set the `ngCspNonce` attribute on the root application element as `<app ngCspNonce=\"randomNonceGoesHere\"></app>`. Use this approach if you have access to server-side templating that can add the nonce both to the header and the `index.html` when constructing the response.\n2. Provide the nonce using the `CSP_NONCE` injection token. Use this approach if you have access to the nonce at runtime and you want to be able to cache the `index.html`.\n\n```\n      import {bootstrapApplication, CSP_NONCE} from '@angular/core';import {AppComponent} from './app/app.component';bootstrapApplication(AppComponent, {  providers: [{    provide: CSP_NONCE,    useValue: globalThis.myRandomNonceValue  }]});\n\n```\n\ncheck\n\n### Unique nonces\n\nAlways ensure that the nonces you provide are **unique per request** and that they are not predictable or guessable.\nIf an attacker can predict future nonces, they can circumvent the protections offered by CSP.\n\nIf you cannot generate nonces in your project, you can allow inline styles by adding `'unsafe-inline'` to the `style-src` section of the CSP header.\n\n| Sections | Details |\n| :-- | :-- |\n| `default-src 'self';` | Allows the page to load all its required resources from the same origin. |\n| `style-src 'self' 'nonce-randomNonceGoesHere';` | Allows the page to load global styles from the same origin ( `'self'`) and styles inserted by Angular with the `nonce-randomNonceGoesHere`. |\n| `script-src 'self' 'nonce-randomNonceGoesHere';` | Allows the page to load JavaScript from the same origin ( `'self'`) and scripts inserted by the Angular CLI with the `nonce-randomNonceGoesHere`. This is only required if you're using critical CSS inlining. |\n\nAngular itself requires only these settings to function correctly.\nAs your project grows, you may need to expand your CSP settings to accommodate extra features specific to your application.\n\n### [Enforcing Trusted Types](https://angular.dev/best-practices/security\\#enforcing-trusted-types)\n\nIt is recommended that you use [Trusted Types](https://w3c.github.io/trusted-types/dist/spec/) as a way to help secure your applications from cross-site scripting attacks.\nTrusted Types is a [web platform](https://en.wikipedia.org/wiki/Web_platform) feature that can help you prevent cross-site scripting attacks by enforcing safer coding practices.\nTrusted Types can also help simplify the auditing of application code.\n\n### Trusted types\n\nTrusted Types might not yet be available in all browsers your application targets.\nIn the case your Trusted-Types-enabled application runs in a browser that doesn't support Trusted Types, the features of the application are preserved. Your application is guarded against XSS by way of Angular's DomSanitizer.\nSee [caniuse.com/trusted-types](https://caniuse.com/trusted-types) for the current browser support.\n\nTo enforce Trusted Types for your application, you must configure your application's web server to emit HTTP headers with one of the following Angular policies:\n\n| Policies | Detail |\n| :-- | :-- |\n| `angular` | This policy is used in security-reviewed code that is internal to Angular, and is required for Angular to function when Trusted Types are enforced. Any inline template values or content sanitized by Angular is treated as safe by this policy. |\n| `angular#bundler` | This policy is used by the Angular CLI bundler when creating lazy chunk files. |\n| `angular#unsafe-bypass` | This policy is used for applications that use any of the methods in Angular's [DomSanitizer](https://angular.dev/best-practices/api/platform-browser/DomSanitizer) that bypass security, such as `bypassSecurityTrustHtml`. Any application that uses these methods must enable this policy. |\n| `angular#unsafe-jit` | This policy is used by the [Just-In-Time (JIT) compiler](https://angular.dev/best-practices/api/core/Compiler). You must enable this policy if your application interacts directly with the JIT compiler or is running in JIT mode using the [platform browser dynamic](https://angular.dev/best-practices/api/platform-browser-dynamic/platformBrowserDynamic). |\n| `angular#unsafe-upgrade` | This policy is used by the [@angular/upgrade](https://angular.dev/best-practices/api/upgrade/static/UpgradeModule) package. You must enable this policy if your application is an AngularJS hybrid. |\n\nYou should configure the HTTP headers for Trusted Types in the following locations:\n\n- Production serving infrastructure\n- Angular CLI ( `ng serve`), using the `headers` property in the `angular.json` file, for local development and end-to-end testing\n- Karma ( `ng test`), using the `customHeaders` property in the `karma.config.js` file, for unit testing\n\nThe following is an example of a header specifically configured for Trusted Types and Angular:\n\n```\n      Content-Security-Policy: trusted-types angular; require-trusted-types-for 'script';\n\n```\n\ncheck\n\nAn example of a header specifically configured for Trusted Types and Angular applications that use any of Angular's methods in [DomSanitizer](https://angular.dev/best-practices/api/platform-browser/DomSanitizer) that bypasses security:\n\n```\n      Content-Security-Policy: trusted-types angular angular#unsafe-bypass; require-trusted-types-for 'script';\n\n```\n\ncheck\n\nThe following is an example of a header specifically configured for Trusted Types and Angular applications using JIT:\n\n```\n      Content-Security-Policy: trusted-types angular angular#unsafe-jit; require-trusted-types-for 'script';\n\n```\n\ncheck\n\nThe following is an example of a header specifically configured for Trusted Types and Angular applications that use lazy loading of modules:\n\n```\n      Content-Security-Policy: trusted-types angular angular#bundler; require-trusted-types-for 'script';\n\n```\n\ncheck\n\n### Community contributions\n\nTo learn more about troubleshooting Trusted Type configurations, the following resource might be HELPFUL:\n\n[Prevent DOM-based cross-site scripting vulnerabilities with Trusted Types](https://web.dev/trusted-types/#how-to-use-trusted-types)\n\n### [Use the AOT template compiler](https://angular.dev/best-practices/security\\#use-the-aot-template-compiler)\n\nThe AOT template compiler prevents a whole class of vulnerabilities called template injection, and greatly improves application performance.\nThe AOT template compiler is the default compiler used by Angular CLI applications, and you should use it in all production deployments.\n\nAn alternative to the AOT compiler is the JIT compiler which compiles templates to executable template code within the browser at runtime.\nAngular trusts template code, so dynamically generating templates and compiling them, in particular templates containing user data, circumvents Angular's built-in protections. This is a security anti-pattern.\nFor information about dynamically constructing forms in a safe way, see the [Dynamic Forms](https://angular.dev/best-practices/guide/forms/dynamic-forms) guide.\n\n### [Server-side XSS protection](https://angular.dev/best-practices/security\\#server-side-xss-protection)\n\nHTML constructed on the server is vulnerable to injection attacks.\nInjecting template code into an Angular application is the same as injecting executable code into the application:\nIt gives the attacker full control over the application.\nTo prevent this, use a templating language that automatically escapes values to prevent XSS vulnerabilities on the server.\nDon't create Angular templates on the server side using a templating language. This carries a high risk of introducing template-injection vulnerabilities.\n\n## [HTTP-level vulnerabilities](https://angular.dev/best-practices/security\\#http-level-vulnerabilities)\n\nAngular has built-in support to help prevent two common HTTP vulnerabilities, cross-site request forgery (CSRF or XSRF) and cross-site script inclusion (XSSI).\nBoth of these must be mitigated primarily on the server side, but Angular provides helpers to make integration on the client side easier.\n\n### [Cross-site request forgery](https://angular.dev/best-practices/security\\#cross-site-request-forgery)\n\nIn a cross-site request forgery (CSRF or XSRF), an attacker tricks the user into visiting a different web page (such as `evil.com`) with malignant code. This web page secretly sends a malicious request to the application's web server (such as `example-bank.com`).\n\nAssume the user is logged into the application at `example-bank.com`.\nThe user opens an email and clicks a link to `evil.com`, which opens in a new tab.\n\nThe `evil.com` page immediately sends a malicious request to `example-bank.com`.\nPerhaps it's a request to transfer money from the user's account to the attacker's account.\nThe browser automatically sends the `example-bank.com` cookies, including the authentication cookie, with this request.\n\nIf the `example-bank.com` server lacks XSRF protection, it can't tell the difference between a legitimate request from the application and the forged request from `evil.com`.\n\nTo prevent this, the application must ensure that a user request originates from the real application, not from a different site.\nThe server and client must cooperate to thwart this attack.\n\nIn a common anti-XSRF technique, the application server sends a randomly created authentication token in a cookie.\nThe client code reads the cookie and adds a custom request header with the token in all following requests.\nThe server compares the received cookie value to the request header value and rejects the request if the values are missing or don't match.\n\nThis technique is effective because all browsers implement the _same origin policy_.\nOnly code from the website on which cookies are set can read the cookies from that site and set custom headers on requests to that site.\nThat means only your application can read this cookie token and set the custom header.\nThe malicious code on `evil.com` can't.\n\n### [`HttpClient` XSRF/CSRF security](https://angular.dev/best-practices/security\\#httpclient-xsrf-csrf-security)\n\n`HttpClient` supports a [common mechanism](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token) used to prevent XSRF attacks. When performing HTTP requests, an interceptor reads a token from a cookie, by default `XSRF-TOKEN`, and sets it as an HTTP header, `X-XSRF-TOKEN`. Because only code that runs on your domain could read the cookie, the backend can be certain that the HTTP request came from your client application and not an attacker.\n\nBy default, an interceptor sends this header on all mutating requests (such as `POST`) to relative URLs, but not on GET/HEAD requests or on requests with an absolute URL.\n\n### Why not protect GET requests?\n\nCSRF protection is only needed for requests that can change state on the backend. By their nature, CSRF attacks cross domain boundaries, and the web's [same-origin policy](https://developer.mozilla.org/docs/Web/Security/Same-origin_policy) will prevent an attacking page from retrieving the results of authenticated GET requests.\n\nTo take advantage of this, your server needs to set a token in a JavaScript readable session cookie called `XSRF-TOKEN` on either the page load or the first GET request. On subsequent requests the server can verify that the cookie matches the `X-XSRF-TOKEN` HTTP header, and therefore be sure that only code running on your domain could have sent the request. The token must be unique for each user and must be verifiable by the server; this prevents the client from making up its own tokens. Set the token to a digest of your site's authentication cookie with a salt for added security.\n\nTo prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name.\n\n### HttpClient supports only the client half of the XSRF protection scheme\n\nYour backend service must be configured to set the cookie for your page, and to verify that the header is present on all eligible requests. Failing to do so renders Angular's default protection ineffective.\n\n### [Configure custom cookie/header names](https://angular.dev/best-practices/security\\#configure-custom-cookie-header-names)\n\nIf your backend service uses different names for the XSRF token cookie or header, use `withXsrfConfiguration` to override the defaults.\n\nAdd it to the `provideHttpClient` call as follows:\n\n```\n      export const appConfig: ApplicationConfig = {  providers: [    provideHttpClient(      withXsrfConfiguration({        cookieName: 'CUSTOM_XSRF_TOKEN',        headerName: 'X-Custom-Xsrf-Header',      }),    ),  ]};\n\n```\n\ncheck\n\n### [Disabling XSRF protection](https://angular.dev/best-practices/security\\#disabling-xsrf-protection)\n\nIf the built-in XSRF protection mechanism doesn't work for your application, you can disable it using the `withNoXsrfProtection` feature:\n\n```\n      export const appConfig: ApplicationConfig = {  providers: [    provideHttpClient(      withNoXsrfProtection(),    ),  ]};\n\n```\n\ncheck\n\nFor information about CSRF at the Open Web Application Security Project (OWASP), see [Cross-Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf) and [Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html).\nThe Stanford University paper [Robust Defenses for Cross-Site Request Forgery](https://seclab.stanford.edu/websec/csrf/csrf.pdf) is a rich source of detail.\n\nSee also Dave Smith's [talk on XSRF at AngularConnect 2016](https://www.youtube.com/watch?v=9inczw6qtpY \"Cross\").\n\n### [Cross-site script inclusion (XSSI)](https://angular.dev/best-practices/security\\#cross-site-script-inclusion-xssi)\n\nCross-site script inclusion, also known as JSON vulnerability, can allow an attacker's website to read data from a JSON API.\nThe attack works on older browsers by overriding built-in JavaScript object constructors, and then including an API URL using a `<script>` tag.\n\nThis attack is only successful if the returned JSON is executable as JavaScript.\nServers can prevent an attack by prefixing all JSON responses to make them non-executable, by convention, using the well-known string `\")]}',\\n\"`.\n\nAngular's `HttpClient` library recognizes this convention and automatically strips the string `\")]}',\\n\"` from all responses before further parsing.\n\nFor more information, see the XSSI section of this [Google web security blog post](https://security.googleblog.com/2011/05/website-security-for-webmasters.html).\n\n## [Auditing Angular applications](https://angular.dev/best-practices/security\\#auditing-angular-applications)\n\nAngular applications must follow the same security principles as regular web applications, and must be audited as such.\nAngular-specific APIs that should be audited in a security review, such as the [_bypassSecurityTrust_](https://angular.dev/best-practices/security#trusting-safe-values) methods, are marked in the documentation as security sensitive.",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-dad8f334-8d54-4237-a7ff-1ad8c706b1b0.png"
  },
  "metadata": {
    "ogTitle": "Angular",
    "og:description": "The web development framework for building modern apps.",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:card": "summary_large_image",
    "twitter:description": "The web development framework for building modern apps.",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "og:type": "website",
    "msapplication-TileColor": "#e90464",
    "og:url": "https://angular.dev/",
    "og:title": "Angular",
    "twitter:url": "https://angular.dev/",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "apple-mobile-web-app-title": "Angular",
    "description": "The web development framework for building modern apps.",
    "ogDescription": "The web development framework for building modern apps.",
    "twitter:title": "Angular",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "ogUrl": "https://angular.dev/",
    "theme-color": "#ffffff",
    "language": "en",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "title": "Security â€¢ Angular",
    "application-name": "Angular",
    "viewport": "width=device-width, initial-scale=1",
    "scrapeId": "3221cd95-257c-4b93-8e2a-020a2594f83e",
    "sourceURL": "https://angular.dev/best-practices/security",
    "url": "https://angular.dev/best-practices/security",
    "statusCode": 200
  }
}