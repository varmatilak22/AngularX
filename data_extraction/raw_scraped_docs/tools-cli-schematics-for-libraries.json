{
  "scrapeId": "63cdfaf3-96dc-4463-85d1-b19283b002fd",
  "sourceURL": "https://angular.dev/tools/cli/schematics-for-libraries",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backAngular CLI\n  - [Overview](https://angular.dev/tools/cli)\n  - [Local set-up](https://angular.dev/tools/cli/setup-local)\n  - [Building Angular apps](https://angular.dev/tools/cli/build)\n  - [Serving Angular apps for development](https://angular.dev/tools/cli/serve)\n  - [Deployment](https://angular.dev/tools/cli/deployment)\n  - [End-to-End Testing](https://angular.dev/tools/cli/end-to-end)\n  - [Migrating to new build system](https://angular.dev/tools/cli/build-system-migration)\n  - [Build environments](https://angular.dev/tools/cli/environments)\n  - [Angular CLI builders](https://angular.dev/tools/cli/cli-builder)\n  - [Generating code using schematics](https://angular.dev/tools/cli/schematics)\n  - [Authoring schematics](https://angular.dev/tools/cli/schematics-authoring)\n  - [Schematics for libraries](https://angular.dev/tools/cli/schematics-for-libraries)\n  - [Template type checking](https://angular.dev/tools/cli/template-typecheck)\n  - [Ahead-of-time (AOT) compilation](https://angular.dev/tools/cli/aot-compiler)\n  - [AOT metadata errors](https://angular.dev/tools/cli/aot-metadata-errors)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nWhen you create an Angular library, you can provide and package it with schematics that integrate it with the Angular CLI.\nWith your schematics, your users can use `ng add` to install an initial version of your library,\n`ng generate` to create artifacts defined in your library, and `ng update` to adjust their project for a new version of your library that introduces breaking changes.\n\nAll three types of schematics can be part of a collection that you package with your library.\n\n## [Creating a schematics collection](https://angular.dev/tools/cli/schematics-for-libraries\\#creating-a-schematics-collection)\n\nTo start a collection, you need to create the schematic files.\nThe following steps show you how to add initial support without modifying any project files.\n\n1. In your library's root folder, create a `schematics` folder.\n\n2. In the `schematics/` folder, create an `ng-add` folder for your first schematic.\n\n3. At the root level of the `schematics` folder, create a `collection.json` file.\n\n4. Edit the `collection.json` file to define the initial schema for your collection.\n\n\n\n\n\n### projects/my-lib/schematics/collection.json (Schematics Collection)\n\n\n\n\n\n```\n         {  \"$schema\": \"../../../node_modules/@angular-devkit/schematics/collection-schema.json\",  \"schematics\": {    \"ng-add\": {      \"description\": \"Add my library to the project.\",      \"factory\": \"./ng-add/index#ngAdd\",      \"schema\": \"./ng-add/schema.json\"    }  }}\n\n```\n\ncheck\n\n   - The `$schema` path is relative to the Angular Devkit collection schema.\n   - The `schematics` object describes the named schematics that are part of this collection.\n   - The first entry is for a schematic named `ng-add`.\n      It contains the description, and points to the factory function that is called when your schematic is executed.\n5. In your library project's `package.json` file, add a \"schematics\" entry with the path to your schema file.\n    The Angular CLI uses this entry to find named schematics in your collection when it runs commands.\n\n\n\n\ncheck\n\n```\n         {  \"name\": \"my-lib\",  \"version\": \"0.0.1\",  \"scripts\": {    \"build\": \"tsc -p tsconfig.schematics.json\",    \"postbuild\": \"copyfiles schematics/*/schema.json schematics/*/files/** schematics/collection.json ../../dist/my-lib/\"  },  \"peerDependencies\": {    \"@angular/common\": \"^19.0.0\",    \"@angular/core\": \"^19.0.0\"  },\n...  \"schematics\": \"./schematics/collection.json\",  \"ng-add\": {    \"save\": \"devDependencies\"  },  \"devDependencies\": {    \"copyfiles\": \"file:../../node_modules/copyfiles\",    \"typescript\": \"file:../../node_modules/typescript\"  }\n...}\n\n```\n\n\nThe initial schema that you have created tells the CLI where to find the schematic that supports the `ng add` command.\nNow you are ready to create that schematic.\n\n## [Providing installation support](https://angular.dev/tools/cli/schematics-for-libraries\\#providing-installation-support)\n\nA schematic for the `ng add` command can enhance the initial installation process for your users.\nThe following steps define this type of schematic.\n\n1. Go to the `<lib-root>/schematics/ng-add` folder.\n2. Create the main file, `index.ts`.\n3. Open `index.ts` and add the source code for your schematic factory function.\n\n\n\n\n### projects/my-lib/schematics/ng-add/index.ts (ng-add Rule Factory)\n\n\n\n\n\n```\n         import {Rule} from '@angular-devkit/schematics';import {addRootImport} from '@schematics/angular/utility';import {Schema} from './schema';export function ngAdd(options: Schema): Rule {  // Add an import `MyLibModule` from `my-lib` to the root of the user's project.  return addRootImport(    options.project,    ({code, external}) => code`${external('MyLibModule', 'my-lib')}`,  );}\n\n```\n\ncheck\n\n\nThe Angular CLI will install the latest version of the library automatically, and this example is taking it a step further by adding the `MyLibModule` to the root of the application. The `addRootImport` function accepts a callback that needs to return a code block. You can write any code inside of the string tagged with the `code` function and any external symbol have to be wrapped with the `external` function to ensure that the appropriate import statements are generated.\n\n### [Define dependency type](https://angular.dev/tools/cli/schematics-for-libraries\\#define-dependency-type)\n\nUse the `save` option of `ng-add` to configure if the library should be added to the `dependencies`, the `devDependencies`, or not saved at all in the project's `package.json` configuration file.\n\ncheck\n\n```\n      {  \"name\": \"my-lib\",  \"version\": \"0.0.1\",  \"scripts\": {    \"build\": \"tsc -p tsconfig.schematics.json\",    \"postbuild\": \"copyfiles schematics/*/schema.json schematics/*/files/** schematics/collection.json ../../dist/my-lib/\"  },  \"peerDependencies\": {    \"@angular/common\": \"^19.0.0\",    \"@angular/core\": \"^19.0.0\"  },  \"schematics\": \"./schematics/collection.json\",  \"ng-add\": {    \"save\": \"devDependencies\"  },  \"devDependencies\": {    \"copyfiles\": \"file:../../node_modules/copyfiles\",    \"typescript\": \"file:../../node_modules/typescript\"  }}\n\n```\n\nPossible values are:\n\n| Values | Details |\n| :-- | :-- |\n| `false` | Don't add the package to `package.json` |\n| `true` | Add the package to the dependencies |\n| `\"dependencies\"` | Add the package to the dependencies |\n| `\"devDependencies\"` | Add the package to the devDependencies |\n\n## [Building your schematics](https://angular.dev/tools/cli/schematics-for-libraries\\#building-your-schematics)\n\nTo bundle your schematics together with your library, you must configure the library to build the schematics separately, then add them to the bundle.\nYou must build your schematics _after_ you build your library, so they are placed in the correct directory.\n\n- Your library needs a custom Typescript configuration file with instructions on how to compile your schematics into your distributed library\n- To add the schematics to the library bundle, add scripts to the library's `package.json` file\n\nAssume you have a library project `my-lib` in your Angular workspace.\nTo tell the library how to build the schematics, add a `tsconfig.schematics.json` file next to the generated `tsconfig.lib.json` file that configures the library build.\n\n1. Edit the `tsconfig.schematics.json` file to add the following content.\n\n\n\n\n\n### projects/my-lib/tsconfig.schematics.json (TypeScript Config)\n\n\n\n\n\n```\n         {  \"compilerOptions\": {    \"baseUrl\": \".\",    \"lib\": [      \"es2018\",      \"dom\"    ],    \"declaration\": true,    \"module\": \"commonjs\",    \"moduleResolution\": \"node\",    \"noEmitOnError\": true,    \"noFallthroughCasesInSwitch\": true,    \"noImplicitAny\": true,    \"noImplicitThis\": true,    \"noUnusedParameters\": true,    \"noUnusedLocals\": true,    \"rootDir\": \"schematics\",    \"outDir\": \"../../dist/my-lib/schematics\",    \"skipDefaultLibCheck\": true,    \"skipLibCheck\": true,    \"sourceMap\": true,    \"strictNullChecks\": true,    \"target\": \"es6\",    \"types\": [      \"jasmine\",      \"node\"    ]  },  \"include\": [    \"schematics/**/*\"  ],  \"exclude\": [    \"schematics/*/files/**/*\"  ]}\n\n```\n\ncheck\n\n\n\n\n| Options | Details |\n| :-- | :-- |\n| `rootDir` | Specifies that your `schematics` folder contains the input files to be compiled. |\n| `outDir` | Maps to the library's output folder. By default, this is the `dist/my-lib` folder at the root of your workspace. |\n\n2. To make sure your schematics source files get compiled into the library bundle, add the following scripts to the `package.json` file in your library project's root folder ( `projects/my-lib`).\n\n\n\n\n\n### projects/my-lib/package.json (Build Scripts)\n\n\n\n\n\n```\n         {  \"name\": \"my-lib\",  \"version\": \"0.0.1\",  \"scripts\": {    \"build\": \"tsc -p tsconfig.schematics.json\",    \"postbuild\": \"copyfiles schematics/*/schema.json schematics/*/files/** schematics/collection.json ../../dist/my-lib/\"  },  \"peerDependencies\": {    \"@angular/common\": \"^19.0.0\",    \"@angular/core\": \"^19.0.0\"  },  \"schematics\": \"./schematics/collection.json\",  \"ng-add\": {    \"save\": \"devDependencies\"  },  \"devDependencies\": {    \"copyfiles\": \"file:../../node_modules/copyfiles\",    \"typescript\": \"file:../../node_modules/typescript\"  }}\n\n```\n\ncheck\n\n   - The `build` script compiles your schematic using the custom `tsconfig.schematics.json` file\n   - The `postbuild` script copies the schematic files after the `build` script completes\n   - Both the `build` and the `postbuild` scripts require the `copyfiles` and `typescript` dependencies.\n      To install the dependencies, navigate to the path defined in `devDependencies` and run `npm install` before you run the scripts.\n\n## [Providing generation support](https://angular.dev/tools/cli/schematics-for-libraries\\#providing-generation-support)\n\nYou can add a named schematic to your collection that lets your users use the `ng generate` command to create an artifact that is defined in your library.\n\nWe'll assume that your library defines a service, `my-service`, that requires some setup.\nYou want your users to be able to generate it using the following CLI command.\n\n```\n      ng generate my-lib:my-service\n\n```\n\ncheck\n\nTo begin, create a new subfolder, `my-service`, in the `schematics` folder.\n\n### [Configure the new schematic](https://angular.dev/tools/cli/schematics-for-libraries\\#configure-the-new-schematic)\n\nWhen you add a schematic to the collection, you have to point to it in the collection's schema, and provide configuration files to define options that a user can pass to the command.\n\n1. Edit the `schematics/collection.json` file to point to the new schematic subfolder, and include a pointer to a schema file that specifies inputs for the new schematic.\n\n\n\n\n\n### projects/my-lib/schematics/collection.json (Schematics Collection)\n\n\n\n\n\n```\n         {  \"$schema\": \"../../../node_modules/@angular-devkit/schematics/collection-schema.json\",  \"schematics\": {    \"ng-add\": {      \"description\": \"Add my library to the project.\",      \"factory\": \"./ng-add/index#ngAdd\",      \"schema\": \"./ng-add/schema.json\"    },    \"my-service\": {      \"description\": \"Generate a service in the project.\",      \"factory\": \"./my-service/index#myService\",      \"schema\": \"./my-service/schema.json\"    }  }}\n\n```\n\ncheck\n\n2. Go to the `<lib-root>/schematics/my-service` folder.\n\n3. Create a `schema.json` file and define the available options for the schematic.\n\n\n\n\n\n### projects/my-lib/schematics/my-service/schema.json (Schematic JSON Schema)\n\n\n\n\n\n```\n         {  \"$schema\": \"http://json-schema.org/schema\",  \"$id\": \"SchematicsMyService\",  \"title\": \"My Service Schema\",  \"type\": \"object\",  \"properties\": {    \"name\": {      \"description\": \"The name of the service.\",      \"type\": \"string\"    },    \"path\": {      \"type\": \"string\",      \"format\": \"path\",      \"description\": \"The path to create the service.\",      \"visible\": false,      \"$default\": {        \"$source\": \"workingDirectory\"      }    },    \"project\": {      \"type\": \"string\",      \"description\": \"The name of the project.\",      \"$default\": {        \"$source\": \"projectName\"      }    }   },  \"required\": [    \"name\"  ]}\n\n```\n\ncheck\n\n\n   - _id_: A unique ID for the schema in the collection.\n   - _title_: A human-readable description of the schema.\n   - _type_: A descriptor for the type provided by the properties.\n   - _properties_: An object that defines the available options for the schematic.\n\nEach option associates key with a type, description, and optional alias.\nThe type defines the shape of the value you expect, and the description is displayed when the user requests usage help for your schematic.\n\nSee the workspace schema for additional customizations for schematic options.\n\n4. Create a `schema.ts` file and define an interface that stores the values of the options defined in the `schema.json` file.\n\n\n\n\n\n### projects/my-lib/schematics/my-service/schema.ts (Schematic Interface)\n\n\n\n\n\n```\n         export interface Schema {  // The name of the service.  name: string;  // The path to create the service.  path?: string;  // The name of the project.  project?: string;}\n\n```\n\ncheck\n\n\n\n\n| Options | Details |\n| :-- | :-- |\n| name | The name you want to provide for the created service. |\n| path | Overrides the path provided to the schematic. The default path value is based on the current working directory. |\n| project | Provides a specific project to run the schematic on. In the schematic, you can provide a default if the option is not provided by the user. |\n\n\n### [Add template files](https://angular.dev/tools/cli/schematics-for-libraries\\#add-template-files)\n\nTo add artifacts to a project, your schematic needs its own template files.\nSchematic templates support special syntax to execute code and variable substitution.\n\n1. Create a `files/` folder inside the `schematics/my-service/` folder.\n\n2. Create a file named `__name@dasherize__.service.ts.template` that defines a template to use for generating files.\n    This template will generate a service that already has Angular's `HttpClient` injected into an `http` property.\n\n\n\n\n\n### projects/my-lib/schematics/my-service/files/\\_\\_name@dasherize\\_\\_.service.ts.template (Schematic Template)\n\n\n\n\n\n```\n         import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; @Injectable({   providedIn: 'root' }) export class <%= classify(name) %>Service {   private http = inject(HttpClient); }\n\n```\n\ncheck\n\n   - The `classify` and `dasherize` methods are utility functions that your schematic uses to transform your source template and filename.\n\n   - The `name` is provided as a property from your factory function.\n      It is the same `name` you defined in the schema.\n\n### [Add the factory function](https://angular.dev/tools/cli/schematics-for-libraries\\#add-the-factory-function)\n\nNow that you have the infrastructure in place, you can define the main function that performs the modifications you need in the user's project.\n\nThe Schematics framework provides a file templating system, which supports both path and content templates.\nThe system operates on placeholders defined inside files or paths that loaded in the input `Tree`.\nIt fills these in using values passed into the `Rule`.\n\nFor details of these data structures and syntax, see the [Schematics README](https://github.com/angular/angular-cli/blob/main/packages/angular_devkit/schematics/README.md).\n\n1. Create the main file `index.ts` and add the source code for your schematic factory function.\n\n2. First, import the schematics definitions you will need.\n    The Schematics framework offers many utility functions to create and use rules when running a schematic.\n\n\n\n\ncheck\n\n```\n         import {  Rule,  Tree,  SchematicsException,  apply,  url,  applyTemplates,  move,  chain,  mergeWith,} from '@angular-devkit/schematics';import {strings, normalize, virtualFs, workspaces} from '@angular-devkit/core';import {Schema as MyServiceSchema} from './schema';function createHost(tree: Tree): workspaces.WorkspaceHost {  return {    async readFile(path: string): Promise<string> {      const data = tree.read(path);      if (!data) {        throw new SchematicsException('File not found.');      }      return virtualFs.fileBufferToString(data);    },    async writeFile(path: string, data: string): Promise<void> {      return tree.overwrite(path, data);    },    async isDirectory(path: string): Promise<boolean> {      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;    },    async isFile(path: string): Promise<boolean> {      return tree.exists(path);    },  };}export function myService(options: MyServiceSchema): Rule {  return async (tree: Tree) => {    const host = createHost(tree);    const {workspace} = await workspaces.readWorkspace('/', host);    const project = options.project != null ? workspace.projects.get(options.project) : null;    if (!project) {      throw new SchematicsException(`Invalid project name: ${options.project}`);    }    const projectType = project.extensions.projectType === 'application' ? 'app' : 'lib';    if (options.path === undefined) {      options.path = `${project.sourceRoot}/${projectType}`;    }    const templateSource = apply(url('./files'), [      applyTemplates({        classify: strings.classify,        dasherize: strings.dasherize,        name: options.name,      }),      move(normalize(options.path as string)),    ]);    return chain([mergeWith(templateSource)]);  };}\n\n```\n\n3. Import the defined schema interface that provides the type information for your schematic's options.\n\n\n\n\ncheck\n\n```\n         import {  Rule,  Tree,  SchematicsException,  apply,  url,  applyTemplates,  move,  chain,  mergeWith,} from '@angular-devkit/schematics';import {strings, normalize, virtualFs, workspaces} from '@angular-devkit/core';import {Schema as MyServiceSchema} from './schema';function createHost(tree: Tree): workspaces.WorkspaceHost {  return {    async readFile(path: string): Promise<string> {      const data = tree.read(path);      if (!data) {        throw new SchematicsException('File not found.');      }      return virtualFs.fileBufferToString(data);    },    async writeFile(path: string, data: string): Promise<void> {      return tree.overwrite(path, data);    },    async isDirectory(path: string): Promise<boolean> {      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;    },    async isFile(path: string): Promise<boolean> {      return tree.exists(path);    },  };}export function myService(options: MyServiceSchema): Rule {  return async (tree: Tree) => {    const host = createHost(tree);    const {workspace} = await workspaces.readWorkspace('/', host);    const project = options.project != null ? workspace.projects.get(options.project) : null;    if (!project) {      throw new SchematicsException(`Invalid project name: ${options.project}`);    }    const projectType = project.extensions.projectType === 'application' ? 'app' : 'lib';    if (options.path === undefined) {      options.path = `${project.sourceRoot}/${projectType}`;    }    const templateSource = apply(url('./files'), [      applyTemplates({        classify: strings.classify,        dasherize: strings.dasherize,        name: options.name,      }),      move(normalize(options.path as string)),    ]);    return chain([mergeWith(templateSource)]);  };}\n\n```\n\n4. To build up the generation schematic, start with an empty rule factory.\n\n\n\n\ncheck\n\n```\n         import {Rule, Tree} from '@angular-devkit/schematics';import {Schema as MyServiceSchema} from './schema';export function myService(options: MyServiceSchema): Rule {  return (tree: Tree) => tree;}\n\n```\n\n\nThis rule factory returns the tree without modification.\nThe options are the option values passed through from the `ng generate` command.\n\n## [Define a generation rule](https://angular.dev/tools/cli/schematics-for-libraries\\#define-a-generation-rule)\n\nYou now have the framework in place for creating the code that actually modifies the user's application to set it up for the service defined in your library.\n\nThe Angular workspace where the user installed your library contains multiple projects (applications and libraries).\nThe user can specify the project on the command line, or let it default.\nIn either case, your code needs to identify the specific project to which this schematic is being applied, so that you can retrieve information from the project configuration.\n\nDo this using the `Tree` object that is passed in to the factory function.\nThe `Tree` methods give you access to the complete file tree in your workspace, letting you read and write files during the execution of the schematic.\n\n### [Get the project configuration](https://angular.dev/tools/cli/schematics-for-libraries\\#get-the-project-configuration)\n\n1. To determine the destination project, use the `workspaces.readWorkspace` method to read the contents of the workspace configuration file, `angular.json`.\n    To use `workspaces.readWorkspace` you need to create a `workspaces.WorkspaceHost` from the `Tree`.\n    Add the following code to your factory function.\n\n\n\n\ncheck\n\n```\n         import {  Rule,  Tree,  SchematicsException,  apply,  url,  applyTemplates,  move,  chain,  mergeWith,} from '@angular-devkit/schematics';import {strings, normalize, virtualFs, workspaces} from '@angular-devkit/core';import {Schema as MyServiceSchema} from './schema';function createHost(tree: Tree): workspaces.WorkspaceHost {  return {    async readFile(path: string): Promise<string> {      const data = tree.read(path);      if (!data) {        throw new SchematicsException('File not found.');      }      return virtualFs.fileBufferToString(data);    },    async writeFile(path: string, data: string): Promise<void> {      return tree.overwrite(path, data);    },    async isDirectory(path: string): Promise<boolean> {      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;    },    async isFile(path: string): Promise<boolean> {      return tree.exists(path);    },  };}export function myService(options: MyServiceSchema): Rule {  return async (tree: Tree) => {    const host = createHost(tree);    const {workspace} = await workspaces.readWorkspace('/', host);    const project = options.project != null ? workspace.projects.get(options.project) : null;    if (!project) {      throw new SchematicsException(`Invalid project name: ${options.project}`);    }    const projectType = project.extensions.projectType === 'application' ? 'app' : 'lib';    if (options.path === undefined) {      options.path = `${project.sourceRoot}/${projectType}`;    }    const templateSource = apply(url('./files'), [      applyTemplates({        classify: strings.classify,        dasherize: strings.dasherize,        name: options.name,      }),      move(normalize(options.path as string)),    ]);    return chain([mergeWith(templateSource)]);\n...  };}\n\n```\n\n\n\n\n\n\n    Be sure to check that the context exists and throw the appropriate error.\n\n2. Now that you have the project name, use it to retrieve the project-specific configuration information.\n\n\n\n\ncheck\n\n```\n         import {  Rule,  Tree,  SchematicsException,  apply,  url,  applyTemplates,  move,  chain,  mergeWith,} from '@angular-devkit/schematics';import {strings, normalize, virtualFs, workspaces} from '@angular-devkit/core';import {Schema as MyServiceSchema} from './schema';function createHost(tree: Tree): workspaces.WorkspaceHost {  return {    async readFile(path: string): Promise<string> {      const data = tree.read(path);      if (!data) {        throw new SchematicsException('File not found.');      }      return virtualFs.fileBufferToString(data);    },    async writeFile(path: string, data: string): Promise<void> {      return tree.overwrite(path, data);    },    async isDirectory(path: string): Promise<boolean> {      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;    },    async isFile(path: string): Promise<boolean> {      return tree.exists(path);    },  };}export function myService(options: MyServiceSchema): Rule {  return async (tree: Tree) => {    const host = createHost(tree);    const {workspace} = await workspaces.readWorkspace('/', host);    const project = options.project != null ? workspace.projects.get(options.project) : null;    if (!project) {      throw new SchematicsException(`Invalid project name: ${options.project}`);    }    const projectType = project.extensions.projectType === 'application' ? 'app' : 'lib';    if (options.path === undefined) {      options.path = `${project.sourceRoot}/${projectType}`;    }    const templateSource = apply(url('./files'), [      applyTemplates({        classify: strings.classify,        dasherize: strings.dasherize,        name: options.name,      }),      move(normalize(options.path as string)),    ]);    return chain([mergeWith(templateSource)]);  };}\n\n```\n\n\n\n\n\n\n    The `workspace.projects` object contains all the project-specific configuration information.\n\n3. The `options.path` determines where the schematic template files are moved to once the schematic is applied.\n\n    The `path` option in the schematic's schema is substituted by default with the current working directory.\n    If the `path` is not defined, use the `sourceRoot` from the project configuration along with the `projectType`.\n\n\n\n\ncheck\n\n```\n         import {  Rule,  Tree,  SchematicsException,  apply,  url,  applyTemplates,  move,  chain,  mergeWith,} from '@angular-devkit/schematics';import {strings, normalize, virtualFs, workspaces} from '@angular-devkit/core';import {Schema as MyServiceSchema} from './schema';function createHost(tree: Tree): workspaces.WorkspaceHost {  return {    async readFile(path: string): Promise<string> {      const data = tree.read(path);      if (!data) {        throw new SchematicsException('File not found.');      }      return virtualFs.fileBufferToString(data);    },    async writeFile(path: string, data: string): Promise<void> {      return tree.overwrite(path, data);    },    async isDirectory(path: string): Promise<boolean> {      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;    },    async isFile(path: string): Promise<boolean> {      return tree.exists(path);    },  };}export function myService(options: MyServiceSchema): Rule {  return async (tree: Tree) => {    const host = createHost(tree);    const {workspace} = await workspaces.readWorkspace('/', host);    const project = options.project != null ? workspace.projects.get(options.project) : null;    if (!project) {      throw new SchematicsException(`Invalid project name: ${options.project}`);    }    const projectType = project.extensions.projectType === 'application' ? 'app' : 'lib';    if (options.path === undefined) {      options.path = `${project.sourceRoot}/${projectType}`;    }    const templateSource = apply(url('./files'), [      applyTemplates({        classify: strings.classify,        dasherize: strings.dasherize,        name: options.name,      }),      move(normalize(options.path as string)),    ]);    return chain([mergeWith(templateSource)]);  };}\n\n```\n\n\n### [Define the rule](https://angular.dev/tools/cli/schematics-for-libraries\\#define-the-rule)\n\nA `Rule` can use external template files, transform them, and return another `Rule` object with the transformed template.\nUse the templating to generate any custom files required for your schematic.\n\n1. Add the following code to your factory function.\n\n\n\n\ncheck\n\n```\n         import {  Rule,  Tree,  SchematicsException,  apply,  url,  applyTemplates,  move,  chain,  mergeWith,} from '@angular-devkit/schematics';import {strings, normalize, virtualFs, workspaces} from '@angular-devkit/core';import {Schema as MyServiceSchema} from './schema';function createHost(tree: Tree): workspaces.WorkspaceHost {  return {    async readFile(path: string): Promise<string> {      const data = tree.read(path);      if (!data) {        throw new SchematicsException('File not found.');      }      return virtualFs.fileBufferToString(data);    },    async writeFile(path: string, data: string): Promise<void> {      return tree.overwrite(path, data);    },    async isDirectory(path: string): Promise<boolean> {      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;    },    async isFile(path: string): Promise<boolean> {      return tree.exists(path);    },  };}export function myService(options: MyServiceSchema): Rule {  return async (tree: Tree) => {    const host = createHost(tree);    const {workspace} = await workspaces.readWorkspace('/', host);    const project = options.project != null ? workspace.projects.get(options.project) : null;    if (!project) {      throw new SchematicsException(`Invalid project name: ${options.project}`);    }    const projectType = project.extensions.projectType === 'application' ? 'app' : 'lib';    if (options.path === undefined) {      options.path = `${project.sourceRoot}/${projectType}`;    }    const templateSource = apply(url('./files'), [      applyTemplates({        classify: strings.classify,        dasherize: strings.dasherize,        name: options.name,      }),      move(normalize(options.path as string)),    ]);    return chain([mergeWith(templateSource)]);  };}\n\n```\n\n\n\n\n\n\n\n\n\n| Methods | Details |\n| :-- | :-- |\n| `apply()` | Applies multiple rules to a source and returns the transformed source. It takes 2 arguments, a source and an array of rules. |\n| `url()` | Reads source files from your filesystem, relative to the schematic. |\n| `applyTemplates()` | Receives an argument of methods and properties you want make available to the schematic template and the schematic filenames. It returns a `Rule`. This is where you define the `classify()` and `dasherize()` methods, and the `name` property. |\n| `classify()` | Takes a value and returns the value in title case. For example, if the provided name is `my service`, it is returned as `MyService`. |\n| `dasherize()` | Takes a value and returns the value in dashed and lowercase. For example, if the provided name is MyService, it is returned as `my-service`. |\n| `move()` | Moves the provided source files to their destination when the schematic is applied. |\n\n2. Finally, the rule factory must return a rule.\n\n\n\n\ncheck\n\n```\n         import {  Rule,  Tree,  SchematicsException,  apply,  url,  applyTemplates,  move,  chain,  mergeWith,} from '@angular-devkit/schematics';import {strings, normalize, virtualFs, workspaces} from '@angular-devkit/core';import {Schema as MyServiceSchema} from './schema';function createHost(tree: Tree): workspaces.WorkspaceHost {  return {    async readFile(path: string): Promise<string> {      const data = tree.read(path);      if (!data) {        throw new SchematicsException('File not found.');      }      return virtualFs.fileBufferToString(data);    },    async writeFile(path: string, data: string): Promise<void> {      return tree.overwrite(path, data);    },    async isDirectory(path: string): Promise<boolean> {      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;    },    async isFile(path: string): Promise<boolean> {      return tree.exists(path);    },  };}export function myService(options: MyServiceSchema): Rule {  return async (tree: Tree) => {    const host = createHost(tree);    const {workspace} = await workspaces.readWorkspace('/', host);    const project = options.project != null ? workspace.projects.get(options.project) : null;    if (!project) {      throw new SchematicsException(`Invalid project name: ${options.project}`);    }    const projectType = project.extensions.projectType === 'application' ? 'app' : 'lib';    if (options.path === undefined) {      options.path = `${project.sourceRoot}/${projectType}`;    }    const templateSource = apply(url('./files'), [      applyTemplates({        classify: strings.classify,        dasherize: strings.dasherize,        name: options.name,      }),      move(normalize(options.path as string)),    ]);    return chain([mergeWith(templateSource)]);  };}\n\n```\n\n\n\n\n\n\n    The `chain()` method lets you combine multiple rules into a single rule, so that you can perform multiple operations in a single schematic.\n    Here you are only merging the template rules with any code executed by the schematic.\n\n\nSee a complete example of the following schematic rule function.\n\n### projects/my-lib/schematics/my-service/index.ts\n\n```\n      import {  Rule,  Tree,  SchematicsException,  apply,  url,  applyTemplates,  move,  chain,  mergeWith,} from '@angular-devkit/schematics';import {strings, normalize, virtualFs, workspaces} from '@angular-devkit/core';import {Schema as MyServiceSchema} from './schema';function createHost(tree: Tree): workspaces.WorkspaceHost {  return {    async readFile(path: string): Promise<string> {      const data = tree.read(path);      if (!data) {        throw new SchematicsException('File not found.');      }      return virtualFs.fileBufferToString(data);    },    async writeFile(path: string, data: string): Promise<void> {      return tree.overwrite(path, data);    },    async isDirectory(path: string): Promise<boolean> {      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;    },    async isFile(path: string): Promise<boolean> {      return tree.exists(path);    },  };}export function myService(options: MyServiceSchema): Rule {  return async (tree: Tree) => {    const host = createHost(tree);    const {workspace} = await workspaces.readWorkspace('/', host);    const project = options.project != null ? workspace.projects.get(options.project) : null;    if (!project) {      throw new SchematicsException(`Invalid project name: ${options.project}`);    }    const projectType = project.extensions.projectType === 'application' ? 'app' : 'lib';    if (options.path === undefined) {      options.path = `${project.sourceRoot}/${projectType}`;    }    const templateSource = apply(url('./files'), [      applyTemplates({        classify: strings.classify,        dasherize: strings.dasherize,        name: options.name,      }),      move(normalize(options.path as string)),    ]);    return chain([mergeWith(templateSource)]);  };}\n\n```\n\ncheck\n\nFor more information about rules and utility methods, see [Provided Rules](https://github.com/angular/angular-cli/tree/main/packages/angular_devkit/schematics#provided-rules).\n\n## [Running your library schematic](https://angular.dev/tools/cli/schematics-for-libraries\\#running-your-library-schematic)\n\nAfter you build your library and schematics, you can install the schematics collection to run against your project.\nThe following steps show you how to generate a service using the schematic you created earlier.\n\n### [Build your library and schematics](https://angular.dev/tools/cli/schematics-for-libraries\\#build-your-library-and-schematics)\n\nFrom the root of your workspace, run the `ng build` command for your library.\n\n```\n      ng build my-lib\n\n```\n\ncheck\n\nThen, you change into your library directory to build the schematic\n\n```\n      cd projects/my-libnpm run build\n\n```\n\ncheck\n\n### [Link the library](https://angular.dev/tools/cli/schematics-for-libraries\\#link-the-library)\n\nYour library and schematics are packaged and placed in the `dist/my-lib` folder at the root of your workspace.\nFor running the schematic, you need to link the library into your `node_modules` folder.\nFrom the root of your workspace, run the `npm link` command with the path to your distributable library.\n\n```\n      npm link dist/my-lib\n\n```\n\ncheck\n\n### [Run the schematic](https://angular.dev/tools/cli/schematics-for-libraries\\#run-the-schematic)\n\nNow that your library is installed, run the schematic using the `ng generate` command.\n\n```\n      ng generate my-lib:my-service --name my-data\n\n```\n\ncheck\n\nIn the console, you see that the schematic was run and the `my-data.service.ts` file was created in your application folder.\n\n```\n      CREATE src/app/my-data.service.ts (208 bytes)\n\n```\n\ncheck",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-431eb768-6e65-432d-ad32-7d3978f627d1.png"
  },
  "metadata": {
    "language": "en",
    "description": "The web development framework for building modern apps.",
    "twitter:card": "summary_large_image",
    "ogUrl": "https://angular.dev/",
    "title": "Schematics for libraries â€¢ Angular",
    "viewport": "width=device-width, initial-scale=1",
    "apple-mobile-web-app-title": "Angular",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "og:type": "website",
    "ogDescription": "The web development framework for building modern apps.",
    "og:description": "The web development framework for building modern apps.",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:title": "Angular",
    "application-name": "Angular",
    "twitter:description": "The web development framework for building modern apps.",
    "msapplication-TileColor": "#e90464",
    "ogTitle": "Angular",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "theme-color": "#ffffff",
    "twitter:url": "https://angular.dev/",
    "og:url": "https://angular.dev/",
    "og:title": "Angular",
    "scrapeId": "63cdfaf3-96dc-4463-85d1-b19283b002fd",
    "sourceURL": "https://angular.dev/tools/cli/schematics-for-libraries",
    "url": "https://angular.dev/tools/cli/schematics-for-libraries",
    "statusCode": 200
  }
}