{
  "scrapeId": "a79f425e-b794-4bdb-ab57-357a9a5812a3",
  "sourceURL": "https://angular.dev/guide/forms",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backForms\n  - [Overview](https://angular.dev/guide/forms)\n  - [Reactive forms](https://angular.dev/guide/forms/reactive-forms)\n  - [Strictly typed reactive forms](https://angular.dev/guide/forms/typed-forms)\n  - [Template-driven forms](https://angular.dev/guide/forms/template-driven-forms)\n  - [Validate form input](https://angular.dev/guide/forms/form-validation)\n  - [Building dynamic forms](https://angular.dev/guide/forms/dynamic-forms)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nIn-depth Guides\n\nForms\n\n# Forms in Angular\n\n[edit](https://github.com/angular/angular/edit/main/adev/src/content/guide/forms/overview.md \"Edit this page\")\n\nHandling user input with forms is the cornerstone of many common applications.\n\nApplications use forms to enable users to log in, to update a profile, to enter sensitive information, and to perform many other data-entry tasks.\n\nAngular provides two different approaches to handling user input through forms: reactive and template-driven.\nBoth capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes.\n\nThis guide provides information to help you decide which type of form works best for your situation.\nIt introduces the common building blocks used by both approaches.\nIt also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing.\n\n## [Choosing an approach](https://angular.dev/guide/forms\\#choosing-an-approach)\n\nReactive forms and template-driven forms process and manage form data differently.\nEach approach offers different advantages.\n\n| Forms | Details |\n| :-- | :-- |\n| Reactive forms | Provide direct, explicit access to the underlying form's object model. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms. |\n| Template-driven forms | Rely on directives in the template to create and manipulate the underlying object model. They are useful for adding a simple form to an app, such as an email list signup form. They're straightforward to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit. |\n\n### [Key differences](https://angular.dev/guide/forms\\#key-differences)\n\nThe following table summarizes the key differences between reactive and template-driven forms.\n\n|  | Reactive | Template-driven |\n| :-- | :-- | :-- |\n| [Setup of form model](https://angular.dev/guide/forms#setting-up-the-form-model) | Explicit, created in component class | Implicit, created by directives |\n| [Data model](https://angular.dev/guide/forms#mutability-of-the-data-model) | Structured and immutable | Unstructured and mutable |\n| [Data flow](https://angular.dev/guide/forms#data-flow-in-forms) | Synchronous | Asynchronous |\n| [Form validation](https://angular.dev/guide/forms#form-validation) | Functions | Directives |\n\n### [Scalability](https://angular.dev/guide/forms\\#scalability)\n\nIf forms are a central part of your application, scalability is very important.\nBeing able to reuse form models across components is critical.\n\nReactive forms are more scalable than template-driven forms.\nThey provide direct access to the underlying form API, and use [synchronous data flow](https://angular.dev/guide/forms#data-flow-in-reactive-forms) between the view and the data model, which makes creating large-scale forms easier.\nReactive forms require less setup for testing, and testing does not require deep understanding of change detection to properly test form updates and validation.\n\nTemplate-driven forms focus on simple scenarios and are not as reusable.\nThey abstract away the underlying form API, and use [asynchronous data flow](https://angular.dev/guide/forms#data-flow-in-template-driven-forms) between the view and the data model.\nThe abstraction of template-driven forms also affects testing.\nTests are deeply reliant on manual change detection execution to run properly, and require more setup.\n\n## [Setting up the form model](https://angular.dev/guide/forms\\#setting-up-the-form-model)\n\nBoth reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model.\nThe two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances.\n\n### [Common form foundation classes](https://angular.dev/guide/forms\\#common-form-foundation-classes)\n\nBoth reactive and template-driven forms are built on the following base classes.\n\n| Base classes | Details |\n| :-- | :-- |\n| `FormControl` | Tracks the value and validation status of an individual form control. |\n| `FormGroup` | Tracks the same values and status for a collection of form controls. |\n| `FormArray` | Tracks the same values and status for an array of form controls. |\n| `ControlValueAccessor` | Creates a bridge between Angular `FormControl` instances and built-in DOM elements. |\n\n### [Setup in reactive forms](https://angular.dev/guide/forms\\#setup-in-reactive-forms)\n\nWith reactive forms, you define the form model directly in the component class.\nThe `[formControl]` directive links the explicitly created `FormControl` instance to a specific form element in the view, using an internal value accessor.\n\nThe following component implements an input field for a single control, using reactive forms.\nIn this example, the form model is the `FormControl` instance.\n\n```\n      import {Component} from '@angular/core';import {FormControl, ReactiveFormsModule} from '@angular/forms';@Component({  selector: 'app-reactive-favorite-color',  template: `    Favorite Color: <input type=\"text\" [formControl]=\"favoriteColorControl\">  `,  imports: [ReactiveFormsModule],})export class FavoriteColorReactiveComponent {  favoriteColorControl = new FormControl('');}\n\n```\n\ncheck\n\n**IMPORTANT:** In reactive forms, the form model is the source of truth; it provides the value and status of the form element at any given point in time, through the `[formControl]` directive on the `<input>` element.\n\n### [Setup in template-driven forms](https://angular.dev/guide/forms\\#setup-in-template-driven-forms)\n\nIn template-driven forms, the form model is implicit, rather than explicit.\nThe directive `NgModel` creates and manages a `FormControl` instance for a given form element.\n\nThe following component implements the same input field for a single control, using template-driven forms.\n\n```\n      import {Component} from '@angular/core';import {FormsModule} from '@angular/forms';@Component({  selector: 'app-template-favorite-color',  template: `    Favorite Color: <input type=\"text\" [(ngModel)]=\"favoriteColor\">  `,  imports: [FormsModule],})export class FavoriteColorTemplateComponent {  favoriteColor = '';}\n\n```\n\ncheck\n\n**IMPORTANT:** In a template-driven form the source of truth is the template. The `NgModel` directive automatically manages the `FormControl` instance for you.\n\n## [Data flow in forms](https://angular.dev/guide/forms\\#data-flow-in-forms)\n\nWhen an application contains a form, Angular must keep the view in sync with the component model and the component model in sync with the view.\nAs users change values and make selections through the view, the new values must be reflected in the data model.\nSimilarly, when the program logic changes values in the data model, those values must be reflected in the view.\n\nReactive and template-driven forms differ in how they handle data flowing from the user or from programmatic changes.\nThe following diagrams illustrate both kinds of data flow for each type of form, using the favorite-color input field defined above.\n\n### [Data flow in reactive forms](https://angular.dev/guide/forms\\#data-flow-in-reactive-forms)\n\nIn reactive forms each form element in the view is directly linked to the form model (a `FormControl` instance).\nUpdates from the view to the model and from the model to the view are synchronous and do not depend on how the UI is rendered.\n\nThe view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps.\n\n1. The user types a value into the input element, in this case the favorite color _Blue_.\n2. The form input element emits an \"input\" event with the latest value.\n3. The `ControlValueAccessor` listening for events on the form input element immediately relays the new value to the `FormControl` instance.\n4. The `FormControl` instance emits the new value through the `valueChanges` observable.\n5. Any subscribers to the `valueChanges` observable receive the new value.\n\nTypes in the input box\n\nFires the 'input' event\n\nCalls setValue() on the FormControl\n\nFires a 'valueChanges' event to observers\n\nUser\n\n<input>\n\nControlValueAccessor\n\nFormControl\n\nObservers\n\nThe model-to-view diagram shows how a programmatic change to the model is propagated to the view through the following steps.\n\n1. The user calls the `favoriteColorControl.setValue()` method, which updates the `FormControl` value.\n2. The `FormControl` instance emits the new value through the `valueChanges` observable.\n3. Any subscribers to the `valueChanges` observable receive the new value.\n4. The control value accessor on the form input element updates the element with the new value.\n\nCalls setValue() on the FormControl\n\nNotifies the ControlValueAccessor\n\nFires a 'valueChanges' event to observers\n\nUpdates the value of the <input>\n\nUser\n\n<input>\n\nControlValueAccessor\n\nFormControl\n\nObservers\n\n### [Data flow in template-driven forms](https://angular.dev/guide/forms\\#data-flow-in-template-driven-forms)\n\nIn template-driven forms, each form element is linked to a directive that manages the form model internally.\n\nThe view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps.\n\n1. The user types _Blue_ into the input element.\n2. The input element emits an \"input\" event with the value _Blue_.\n3. The control value accessor attached to the input triggers the `setValue()` method on the `FormControl` instance.\n4. The `FormControl` instance emits the new value through the `valueChanges` observable.\n5. Any subscribers to the `valueChanges` observable receive the new value.\n6. The control value accessor also calls the `NgModel.viewToModelUpdate()` method which emits an `ngModelChange` event.\n7. Because the component template uses two-way data binding for the `favoriteColor` property, the `favoriteColor` property in the component is updated to the value emitted by the `ngModelChange` event ( _Blue_).\n\nTypes in the input box\n\nFires the 'input' event\n\nCalls setValue() on the FormControl\n\nFires a 'valueChanges' event to observers\n\nCalls viewToModelUpdate()\n\nEmits an ngModelChange event\n\nUpdates the value of the two-way bound property\n\nUser\n\n<input>\n\nControlValueAccessor\n\nFormControl\n\nNgModel\n\nObservers\n\nComponent\n\nTwo-way binding\n\nThe model-to-view diagram shows how data flows from model to view when the `favoriteColor` changes from _Blue_ to _Red_, through the following steps\n\n1. The `favoriteColor` value is updated in the component.\n2. Change detection begins.\n3. During change detection, the `ngOnChanges` lifecycle hook is called on the `NgModel` directive instance because the value of one of its inputs has changed.\n4. The `ngOnChanges()` method queues an async task to set the value for the internal `FormControl` instance.\n5. Change detection completes.\n6. On the next tick, the task to set the `FormControl` instance value is executed.\n7. The `FormControl` instance emits the latest value through the `valueChanges` observable.\n8. Any subscribers to the `valueChanges` observable receive the new value.\n9. The control value accessor updates the form input element in the view with the latest `favoriteColor` value.\n\nUpdates the property value\n\nTriggers CD\n\nAsync actions trigger a second round of Change Detection\n\nSecond Change Detection\n\nFires a 'valueChanges' event to observers\n\nControlValueAccessor receives valueChanges event\n\nSets the value in the control\n\nFormControl\n\nObservers\n\nControlValueAccessor\n\n<input>\n\nFirst Change Detection\n\nAsynchronously sets FormControl value\n\nNgModel\n\nFormControl\n\nComponent\n\nProperty bound to NgModel\n\n**NOTE:** `NgModel` triggers a second change detection to avoid `ExpressionChangedAfterItHasBeenChecked` errors, because the value change originates in an input binding.\n\n### [Mutability of the data model](https://angular.dev/guide/forms\\#mutability-of-the-data-model)\n\nThe change-tracking method plays a role in the efficiency of your application.\n\n| Forms | Details |\n| :-- | :-- |\n| Reactive forms | Keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the `FormControl` instance returns a new data model rather than updating the existing data model. This gives you the ability to track unique changes to the data model through the control's observable. Change detection is more efficient because it only needs to update on unique changes. Because data updates follow reactive patterns, you can integrate with observable operators to transform data. |\n| Template-driven forms | Rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, change detection is less efficient at determining when updates are required. |\n\nThe difference is demonstrated in the previous examples that use the favorite-color input element.\n\n- With reactive forms, the **`FormControl` instance** always returns a new value when the control's value is updated\n- With template-driven forms, the **favorite color property** is always modified to its new value\n\n## [Form validation](https://angular.dev/guide/forms\\#form-validation)\n\nValidation is an integral part of managing any set of forms.\nWhether you're checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators.\n\n| Forms | Details |\n| :-- | :-- |\n| Reactive forms | Define custom validators as **functions** that receive a control to validate |\n| Template-driven forms | Tied to template **directives**, and must provide custom validator directives that wrap validation functions |\n\nFor more information, see [Form Validation](https://angular.dev/guide/guide/forms/form-validation#validating-input-in-reactive-forms).\n\n## [Testing](https://angular.dev/guide/forms\\#testing)\n\nTesting plays a large part in complex applications.\nA simpler testing strategy is useful when validating that your forms function correctly.\nReactive forms and template-driven forms have different levels of reliance on rendering the UI to perform assertions based on form control and form field changes.\nThe following examples demonstrate the process of testing forms with reactive and template-driven forms.\n\n### [Testing reactive forms](https://angular.dev/guide/forms\\#testing-reactive-forms)\n\nReactive forms provide a relatively straightforward testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI.\nIn these tests, status and data are queried and manipulated through the control without interacting with the change detection cycle.\n\nThe following tests use the favorite-color components from previous examples to verify the view-to-model and model-to-view data flows for a reactive form.\n\n#### [Verifying view-to-model data flow](https://angular.dev/guide/forms\\#verifying-view-to-model-data-flow)\n\nThe first example performs the following steps to verify the view-to-model data flow.\n\n1. Query the view for the form input element, and create a custom \"input\" event for the test.\n2. Set the new value for the input to _Red_, and dispatch the \"input\" event on the form input element.\n3. Assert that the component's `favoriteColorControl` value matches the value from the input.\n\ncheck\n\n```\n      import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {createNewEvent} from '../../shared/utils';import {FavoriteColorReactiveComponent} from './favorite-color.component';describe('Favorite Color Component', () => {  let component: FavoriteColorReactiveComponent;  let fixture: ComponentFixture<FavoriteColorReactiveComponent>;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      declarations: [FavoriteColorReactiveComponent],    }).compileComponents();  }));  beforeEach(() => {    fixture = TestBed.createComponent(FavoriteColorReactiveComponent);    component = fixture.componentInstance;    fixture.detectChanges();  });  it('should create', () => {    expect(component).toBeTruthy();  });  it('should update the value of the input field', () => {    const input = fixture.nativeElement.querySelector('input');    const event = createNewEvent('input');    input.value = 'Red';    input.dispatchEvent(event);    expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');  });  it('should update the value in the control', () => {    component.favoriteColorControl.setValue('Blue');    const input = fixture.nativeElement.querySelector('input');    expect(input.value).toBe('Blue');  });});\n\n```\n\nThe next example performs the following steps to verify the model-to-view data flow.\n\n1. Use the `favoriteColorControl`, a `FormControl` instance, to set the new value.\n2. Query the view for the form input element.\n3. Assert that the new value set on the control matches the value in the input.\n\ncheck\n\n```\n      import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {createNewEvent} from '../../shared/utils';import {FavoriteColorReactiveComponent} from './favorite-color.component';describe('Favorite Color Component', () => {  let component: FavoriteColorReactiveComponent;  let fixture: ComponentFixture<FavoriteColorReactiveComponent>;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      declarations: [FavoriteColorReactiveComponent],    }).compileComponents();  }));  beforeEach(() => {    fixture = TestBed.createComponent(FavoriteColorReactiveComponent);    component = fixture.componentInstance;    fixture.detectChanges();  });  it('should create', () => {    expect(component).toBeTruthy();  });  it('should update the value of the input field', () => {    const input = fixture.nativeElement.querySelector('input');    const event = createNewEvent('input');    input.value = 'Red';    input.dispatchEvent(event);    expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');  });  it('should update the value in the control', () => {    component.favoriteColorControl.setValue('Blue');    const input = fixture.nativeElement.querySelector('input');    expect(input.value).toBe('Blue');  });});\n\n```\n\n### [Testing template-driven forms](https://angular.dev/guide/forms\\#testing-template-driven-forms)\n\nWriting tests with template-driven forms requires a detailed knowledge of the change detection process and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time.\n\nThe following tests use the favorite color components mentioned earlier to verify the data flows from view to model and model to view for a template-driven form.\n\nThe following test verifies the data flow from view to model.\n\ncheck\n\n```\n      import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {createNewEvent} from '../../shared/utils';import {FavoriteColorTemplateComponent} from './favorite-color.component';describe('FavoriteColorComponent', () => {  let component: FavoriteColorTemplateComponent;  let fixture: ComponentFixture<FavoriteColorTemplateComponent>;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      declarations: [FavoriteColorTemplateComponent],    }).compileComponents();  }));  beforeEach(() => {    fixture = TestBed.createComponent(FavoriteColorTemplateComponent);    component = fixture.componentInstance;    fixture.detectChanges();  });  it('should create', () => {    expect(component).toBeTruthy();  });  it('should update the favorite color on the input field', fakeAsync(() => {    component.favoriteColor = 'Blue';    fixture.detectChanges();    tick();    const input = fixture.nativeElement.querySelector('input');    expect(input.value).toBe('Blue');  }));  it('should update the favorite color in the component', fakeAsync(() => {    const input = fixture.nativeElement.querySelector('input');    const event = createNewEvent('input');    input.value = 'Red';    input.dispatchEvent(event);    fixture.detectChanges();    expect(component.favoriteColor).toEqual('Red');  }));});\n\n```\n\nHere are the steps performed in the view to model test.\n\n1. Query the view for the form input element, and create a custom \"input\" event for the test.\n2. Set the new value for the input to _Red_, and dispatch the \"input\" event on the form input element.\n3. Run change detection through the test fixture.\n4. Assert that the component `favoriteColor` property value matches the value from the input.\n\nThe following test verifies the data flow from model to view.\n\ncheck\n\n```\n      import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {createNewEvent} from '../../shared/utils';import {FavoriteColorTemplateComponent} from './favorite-color.component';describe('FavoriteColorComponent', () => {  let component: FavoriteColorTemplateComponent;  let fixture: ComponentFixture<FavoriteColorTemplateComponent>;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      declarations: [FavoriteColorTemplateComponent],    }).compileComponents();  }));  beforeEach(() => {    fixture = TestBed.createComponent(FavoriteColorTemplateComponent);    component = fixture.componentInstance;    fixture.detectChanges();  });  it('should create', () => {    expect(component).toBeTruthy();  });  it('should update the favorite color on the input field', fakeAsync(() => {    component.favoriteColor = 'Blue';    fixture.detectChanges();    tick();    const input = fixture.nativeElement.querySelector('input');    expect(input.value).toBe('Blue');  }));  it('should update the favorite color in the component', fakeAsync(() => {    const input = fixture.nativeElement.querySelector('input');    const event = createNewEvent('input');    input.value = 'Red';    input.dispatchEvent(event);    fixture.detectChanges();    expect(component.favoriteColor).toEqual('Red');  }));});\n\n```\n\nHere are the steps performed in the model to view test.\n\n1. Use the component instance to set the value of the `favoriteColor` property.\n2. Run change detection through the test fixture.\n3. Use the `tick()` method to simulate the passage of time within the `fakeAsync()` task.\n4. Query the view for the form input element.\n5. Assert that the input value matches the value of the `favoriteColor` property in the component instance.\n\n## [Next steps](https://angular.dev/guide/forms\\#next-steps)\n\nTo learn more about reactive forms, see the following guides:\n\nTo learn more about template-driven forms, see the following guides:",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-214ce88e-10ad-488e-ae1a-b76f6dc4c47e.png"
  },
  "metadata": {
    "twitter:card": "summary_large_image",
    "twitter:url": "https://angular.dev/",
    "twitter:title": "Angular",
    "twitter:description": "The web development framework for building modern apps.",
    "application-name": "Angular",
    "title": "Forms â€¢ Overview â€¢ Angular",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "og:type": "website",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "apple-mobile-web-app-title": "Angular",
    "og:description": "The web development framework for building modern apps.",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "description": "The web development framework for building modern apps.",
    "language": "en",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "theme-color": "#ffffff",
    "ogDescription": "The web development framework for building modern apps.",
    "ogUrl": "https://angular.dev/",
    "og:url": "https://angular.dev/",
    "og:title": "Angular",
    "ogTitle": "Angular",
    "viewport": "width=device-width, initial-scale=1",
    "msapplication-TileColor": "#e90464",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "scrapeId": "a79f425e-b794-4bdb-ab57-357a9a5812a3",
    "sourceURL": "https://angular.dev/guide/forms",
    "url": "https://angular.dev/guide/forms",
    "statusCode": 200
  }
}