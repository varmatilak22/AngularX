{
  "scrapeId": "3a5514a7-bdb8-4485-9009-435b84e282d2",
  "sourceURL": "https://angular.dev/guide/testing/creating-component-harnesses",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backTesting\n  - [Overview](https://angular.dev/guide/testing)\n  - [Code coverage](https://angular.dev/guide/testing/code-coverage)\n  - [Testing services](https://angular.dev/guide/testing/services)\n  - [Basics of testing components](https://angular.dev/guide/testing/components-basics)\n  - [Component testing scenarios](https://angular.dev/guide/testing/components-scenarios)\n  - [Testing attribute directives](https://angular.dev/guide/testing/attribute-directives)\n  - [Testing pipes](https://angular.dev/guide/testing/pipes)\n  - [Debugging tests](https://angular.dev/guide/testing/debugging)\n  - [Testing utility APIs](https://angular.dev/guide/testing/utility-apis)\n  - [Component harnesses overview](https://angular.dev/guide/testing/component-harnesses-overview)\n  - [Using component harnesses in tests](https://angular.dev/guide/testing/using-component-harnesses)\n  - [Creating harnesses for your components](https://angular.dev/guide/testing/creating-component-harnesses)\n  - [Adding harness support for additional testing environments](https://angular.dev/guide/testing/component-harnesses-testing-environments)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\n## [Before you start](https://angular.dev/guide/testing/creating-component-harnesses\\#before-you-start)\n\n**TIP:** This guide assumes you've already read the [component harnesses overview guide](https://angular.dev/guide/testing/guide/testing/component-harnesses-overview). Read that first if you're new to using component harnesses.\n\n### [When does creating a test harness make sense?](https://angular.dev/guide/testing/creating-component-harnesses\\#when-does-creating-a-test-harness-make-sense)\n\nThe Angular team recommends creating component test harnesses for shared components that are used in many places and have some user interactivity. This most commonly applies to widget libraries and similar reusable components. Harnesses are valuable for these cases because they provide the consumers of these shared components a well- supported API for interacting with a component. Tests that use harnesses can avoid depending on unreliable implementation details of these shared components, such as DOM structure and specific event listeners.\n\nFor components that appear in only one place, such as a page in an application, harnesses don't provide as much benefit. In these situations, a component's tests can reasonably depend on the implementation details of this component, as the tests and components are updated at the same time. However, harnesses still provide some value if you would use the harness in both unit and end-to-end tests.\n\n### [CDK Installation](https://angular.dev/guide/testing/creating-component-harnesses\\#cdk-installation)\n\nThe [Component Dev Kit (CDK)](https://material.angular.io/cdk/categories) is a set of behavior primitives for building components. To use the component harnesses, first install `@angular/cdk` from npm. You can do this from your terminal using the Angular CLI:\n\n```\n      ng add @angular/cdk\n\n```\n\ncheck\n\n## [Extending `ComponentHarness`](https://angular.dev/guide/testing/creating-component-harnesses\\#extending-componentharness)\n\nThe abstract `ComponentHarness` class is the base class for all component harnesses. To create a custom component harness, extend `ComponentHarness` and implement the static property `hostSelector`.\n\nThe `hostSelector` property identifies elements in the DOM that match this harness subclass. In most cases, the `hostSelector` should be the same as the selector of the corresponding `Component` or `Directive`. For example, consider a simple popup component:\n\n```\n      @Component({  selector: 'my-popup',  template: `    <button (click)=\"toggle()\">{{triggerText()}}</button>    @if (isOpen()) {      <div class=\"my-popup-content\"><ng-content></ng-content></div>    }  `})class MyPopup {  triggerText = input('');  isOpen = signal(false);  toggle() {    this.isOpen.update((value) => !value);  }}\n\n```\n\ncheck\n\nIn this case, a minimal harness for the component would look like the following:\n\n```\n      class MyPopupHarness extends ComponentHarness {  static hostSelector = 'my-popup';}\n\n```\n\ncheck\n\nWhile `ComponentHarness` subclasses require only the `hostSelector` property, most harnesses should also implement a static `with` method to generate `HarnessPredicate` instances. The [filtering harnesses section](https://angular.dev/guide/testing/guide/testing/using-component-harnesses#filtering-harnesses) covers this in more detail.\n\n## [Finding elements in the component's DOM](https://angular.dev/guide/testing/creating-component-harnesses\\#finding-elements-in-the-components-dom)\n\nEach instance of a `ComponentHarness` subclass represents a particular instance of the corresponding component. You can access the component's host element via the `host() ` method from the `ComponentHarness` base class.\n\n`ComponentHarness` also offers several methods for locating elements within the component's DOM. These methods are `locatorFor()`, `locatorForOptional()`, and `locatorForAll()`. These methods create functions that find elements, they do not directly find elements. This approach safeguards against caching references to out-of-date elements. For example, when an `ngIf` hides and then shows an element, the result is a new DOM element; using functions ensures that tests always reference the current state of the DOM.\n\nSee the [ComponentHarness API reference page](https://material.angular.io/cdk/testing/api#ComponentHarness) for the full list details of the different `locatorFor` methods.\n\nFor example, the `MyPopupHarness` example discussed above could provide methods to get the trigger and content elements as follows:\n\n```\n      class MyPopupHarness extends ComponentHarness {  static hostSelector = 'my-popup';  /** Gets the trigger element */  getTriggerElement = this.locatorFor('button');  /** Gets the content element. */  getContentElement = this.locatorForOptional('.my-popup-content');}\n\n```\n\ncheck\n\n## [Working with `TestElement` instances](https://angular.dev/guide/testing/creating-component-harnesses\\#working-with-testelement-instances)\n\n`TestElement` is an abstraction designed to work across different test environments (Unit tests, WebDriver, etc). When using harnesses, you should perform all DOM interaction via this interface. Other means of accessing DOM elements, such as `document.querySelector()`, do not work in all test environments.\n\n`TestElement` has a number of methods to interact with the underlying DOM, such as `blur()`, `click()`, `getAttribute()`, and more. See the [TestElement API reference page](https://material.angular.io/cdk/testing/api#TestElement) for the full list of methods.\n\nDo not expose `TestElement` instances to harness users unless it's an element the component consumer defines directly, such as the component's host element. Exposing `TestElement` instances for internal elements leads users to depend on a component's internal DOM structure.\n\nInstead, provide more narrow-focused methods for specific actions the end-user may take or particular state they may observe. For example, `MyPopupHarness` from previous sections could provide methods like `toggle` and `isOpen`:\n\n```\n      class MyPopupHarness extends ComponentHarness {  static hostSelector = 'my-popup';  protected getTriggerElement = this.locatorFor('button');  protected getContentElement = this.locatorForOptional('.my-popup-content');  /** Toggles the open state of the popup. */  async toggle() {    const trigger = await this.getTriggerElement();    return trigger.click();  }  /** Checks if the popup us open. */  async isOpen() {    const content = await this.getContentElement();    return !!content;  }}\n\n```\n\ncheck\n\n## [Loading harnesses for subcomponents](https://angular.dev/guide/testing/creating-component-harnesses\\#loading-harnesses-for-subcomponents)\n\nLarger components often compose sub-components. You can reflect this structure in a component's harness as well. Each of the `locatorFor` methods on `ComponentHarness` has an alternate signature that can be used for locating sub-harnesses rather than elements.\n\nSee the [ComponentHarness API reference page](https://material.angular.io/cdk/testing/api#ComponentHarness) for the full list of the different locatorFor methods.\n\nFor example, consider a menu build using the popup from above:\n\n```\n      @Directive({  selector: 'my-menu-item'})class MyMenuItem {}@Component({  selector: 'my-menu',  template: `    <my-popup>      <ng-content></ng-content>    </my-popup>  `})class MyMenu {  triggerText = input('');  @ContentChildren(MyMenuItem) items: QueryList<MyMenuItem>;}\n\n```\n\ncheck\n\nThe harness for `MyMenu` can then take advantage of other harnesses for `MyPopup` and `MyMenuItem`:\n\n```\n      class MyMenuHarness extends ComponentHarness {  static hostSelector = 'my-menu';  protected getPopupHarness = this.locatorFor(MyPopupHarness);  /** Gets the currently shown menu items (empty list if menu is closed). */  getItems = this.locatorForAll(MyMenuItemHarness);  /** Toggles open state of the menu. */  async toggle() {    const popupHarness = await this.getPopupHarness();    return popupHarness.toggle();  }}class MyMenuItemHarness extends ComponentHarness {  static hostSelector = 'my-menu-item';}\n\n```\n\ncheck\n\n## [Filtering harness instances with `HarnessPredicate`](https://angular.dev/guide/testing/creating-component-harnesses\\#filtering-harness-instances-with-harnesspredicate)\n\nWhen a page contains multiple instances of a particular component, you may want to filter based on some property of the component to get a particular component instance. For example, you may want a button with some specific text, or a menu with a specific ID. The `HarnessPredicate` class can capture criteria like this for a `ComponentHarness` subclass. While the test author is able to construct `HarnessPredicate` instances manually, it's easier when the `ComponentHarness` subclass provides a helper method to construct predicates for common filters.\n\nYou should create a static `with()` method on each `ComponentHarness` subclass that returns a `HarnessPredicate` for that class. This allows test authors to write easily understandable code, e.g. `loader.getHarness(MyMenuHarness.with({selector: '#menu1'}))`. In addition to the standard selector and ancestor options, the `with` method should add any other options that make sense for the particular subclass.\n\nHarnesses that need to add additional options should extend the `BaseHarnessFilters` interface and additional optional properties as needed. `HarnessPredicate` provides several convenience methods for adding options: `stringMatches()`, `addOption()`, and `add()`. See the [HarnessPredicate API page](https://material.angular.io/cdk/testing/api#HarnessPredicate) for the full description.\n\nFor example, when working with a menu it is useful to filter based on trigger text and to filter menu items based on their text:\n\n```\n      interface MyMenuHarnessFilters extends BaseHarnessFilters {  /** Filters based on the trigger text for the menu. */  triggerText?: string | RegExp;}interface MyMenuItemHarnessFilters extends BaseHarnessFilters {  /** Filters based on the text of the menu item. */  text?: string | RegExp;}class MyMenuHarness extends ComponentHarness {  static hostSelector = 'my-menu';  /** Creates a `HarnessPredicate` used to locate a particular `MyMenuHarness`. */  static with(options: MyMenuHarnessFilters): HarnessPredicate<MyMenuHarness> {    return new HarnessPredicate(MyMenuHarness, options)        .addOption('trigger text', options.triggerText,            (harness, text) => HarnessPredicate.stringMatches(harness.getTriggerText(), text));  }  protected getPopupHarness = this.locatorFor(MyPopupHarness);  /** Gets the text of the menu trigger. */  async getTriggerText(): Promise<string> {    const popupHarness = await this.getPopupHarness();    return popupHarness.getTriggerText();  }  ...}class MyMenuItemHarness extends ComponentHarness {  static hostSelector = 'my-menu-item';  /** Creates a `HarnessPredicate` used to locate a particular `MyMenuItemHarness`. */  static with(options: MyMenuItemHarnessFilters): HarnessPredicate<MyMenuItemHarness> {    return new HarnessPredicate(MyMenuItemHarness, options)        .addOption('text', options.text,            (harness, text) => HarnessPredicate.stringMatches(harness.getText(), text));  }  /** Gets the text of the menu item. */  async getText(): Promise<string> {    const host = await this.host();    return host.text();  }}\n\n```\n\ncheck\n\nYou can pass a `HarnessPredicate` instead of a `ComponentHarness` class to any of the APIs on `HarnessLoader`, `LocatorFactory`, or `ComponentHarness`. This allows test authors to easily target a particular component instance when creating a harness instance. It also allows the harness author to leverage the same `HarnessPredicate` to enable more powerful APIs on their harness class. For example, consider the `getItems` method on the `MyMenuHarness` shown above. Adding a filtering API allows users of the harness to search for particular menu items:\n\n```\n      class MyMenuHarness extends ComponentHarness {  static hostSelector = 'my-menu';  /** Gets a list of items in the menu, optionally filtered based on the given criteria. */  async getItems(filters: MyMenuItemHarnessFilters = {}): Promise<MyMenuItemHarness[]> {    const getFilteredItems = this.locatorForAll(MyMenuItemHarness.with(filters));    return getFilteredItems();  }  ...}\n\n```\n\ncheck\n\n## [Creating `HarnessLoader` for elements that use content projection](https://angular.dev/guide/testing/creating-component-harnesses\\#creating-harnessloader-for-elements-that-use-content-projection)\n\nSome components project additional content into the component's template. See the [content projection guide](https://angular.dev/guide/testing/guide/components/content-projection) for more information.\n\nAdd a `HarnessLoader` instance scoped to the element containing the `<ng-content>` when you create a harness for a component that uses content projection. This allows the user of the harness to load additional harnesses for whatever components were passed in as content. `ComponentHarness` has several methods that can be used to create HarnessLoader instances for cases like this: `harnessLoaderFor()`, `harnessLoaderForOptional()`, `harnessLoaderForAll()`. See the [HarnessLoader interface API reference page](https://material.angular.io/cdk/testing/api#HarnessLoader) for more details.\n\nFor example, the `MyPopupHarness` example from above can extend `ContentContainerComponentHarness` to add support to load harnesses within the `<ng-content>` of the component.\n\n```\n      class MyPopupHarness extends ContentContainerComponentHarness<string> {  static hostSelector = 'my-popup';}\n\n```\n\ncheck\n\n## [Accessing elements outside of the component's host element](https://angular.dev/guide/testing/creating-component-harnesses\\#accessing-elements-outside-of-the-components-host-element)\n\nThere are times when a component harness might need to access elements outside of its corresponding component's host element. For example, code that displays a floating element or pop-up often attaches DOM elements directly to the document body, such as the `Overlay` service in Angular CDK.\n\nIn this case, `ComponentHarness` provides a method that can be used to get a `LocatorFactory` for the root element of the document. The `LocatorFactory` supports most of the same APIs as the `ComponentHarness` base class, and can then be used to query relative to the document's root element.\n\nConsider if the `MyPopup` component above used the CDK overlay for the popup content, rather than an element in its own template. In this case, `MyPopupHarness` would have to access the content element via `documentRootLocatorFactory()` method that gets a locator factory rooted at the document root.\n\n```\n      class MyPopupHarness extends ComponentHarness {  static hostSelector = 'my-popup';  /** Gets a `HarnessLoader` whose root element is the popup's content element. */  async getHarnessLoaderForContent(): Promise<HarnessLoader> {    const rootLocator = this.documentRootLocatorFactory();    return rootLocator.harnessLoaderFor('my-popup-content');  }}\n\n```\n\ncheck\n\n## [Waiting for asynchronous tasks](https://angular.dev/guide/testing/creating-component-harnesses\\#waiting-for-asynchronous-tasks)\n\nThe methods on `TestElement` automatically trigger Angular's change detection and wait for tasks inside the `NgZone`. In most cases no special effort is required for harness authors to wait on asynchronous tasks. However, there are some edge cases where this may not be sufficient.\n\nUnder some circumstances, Angular animations may require a second cycle of change detection and subsequent `NgZone` stabilization before animation events are fully flushed. In cases where this is needed, the `ComponentHarness` offers a `forceStabilize()` method that can be called to do the second round.\n\nYou can use `NgZone.runOutsideAngular()` to schedule tasks outside of NgZone. Call the `waitForTasksOutsideAngular()` method on the corresponding harness if you need to explicitly wait for tasks outside `NgZone` since this does not happen automatically.",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-48e67e57-1a7b-4a9f-bcd7-1ca8d3ef91be.png"
  },
  "metadata": {
    "ogTitle": "Angular",
    "language": "en",
    "ogUrl": "https://angular.dev/",
    "twitter:description": "The web development framework for building modern apps.",
    "theme-color": "#ffffff",
    "og:type": "website",
    "og:url": "https://angular.dev/",
    "og:title": "Angular",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "msapplication-TileColor": "#e90464",
    "application-name": "Angular",
    "og:description": "The web development framework for building modern apps.",
    "twitter:url": "https://angular.dev/",
    "viewport": "width=device-width, initial-scale=1",
    "twitter:title": "Angular",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "ogDescription": "The web development framework for building modern apps.",
    "apple-mobile-web-app-title": "Angular",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "twitter:card": "summary_large_image",
    "title": "Creating harnesses for your components â€¢ Angular",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "description": "The web development framework for building modern apps.",
    "scrapeId": "3a5514a7-bdb8-4485-9009-435b84e282d2",
    "sourceURL": "https://angular.dev/guide/testing/creating-component-harnesses",
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "statusCode": 200
  }
}