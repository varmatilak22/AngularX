{
  "scrapeId": "c0101876-49a7-4353-a5c0-5dabd9221961",
  "sourceURL": "https://angular.dev/guide/http/testing",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backHTTP Client\n  - [Overview](https://angular.dev/guide/http)\n  - [Setting up HttpClient](https://angular.dev/guide/http/setup)\n  - [Making requests](https://angular.dev/guide/http/making-requests)\n  - [Intercepting requests and responses](https://angular.dev/guide/http/interceptors)\n  - [Testing](https://angular.dev/guide/http/testing)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nAs for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server. The `@angular/common/http/testing` library provides tools to capture requests made by the application, make assertions about them, and mock the responses to emulate your backend's behavior.\n\nThe testing library is designed for a pattern in which the app executes code and makes requests first. The test then expects that certain requests have or have not been made, performs assertions against those requests, and finally provides responses by \"flushing\" each expected request.\n\nAt the end, tests can verify that the app made no unexpected requests.\n\n## [Setup for testing](https://angular.dev/guide/http/testing\\#setup-for-testing)\n\nTo begin testing usage of `HttpClient`, configure `TestBed` and include `provideHttpClient()` and `provideHttpClientTesting()` in your test's setup. This configures `HttpClient` to use a test backend instead of the real network. It also provides `HttpTestingController`, which you'll use to interact with the test backend, set expectations about which requests have been made, and flush responses to those requests. `HttpTestingController` can be injected from `TestBed` once configured.\n\nKeep in mind to provide `provideHttpClient()` **before** `provideHttpClientTesting()`, as `provideHttpClientTesting()` will overwrite parts of `provideHttpCient()`. Doing it the other way around can potentially break your tests.\n\n```\n      TestBed.configureTestingModule({  providers: [    // ... other test providers    provideHttpClient(),    provideHttpClientTesting(),  ],});const httpTesting = TestBed.inject(HttpTestingController);\n\n```\n\ncheck\n\nNow when your tests make requests, they will hit the testing backend instead of the normal one. You can use `httpTesting` to make assertions about those requests.\n\n## [Expecting and answering requests](https://angular.dev/guide/http/testing\\#expecting-and-answering-requests)\n\nFor example, you can write a test that expects a GET request to occur and provides a mock response:\n\n```\n      TestBed.configureTestingModule({  providers: [    ConfigService,    provideHttpClient(),    provideHttpClientTesting(),  ],});const httpTesting = TestBed.inject(HttpTestingController);// Load `ConfigService` and request the current configuration.const service = TestBed.inject(ConfigService);const config$ = this.configService.getConfig<Config>();// `firstValueFrom` subscribes to the `Observable`, which makes the HTTP request,// and creates a `Promise` of the response.const configPromise = firstValueFrom(config$);// At this point, the request is pending, and we can assert it was made// via the `HttpTestingController`:const req = httpTesting.expectOne('/api/config', 'Request to load the configuration');// We can assert various properties of the request if desired.expect(req.request.method).toBe('GET');// Flushing the request causes it to complete, delivering the result.req.flush(DEFAULT_CONFIG);// We can then assert that the response was successfully delivered by the `ConfigService`:expect(await configPromise).toEqual(DEFAULT_CONFIG);// Finally, we can assert that no other requests were made.httpTesting.verify();\n\n```\n\ncheck\n\n**NOTE:** `expectOne` will fail if the test has made more than one request which matches the given criteria.\n\nAs an alternative to asserting on `req.method`, you could instead use an expanded form of `expectOne` to also match the request method:\n\n```\n      const req = httpTesting.expectOne({  method: 'GET',  url: '/api/config',}, 'Request to load the configuration');\n\n```\n\ncheck\n\n**HELPFUL:** The expectation APIs match against the full URL of requests, including any query parameters.\n\nThe last step, verifying that no requests remain outstanding, is common enough for you to move it into an `afterEach()` step:\n\n```\n      afterEach(() => {  // Verify that none of the tests make any extra HTTP requests.  TestBed.inject(HttpTestingController).verify();});\n\n```\n\ncheck\n\n## [Handling more than one request at once](https://angular.dev/guide/http/testing\\#handling-more-than-one-request-at-once)\n\nIf you need to respond to duplicate requests in your test, use the `match()` API instead of `expectOne()`. It takes the same arguments but returns an array of matching requests. Once returned, these requests are removed from future matching and you are responsible for flushing and verifying them.\n\n```\n      const allGetRequests = httpTesting.match({method: 'GET'});for (const req of allGetRequests) {  // Handle responding to each request.}\n\n```\n\ncheck\n\n## [Advanced matching](https://angular.dev/guide/http/testing\\#advanced-matching)\n\nAll matching functions accept a predicate function for custom matching logic:\n\n```\n      // Look for one request that has a request body.const requestsWithBody = httpTesting.expectOne(req => req.body !== null);\n\n```\n\ncheck\n\nThe `expectNone` function asserts that no requests match the given criteria.\n\n```\n      // Assert that no mutation requests have been issued.httpTesting.expectNone(req => req.method !== 'GET');\n\n```\n\ncheck\n\n## [Testing error handling](https://angular.dev/guide/http/testing\\#testing-error-handling)\n\nYou should test your app's responses when HTTP requests fail.\n\n### [Backend errors](https://angular.dev/guide/http/testing\\#backend-errors)\n\nTo test handling of backend errors (when the server returns a non-successful status code), flush requests with an error response that emulates what your backend would return when a request fails.\n\n```\n      const req = httpTesting.expectOne('/api/config');req.flush('Failed!', {status: 500, statusText: 'Internal Server Error'});// Assert that the application successfully handled the backend error.\n\n```\n\ncheck\n\n### [Network errors](https://angular.dev/guide/http/testing\\#network-errors)\n\nRequests can also fail due to network errors, which surface as `ProgressEvent` errors. These can be delivered with the `error()` method:\n\n```\n      const req = httpTesting.expectOne('/api/config');req.error(new ProgressEvent('network error!'));// Assert that the application successfully handled the network error.\n\n```\n\ncheck\n\n## [Testing an Interceptor](https://angular.dev/guide/http/testing\\#testing-an-interceptor)\n\nYou should test that your interceptors work under the desired circumstances.\n\nFor example, an application may be required to add an authentication token generated by a service to each outgoing request.\nThis behavior can be enforced with the use of an interceptor:\n\n```\n      export function authInterceptor(request: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> {  const authService = inject(AuthService);  const clonedRequest = request.clone({    headers: request.headers.append('X-Authentication-Token', authService.getAuthToken()),  });  return next(clonedRequest);}\n\n```\n\ncheck\n\nThe `TestBed` configuration for this interceptor should rely on the `withInterceptors` feature.\n\n```\n      TestBed.configureTestingModule({  providers: [    AuthService,    // Testing one interceptor at a time is recommended.    provideHttpClient(withInterceptors([authInterceptor])),    provideHttpClientTesting(),  ],});\n\n```\n\ncheck\n\nThe `HttpTestingController` can retrieve the request instance which can then be inspected to ensure that the request was modified.\n\n```\n      const service = TestBed.inject(AuthService);const req = httpTesting.expectOne('/api/config');expect(req.request.headers.get('X-Authentication-Token')).toEqual(service.getAuthToken());\n\n```\n\ncheck\n\nA similar interceptor could be implemented with class based interceptors:\n\n```\n      @Injectable()export class AuthInterceptor implements HttpInterceptor {  private authService = inject(AuthService);  intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {    const clonedRequest = request.clone({      headers: request.headers.append('X-Authentication-Token', this.authService.getAuthToken()),    });    return next.handle(clonedRequest);  }}\n\n```\n\ncheck\n\nIn order to test it, the `TestBed` configuration should instead be:\n\n```\n      TestBed.configureTestingModule({  providers: [    AuthService,    provideHttpClient(withInterceptorsFromDi()),    provideHttpClientTesting(),    // We rely on the HTTP_INTERCEPTORS token to register the AuthInterceptor as an HttpInterceptor    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },  ],});\n\n```\n\ncheck",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-8c7749cb-ef45-4f96-8559-1e0cca8c7625.png"
  },
  "metadata": {
    "ogTitle": "Angular",
    "ogDescription": "The web development framework for building modern apps.",
    "theme-color": "#ffffff",
    "title": "Testing â€¢ Angular",
    "og:url": "https://angular.dev/",
    "og:title": "Angular",
    "og:description": "The web development framework for building modern apps.",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:url": "https://angular.dev/",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "language": "en",
    "description": "The web development framework for building modern apps.",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "ogUrl": "https://angular.dev/",
    "application-name": "Angular",
    "msapplication-TileColor": "#e90464",
    "twitter:title": "Angular",
    "viewport": "width=device-width, initial-scale=1",
    "twitter:description": "The web development framework for building modern apps.",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "og:type": "website",
    "apple-mobile-web-app-title": "Angular",
    "twitter:card": "summary_large_image",
    "scrapeId": "c0101876-49a7-4353-a5c0-5dabd9221961",
    "sourceURL": "https://angular.dev/guide/http/testing",
    "url": "https://angular.dev/guide/http/testing",
    "statusCode": 200
  }
}