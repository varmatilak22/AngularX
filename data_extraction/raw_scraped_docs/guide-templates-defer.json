{
  "scrapeId": "7070447c-eccd-4647-a637-c87f2328341c",
  "sourceURL": "https://angular.dev/guide/templates/defer",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backTemplates\n  - [Overview](https://angular.dev/guide/templates)\n  - [Binding dynamic text, properties and attributes](https://angular.dev/guide/templates/binding)\n  - [Adding event listeners](https://angular.dev/guide/templates/event-listeners)\n  - [Two-way binding](https://angular.dev/guide/templates/two-way-binding)\n  - [Control flow](https://angular.dev/guide/templates/control-flow)\n  - [Pipes](https://angular.dev/guide/templates/pipes)\n  - [Slotting child content with ng-content](https://angular.dev/guide/templates/ng-content)\n  - [Create template fragments with ng-template](https://angular.dev/guide/templates/ng-template)\n  - [Grouping elements with ng-container](https://angular.dev/guide/templates/ng-container)\n  - [Variables in templates](https://angular.dev/guide/templates/variables)\n  - [Deferred loading with @defer](https://angular.dev/guide/templates/defer)\n  - [Expression syntax](https://angular.dev/guide/templates/expression-syntax)\n  - [Whitespace in templates](https://angular.dev/guide/templates/whitespace)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nDeferrable views, also known as `@defer` blocks, reduce the initial bundle size of your application by deferring the loading of code that is not strictly necessary for the initial rendering of a page. This often results in a faster initial load and improvement in Core Web Vitals (CWV), primarily Largest Contentful Paint (LCP) and Time to First Byte (TTFB).\n\nTo use this feature, you can declaratively wrap a section of your template in a @defer block:\n\n```\n      @defer {  <large-component />}\n\n```\n\ncheck\n\nThe code for any components, directives, and pipes inside the `@defer` block is split into a separate JavaScript file and loaded only when necessary, after the rest of the template has been rendered.\n\nDeferrable views support a variety of triggers, prefetching options, and sub-blocks for placeholder, loading, and error state management.\n\n## [Which dependencies are deferred?](https://angular.dev/guide/templates/defer\\#which-dependencies-are-deferred)\n\nComponents, directives, pipes, and any component CSS styles can be deferred when loading an application.\n\nIn order for the dependencies within a `@defer` block to be deferred, they need to meet two conditions:\n\n1. **They must be standalone.** Non-standalone dependencies cannot be deferred and are still eagerly loaded, even if they are inside of `@defer` blocks.\n2. **They cannot be referenced outside of `@defer` blocks within the same file.** If they are referenced outside the `@defer` block or referenced within ViewChild queries, the dependencies will be eagerly loaded.\n\nThe _transitive_ dependencies of the components, directives and pipes used in the `@defer` block do not strictly need to be standalone; transitive dependencies can still be declared in an `NgModule` and participate in deferred loading.\n\nAngular's compiler produces a [dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) statement for each component, directive, and pipe used in the `@defer` block. The main content of the block renders after all the imports resolve. Angular does not guarantee any particular order for these imports.\n\n## [How to manage different stages of deferred loading](https://angular.dev/guide/templates/defer\\#how-to-manage-different-stages-of-deferred-loading)\n\n`@defer` blocks have several sub blocks to allow you to gracefully handle different stages in the deferred loading process.\n\n### [`@defer`](https://angular.dev/guide/templates/defer\\#defer)\n\nThis is the primary block that defines the section of content that is lazily loaded. It is not rendered initiallyâ€“ deferred content loads and renders once the specified [trigger](https://angular.dev/guide/defer#triggers) occurs or the `when` condition is met.\n\nBy default, a @defer block is triggered when the browser state becomes [idle](https://angular.dev/guide/defer#idle).\n\n```\n      @defer {  <large-component />}\n\n```\n\ncheck\n\n### [Show placeholder content with `@placeholder`](https://angular.dev/guide/templates/defer\\#show-placeholder-content-with-placeholder)\n\nBy default, defer blocks do not render any content before they are triggered.\n\nThe `@placeholder` is an optional block that declares what content to show before the `@defer` block is triggered.\n\n```\n      @defer {  <large-component />} @placeholder {  <p>Placeholder content</p>}\n\n```\n\ncheck\n\nWhile optional, certain triggers may require the presence of either a `@placeholder` or a [template reference variable](https://angular.dev/guide/templates/variables#template-reference-variables) to function. See the [Triggers](https://angular.dev/guide/defer#triggers) section for more details.\n\nAngular replaces placeholder content with the main content once loading is complete. You can use any content in the placeholder section including plain HTML, components, directives, and pipes. Keep in mind the _dependencies of the placeholder block are eagerly loaded_.\n\nThe `@placeholder` block accepts an optional parameter to specify the `minimum` amount of time that this placeholder should be shown after the placeholder content initially renders.\n\n```\n      @defer {  <large-component />} @placeholder (minimum 500ms) {  <p>Placeholder content</p>}\n\n```\n\ncheck\n\nThis `minimum` parameter is specified in time increments of milliseconds (ms) or seconds (s). You can use this parameter to prevent fast flickering of placeholder content in the case that the deferred dependencies are fetched quickly.\n\n### [Show loading content with `@loading`](https://angular.dev/guide/templates/defer\\#show-loading-content-with-loading)\n\nThe `@loading` block is an optional block that allows you to declare content that is shown while deferred dependencies are loading. It replaces the `@placeholder` block once loading is triggered.\n\n```\n      @defer {  <large-component />} @loading {  <img alt=\"loading...\" src=\"loading.gif\" />} @placeholder {  <p>Placeholder content</p>}\n\n```\n\ncheck\n\nIts dependencies are eagerly loaded (similar to `@placeholder`).\n\nThe `@loading` block accepts two optional parameters to help prevent fast flickering of content that may occur when deferred dependencies are fetched quickly,:\n\n- `minimum` \\- the minimum amount of time that this placeholder should be shown\n- `after` \\- the amount of time to wait after loading begins before showing the loading template\n\n```\n      @defer {  <large-component />} @loading (after 100ms; minimum 1s) {  <img alt=\"loading...\" src=\"loading.gif\" />}\n\n```\n\ncheck\n\nBoth parameters are specified in time increments of milliseconds (ms) or seconds (s). In addition, the timers for both parameters begin immediately after the loading has been triggered.\n\n### [Show error state when deferred loading fails with `@error`](https://angular.dev/guide/templates/defer\\#show-error-state-when-deferred-loading-fails-with-error)\n\nThe `@error` block is an optional block that displays if deferred loading fails. Similar to `@placeholder` and `@loading`, the dependencies of the @error block are eagerly loaded.\n\n```\n      @defer {  <large-component />} @error {  <p>Failed to load large component.</p>}\n\n```\n\ncheck\n\n## [Controlling deferred content loading with triggers](https://angular.dev/guide/templates/defer\\#controlling-deferred-content-loading-with-triggers)\n\nYou can specify **triggers** that control when Angular loads and displays deferred content.\n\nWhen a `@defer` block is triggered, it replaces placeholder content with lazily loaded content.\n\nMultiple event triggers can be defined by separating them with a semicolon, `;` and will be evaluated as OR conditions.\n\nThere are two types of triggers: `on` and `when`.\n\n### [`on`](https://angular.dev/guide/templates/defer\\#on)\n\n`on` specifies a condition for when the `@defer` block is triggered.\n\nThe available triggers are as follows:\n\n| Trigger | Description |\n| --- | --- |\n| [`idle`](https://angular.dev/guide/templates/defer#idle) | Triggers when the browser is idle. |\n| [`viewport`](https://angular.dev/guide/templates/defer#viewport) | Triggers when specified content enters the viewport |\n| [`interaction`](https://angular.dev/guide/templates/defer#interaction) | Triggers when the user interacts with specified element |\n| [`hover`](https://angular.dev/guide/templates/defer#hover) | Triggers when the mouse hovers over specified area |\n| [`immediate`](https://angular.dev/guide/templates/defer#immediate) | Triggers immediately after non-deferred content has finished rendering |\n| [`timer`](https://angular.dev/guide/templates/defer#timer) | Triggers after a specific duration |\n\n#### [`idle`](https://angular.dev/guide/templates/defer\\#idle)\n\nThe `idle` trigger loads the deferred content once the browser has reached an idle state, based on requestIdleCallback. This is the default behavior with a defer block.\n\n```\n      <!-- @defer (on idle) -->@defer {  <large-cmp />} @placeholder {  <div>Large component placeholder</div>}\n\n```\n\ncheck\n\n#### [`viewport`](https://angular.dev/guide/templates/defer\\#viewport)\n\nThe `viewport` trigger loads the deferred content when the specified content enters the viewport using the [Intersection Observer API](https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API). Observed content may be `@placeholder` content or an explicit element reference.\n\nBy default, the `@defer` watches for the placeholder entering the viewport. Placeholders used this way must have a single root element.\n\n```\n      @defer (on viewport) {  <large-cmp />} @placeholder {  <div>Large component placeholder</div>}\n\n```\n\ncheck\n\nAlternatively, you can specify a [template reference variable](https://angular.dev/guide/templates/variables) in the same template as the `@defer` block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger.\n\n```\n      <div #greeting>Hello!</div>@defer (on viewport(greeting)) {  <greetings-cmp />}\n\n```\n\ncheck\n\n#### [`interaction`](https://angular.dev/guide/templates/defer\\#interaction)\n\nThe `interaction` trigger loads the deferred content when the user interacts with the specified element through `click` or `keydown` events.\n\nBy default, the placeholder acts as the interaction element. Placeholders used this way must have a single root element.\n\n```\n      @defer (on interaction) {  <large-cmp />} @placeholder {  <div>Large component placeholder</div>}\n\n```\n\ncheck\n\nAlternatively, you can specify a [template reference variable](https://angular.dev/guide/templates/variables) in the same template as the `@defer` block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger.\n\n```\n      <div #greeting>Hello!</div>@defer (on interaction(greeting)) {  <greetings-cmp />}\n\n```\n\ncheck\n\n#### [`hover`](https://angular.dev/guide/templates/defer\\#hover)\n\nThe `hover` trigger loads the deferred content when the mouse has hovered over the triggered area through the `mouseover` and `focusin` events.\n\nBy default, the placeholder acts as the interaction element. Placeholders used this way must have a single root element.\n\n```\n      @defer (on hover) {  <large-cmp />} @placeholder {  <div>Large component placeholder</div>}\n\n```\n\ncheck\n\nAlternatively, you can specify a [template reference variable](https://angular.dev/guide/templates/variables) in the same template as the `@defer` block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger.\n\n```\n      <div #greeting>Hello!</div>@defer (on hover(greeting)) {  <greetings-cmp />}\n\n```\n\ncheck\n\n#### [`immediate`](https://angular.dev/guide/templates/defer\\#immediate)\n\nThe `immediate` trigger loads the deferred content immediately. This means that the deferred block loads as soon as all other non-deferred content has finished rendering.\n\n```\n      @defer (on immediate) {  <large-cmp />} @placeholder {  <div>Large component placeholder</div>}\n\n```\n\ncheck\n\n#### [`timer`](https://angular.dev/guide/templates/defer\\#timer)\n\nThe `timer` trigger loads the deferred content after a specified duration.\n\n```\n      @defer (on timer(500ms)) {  <large-cmp />} @placeholder {  <div>Large component placeholder</div>}\n\n```\n\ncheck\n\nThe duration parameter must be specified in milliseconds ( `ms`) or seconds ( `s`).\n\n### [`when`](https://angular.dev/guide/templates/defer\\#when)\n\nThe `when` trigger accepts a custom conditional expression and loads the deferred content when the condition becomes truthy.\n\n```\n      @defer (when condition) {  <large-cmp />} @placeholder {  <div>Large component placeholder</div>}\n\n```\n\ncheck\n\nThis is a one-time operationâ€“ the `@defer` block does not revert back to the placeholder if the condition changes to a falsy value after becoming truthy.\n\n## [Prefetching data with `prefetch`](https://angular.dev/guide/templates/defer\\#prefetching-data-with-prefetch)\n\nIn addition to specifying a condition that determines when deferred content is shown, you can optionally specify a **prefetch trigger**. This trigger lets you load the JavaScript associated with the `@defer` block before the deferred content is shown.\n\nPrefetching enables more advanced behaviors, such as letting you start to prefetch resources before a user has actually seen or interacted with a defer block, but might interact with it soon, making the resources available faster.\n\nYou can specify a prefetch trigger similarly to the block's main trigger, but prefixed with the `prefetch` keyword. The block's main trigger and prefetch trigger are separated with a semi-colon character ( `;`).\n\nIn the example below, the prefetching starts when a browser becomes idle and the contents of the block is rendered only once the user interacts with the placeholder.\n\n```\n      @defer (on interaction; prefetch on idle) {  <large-cmp />} @placeholder {  <div>Large component placeholder</div>}\n\n```\n\ncheck\n\n## [Testing `@defer` blocks](https://angular.dev/guide/templates/defer\\#testing-defer-blocks)\n\nAngular provides TestBed APIs to simplify the process of testing `@defer` blocks and triggering different states during testing. By default, `@defer` blocks in tests play through like a defer block would behave in a real application. If you want to manually step through states, you can switch the defer block behavior to `Manual` in the TestBed configuration.\n\n```\n      it('should render a defer block in different states', async () => {  // configures the defer block behavior to start in \"paused\" state for manual control.  TestBed.configureTestingModule({deferBlockBehavior: DeferBlockBehavior.Manual});  @Component({    // ...    template: `      @defer {        <large-component />      } @placeholder {        Placeholder      } @loading {        Loading...      }    `  })  class ComponentA {}  // Create component fixture.  const componentFixture = TestBed.createComponent(ComponentA);  // Retrieve the list of all defer block fixtures and get the first block.  const deferBlockFixture = (await componentFixture.getDeferBlocks())[0];  // Renders placeholder state by default.  expect(componentFixture.nativeElement.innerHTML).toContain('Placeholder');  // Render loading state and verify rendered output.  await deferBlockFixture.render(DeferBlockState.Loading);  expect(componentFixture.nativeElement.innerHTML).toContain('Loading');  // Render final state and verify the output.  await deferBlockFixture.render(DeferBlockState.Complete);  expect(componentFixture.nativeElement.innerHTML).toContain('large works!');});\n\n```\n\ncheck\n\n## [Does `@defer` work with `NgModule`?](https://angular.dev/guide/templates/defer\\#does-defer-work-with-ngmodule)\n\n`@defer` blocks are compatible with both standalone and NgModule-based components, directives and pipes. However, **only standalone components, directives and pipes can be deferred**. NgModule-based dependencies are not deferred and are included in the eagerly loaded bundle.\n\n## [How does `@defer` work with server-side rendering (SSR) and static-site generation (SSG)?](https://angular.dev/guide/templates/defer\\#how-does-defer-work-with-server-side-rendering-ssr-and-static-site-generation-ssg)\n\nBy default, when rendering an application on the server (either using SSR or SSG), defer blocks always render their `@placeholder` (or nothing if a placeholder is not specified) and triggers are not invoked. On the client, the content of the `@placeholder` is hydrated and triggers are activated.\n\nTo render the main content of `@defer` blocks on the server (both SSR and SSG), you can enable [the Incremental Hydration feature](https://angular.dev/guide/incremental-hydration) and configure `hydrate` triggers for the necessary blocks.\n\n## [Best practices for deferring views](https://angular.dev/guide/templates/defer\\#best-practices-for-deferring-views)\n\n### [Avoid cascading loads with nested `@defer` blocks](https://angular.dev/guide/templates/defer\\#avoid-cascading-loads-with-nested-defer-blocks)\n\nWhen you have nested `@defer` blocks, they should have different triggers in order to avoid loading simultaneously, which causes cascading requests and may negatively impact page load performance.\n\n### [Avoid layout shifts](https://angular.dev/guide/templates/defer\\#avoid-layout-shifts)\n\nAvoid deferring components that are visible in the userâ€™s viewport on initial load. Doing this may negatively affect Core Web Vitals by causing an increase in cumulative layout shift (CLS).\n\nIn the event this is necessary, avoid `immediate`, `timer`, `viewport`, and custom `when` triggers that cause the content to load during the initial page render.",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-3de862fd-87e9-48fa-890e-b2c115847491.png"
  },
  "metadata": {
    "og:type": "website",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "ogUrl": "https://angular.dev/",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "og:url": "https://angular.dev/",
    "application-name": "Angular",
    "og:title": "Angular",
    "twitter:url": "https://angular.dev/",
    "twitter:title": "Angular",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "apple-mobile-web-app-title": "Angular",
    "viewport": "width=device-width, initial-scale=1",
    "theme-color": "#ffffff",
    "title": "Deferred loading with @defer â€¢ Angular",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "msapplication-TileColor": "#e90464",
    "language": "en",
    "description": "The web development framework for building modern apps.",
    "ogTitle": "Angular",
    "og:description": "The web development framework for building modern apps.",
    "twitter:description": "The web development framework for building modern apps.",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "ogDescription": "The web development framework for building modern apps.",
    "twitter:card": "summary_large_image",
    "scrapeId": "7070447c-eccd-4647-a637-c87f2328341c",
    "sourceURL": "https://angular.dev/guide/templates/defer",
    "url": "https://angular.dev/guide/templates/defer",
    "statusCode": 200
  }
}