{
  "scrapeId": "dbb2aff8-9225-435f-b05d-8620c8f6e705",
  "sourceURL": "https://material.angular.io/guide/creating-a-custom-form-field-control",
  "statusCode": 200,
  "data": {
    "markdown": "# Creating a custom form field control\n\nIt is possible to create custom form field controls that can be used inside `<mat-form-field>`. This\ncan be useful if you need to create a component that shares a lot of common behavior with a form\nfield, but adds some additional logic.\n\nFor example in this guide we'll learn how to create a custom input for inputting US telephone\nnumbers and hook it up to work with `<mat-form-field>`. Here is what we'll build by the end of this\nguide:\n\nForm field with custom telephone number input control.\n\nlinkcodeopen\\_in\\_new\n\nPhone number\n\n––\n\nphone\n\nInclude area code\n\nEntered value: null\n\nIn order to learn how to build custom form field controls, let's start with a simple input component\nthat we want to work inside the form field. For example, a phone number input that segments the\nparts of the number into their own inputs. (Note: this is not intended to be a robust component,\njust a starting point for us to learn.)\n\n```ts\nclass MyTel {\n  constructor(public area: string, public exchange: string, public subscriber: string) {}\n}\n\n@Component({\n  selector: 'example-tel-input',\n  template: `\n    <div role=\"group\" [formGroup]=\"parts\">\n      <input class=\"area\" formControlName=\"area\" maxlength=\"3\">\n      <span>&ndash;</span>\n      <input class=\"exchange\" formControlName=\"exchange\" maxlength=\"3\">\n      <span>&ndash;</span>\n      <input class=\"subscriber\" formControlName=\"subscriber\" maxlength=\"4\">\n    </div>\n  `,\n  styles: [`\\\n    div {\\\n      display: flex;\\\n    }\\\n    input {\\\n      border: none;\\\n      background: none;\\\n      padding: 0;\\\n      outline: none;\\\n      font: inherit;\\\n      text-align: center;\\\n      color: currentColor;\\\n    }\\\n  `],\n})\nexport class MyTelInput {\n  parts: FormGroup;\n\n  @Input()\n  get value(): MyTel | null {\n    let n = this.parts.value;\n    if (n.area.length == 3 && n.exchange.length == 3 && n.subscriber.length == 4) {\n      return new MyTel(n.area, n.exchange, n.subscriber);\n    }\n    return null;\n  }\n  set value(tel: MyTel | null) {\n    tel = tel || new MyTel('', '', '');\n    this.parts.setValue({area: tel.area, exchange: tel.exchange, subscriber: tel.subscriber});\n  }\n\n  constructor(fb: FormBuilder) {\n    this.parts =  fb.group({\n      'area': '',\n      'exchange': '',\n      'subscriber': '',\n    });\n  }\n}\n\n```\n\n## [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#providing-our-component-as-a-matformfieldcontrol)  Providing our component as a MatFormFieldControl\n\nThe first step is to provide our new component as an implementation of the `MatFormFieldControl`\ninterface that the `<mat-form-field>` knows how to work with. To do this, we will have our class\nimplement `MatFormFieldControl`. Since this is a generic interface, we'll need to include a type\nparameter indicating the type of data our control will work with, in this case `MyTel`. We then add\na provider to our component so that the form field will be able to inject it as a\n`MatFormFieldControl`.\n\n```ts\n@Component({\n  ...\n  providers: [{provide: MatFormFieldControl, useExisting: MyTelInput}],\n})\nexport class MyTelInput implements MatFormFieldControl<MyTel> {\n  ...\n}\n\n```\n\nThis sets up our component, so it can work with `<mat-form-field>`, but now we need to implement the\nvarious methods and properties declared by the interface we just implemented. To learn more about\nthe `MatFormFieldControl` interface, see the\n[form field API documentation](https://material.angular.io/components/form-field/api).\n\n### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#implementing-the-methods-and-properties-of-matformfieldcontrol)  Implementing the methods and properties of MatFormFieldControl\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#value) `value`\n\nThis property allows someone to set or get the value of our control. Its type should be the same\ntype we used for the type parameter when we implemented `MatFormFieldControl`. Since our component\nalready has a value property, we don't need to do anything for this one.\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#statechanges) `stateChanges`\n\nBecause the `<mat-form-field>` uses the `OnPush` change detection strategy, we need to let it know\nwhen something happens in the form field control that may require the form field to run change\ndetection. We do this via the `stateChanges` property. So far the only thing the form field needs to\nknow about is when the value changes. We'll need to emit on the stateChanges stream when that\nhappens, and as we continue flushing out these properties we'll likely find more places we need to\nemit. We should also make sure to complete `stateChanges` when our component is destroyed.\n\n```ts\nstateChanges = new Subject<void>();\n\nset value(tel: MyTel | null) {\n  ...\n  this.stateChanges.next();\n}\n\nngOnDestroy() {\n  this.stateChanges.complete();\n}\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#id) `id`\n\nThis property should return the ID of an element in the component's template that we want the\n`<mat-form-field>` to associate all of its labels and hints with. In this case, we'll use the host\nelement and just generate a unique ID for it.\n\n```ts\nstatic nextId = 0;\n\n@HostBinding() id = `example-tel-input-${MyTelInput.nextId++}`;\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#placeholder) `placeholder`\n\nThis property allows us to tell the `<mat-form-field>` what to use as a placeholder. In this\nexample, we'll do the same thing as `matInput` and `<mat-select>` and allow the user to specify it\nvia an `@Input()`. Since the value of the placeholder may change over time, we need to make sure to\ntrigger change detection in the parent form field by emitting on the `stateChanges` stream when the\nplaceholder changes.\n\n```ts\n@Input()\nget placeholder() {\n  return this._placeholder;\n}\nset placeholder(plh) {\n  this._placeholder = plh;\n  this.stateChanges.next();\n}\nprivate _placeholder: string;\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#ngcontrol) `ngControl`\n\nThis property allows the form field control to specify the `@angular/forms` control that is bound\nto this component. Since we haven't set up our component to act as a `ControlValueAccessor`, we'll\njust set this to `null` in our component.\n\n```ts\nngControl: NgControl = null;\n\n```\n\nIt is likely you will want to implement `ControlValueAccessor` so that your component can work with\n`formControl` and `ngModel`. If you do implement `ControlValueAccessor` you will need to get a\nreference to the `NgControl` associated with your control and make it publicly available.\n\nThe easy way is to add it as a public property to your constructor and let dependency injection\nhandle it:\n\n```ts\nconstructor(\n  ...,\n  @Optional() @Self() public ngControl: NgControl,\n  ...,\n) { }\n\n```\n\nNote that if your component implements `ControlValueAccessor`, it may already be set up to provide\n`NG_VALUE_ACCESSOR` (in the `providers` part of the component's decorator, or possibly in a module\ndeclaration). If so, you may get a _cannot instantiate cyclic dependency_ error.\n\nTo resolve this, remove the `NG_VALUE_ACCESSOR` provider and instead set the value accessor directly:\n\n```ts\n@Component({\n  ...,\n  providers: [\\\n    ...,\\\n    // Remove this.\\\n    // {\\\n    //   provide: NG_VALUE_ACCESSOR,\\\n    //   useExisting: forwardRef(() => MatFormFieldControl),\\\n    //   multi: true,\\\n    // },\\\n  ],\n})\nexport class MyTelInput implements MatFormFieldControl<MyTel>, ControlValueAccessor {\n  constructor(\n    ...,\n    @Optional() @Self() public ngControl: NgControl,\n    ...,\n  ) {\n\n    // Replace the provider from above with this.\n    if (this.ngControl != null) {\n      // Setting the value accessor directly (instead of using\n      // the providers) to avoid running into a circular import.\n      this.ngControl.valueAccessor = this;\n    }\n  }\n}\n\n```\n\nFor additional information about `ControlValueAccessor` see the [API docs](https://angular.dev/api/forms/ControlValueAccessor).\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#focused) `focused`\n\nThis property indicates whether the form field control should be considered to be in a\nfocused state. When it is in a focused state, the form field is displayed with a solid color\nunderline. For the purposes of our component, we want to consider it focused if any of the part\ninputs are focused. We can use the `focusin` and `focusout` events to easily check this. We also\nneed to remember to emit on the `stateChanges` when the focused stated changes stream so change\ndetection can happen.\n\nIn addition to updating the focused state, we use the `focusin` and `focusout` methods to update the\ninternal touched state of our component, which we'll use to determine the error state.\n\n```ts\nfocused = false;\n\nonFocusIn(event: FocusEvent) {\n  if (!this.focused) {\n    this.focused = true;\n    this.stateChanges.next();\n  }\n}\n\nonFocusOut(event: FocusEvent) {\n  if (!this._elementRef.nativeElement.contains(event.relatedTarget as Element)) {\n    this.touched = true;\n    this.focused = false;\n    this.onTouched();\n    this.stateChanges.next();\n  }\n}\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#empty) `empty`\n\nThis property indicates whether the form field control is empty. For our control, we'll consider it\nempty if all the parts are empty.\n\n```ts\nget empty() {\n  let n = this.parts.value;\n  return !n.area && !n.exchange && !n.subscriber;\n}\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#shouldlabelfloat) `shouldLabelFloat`\n\nThis property is used to indicate whether the label should be in the floating position. We'll\nuse the same logic as `matInput` and float the placeholder when the input is focused or non-empty.\nSince the placeholder will be overlapping our control when it's not floating, we should hide\nthe `–` characters when it's not floating.\n\n```ts\n@HostBinding('class.floating')\nget shouldLabelFloat() {\n  return this.focused || !this.empty;\n}\n\n```\n\n```css\nspan {\n  opacity: 0;\n  transition: opacity 200ms;\n}\n:host.floating span {\n  opacity: 1;\n}\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#required) `required`\n\nThis property is used to indicate whether the input is required. `<mat-form-field>` uses this\ninformation to add a required indicator to the placeholder. Again, we'll want to make sure we run\nchange detection if the required state changes.\n\n```ts\n@Input()\nget required() {\n  return this._required;\n}\nset required(req: BooleanInput) {\n  this._required = coerceBooleanProperty(req);\n  this.stateChanges.next();\n}\nprivate _required = false;\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#disabled) `disabled`\n\nThis property tells the form field when it should be in the disabled state. In addition to reporting\nthe right state to the form field, we need to set the disabled state on the individual inputs that\nmake up our component.\n\n```ts\n@Input()\nget disabled(): boolean { return this._disabled; }\nset disabled(value: BooleanInput) {\n  this._disabled = coerceBooleanProperty(value);\n  this._disabled ? this.parts.disable() : this.parts.enable();\n  this.stateChanges.next();\n}\nprivate _disabled = false;\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#errorstate) `errorState`\n\nThis property indicates whether the associated `NgControl` is in an error state. For example,\nwe can show an error if the input is invalid and our component has been touched.\n\n```ts\nget errorState(): boolean {\n  return this.parts.invalid && this.touched;\n}\n\n```\n\nHowever, there are some error triggers that we can't subscribe to (e.g. parent form submissions),\nto handle such cases we should re-evaluate `errorState` on every change detection cycle.\n\n```ts\n/** Whether the component is in an error state. */\nerrorState: boolean = false;\n\nconstructor(\n  ...,\n  @Optional() private _parentForm: NgForm,\n  @Optional() private _parentFormGroup: FormGroupDirective\n) {\n...\n}\n\nngDoCheck() {\n  if (this.ngControl) {\n    this.updateErrorState();\n  }\n}\n\nprivate updateErrorState() {\n  const parentSubmitted = this._parentFormGroup?.submitted || this._parentForm?.submitted;\n  const touchedOrParentSubmitted = this.touched || parentSubmitted;\n\n  const newState = (this.ngControl?.invalid || this.parts.invalid) && touchedOrParentSubmitted;\n\n  if (this.errorState !== newState) {\n    this.errorState = newState;\n    this.stateChanges.next(); // Notify listeners of state changes.\n  }\n}\n\n```\n\nKeep in mind that `updateErrorState()` must have minimal logic to avoid performance issues.\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#controltype) `controlType`\n\nThis property allows us to specify a unique string for the type of control in form field. The\n`<mat-form-field>` will add a class based on this type that can be used to easily apply\nspecial styles to a `<mat-form-field>` that contains a specific type of control. In this example\nwe'll use `example-tel-input` as our control type which will result in the form field adding the\nclass `mat-form-field-type-example-tel-input`.\n\n```ts\ncontrolType = 'example-tel-input';\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#setdescribedbyidsids-string) `setDescribedByIds(ids: string[])`\n\nThis method is used by the `<mat-form-field>` to set element ids that should be used for the\n`aria-describedby` attribute of your control. The ids are controlled through the form field\nas hints or errors are conditionally displayed and should be reflected in the control's\n`aria-describedby` attribute for an improved accessibility experience.\n\nThe `setDescribedByIds` method is invoked whenever the control's state changes. Custom controls\nneed to implement this method and update the `aria-describedby` attribute based on the specified\nelement ids. Below is an example that shows how this can be achieved.\n\nNote that the method by default will not respect element ids that have been set manually on the\ncontrol element through the `aria-describedby` attribute. To ensure that your control does not\naccidentally override existing element ids specified by consumers of your control, create an\ninput called `userAriaDescribedby` like followed:\n\n```ts\n@Input('aria-describedby') userAriaDescribedBy: string;\n\n```\n\nThe form field will then pick up the user specified `aria-describedby` ids and merge\nthem with ids for hints or errors whenever `setDescribedByIds` is invoked.\n\n```ts\nsetDescribedByIds(ids: string[]) {\n  const controlElement = this._elementRef.nativeElement\n    .querySelector('.example-tel-input-container')!;\n  controlElement.setAttribute('aria-describedby', ids.join(' '));\n}\n\n```\n\n#### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#oncontainerclickevent-mouseevent) `onContainerClick(event: MouseEvent)`\n\nThis method will be called when the form field is clicked on. It allows your component to hook in\nand handle that click however it wants. The method has one parameter, the `MouseEvent` for the\nclick. In our case we'll just focus the first `<input>` if the user isn't about to click an\n`<input>` anyways.\n\n```ts\nonContainerClick(event: MouseEvent) {\n  if ((event.target as Element).tagName.toLowerCase() != 'input') {\n    this._elementRef.nativeElement.querySelector('input').focus();\n  }\n}\n\n```\n\n### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#improving-accessibility)  Improving accessibility\n\nOur custom form field control consists of multiple inputs that describe segments of a phone\nnumber. For accessibility purposes, we put those inputs as part of a `div` element with\n`role=\"group\"`. This ensures that screen reader users can tell that all those inputs belong\ntogether.\n\nOne significant piece of information is missing for screen reader users though. They won't be able\nto tell what this input group represents. To improve this, we should add a label for the group\nelement using either `aria-label` or `aria-labelledby`.\n\nIt's recommended to link the group to the label that is displayed as part of the parent\n`<mat-form-field>`. This ensures that explicitly specified labels (using `<mat-label>`) are\nactually used for labelling the control.\n\nIn our concrete example, we add an attribute binding for `aria-labelledby` and bind it\nto the label element id provided by the parent `<mat-form-field>`.\n\n```typescript\nexport class MyTelInput implements MatFormFieldControl<MyTel> {\n  ...\n\n  constructor(...\n              @Optional() public parentFormField: MatFormField) {\n\n```\n\n```html\n@Component({\n  selector: 'example-tel-input',\n  template: `\n    <div role=\"group\" [formGroup]=\"parts\"\n         [attr.aria-describedby]=\"describedBy\"\n         [attr.aria-labelledby]=\"parentFormField?.getLabelId()\">\n\n```\n\n### [link](https://material.angular.io/guide/creating-a-custom-form-field-control\\#trying-it-out)  Trying it out\n\nNow that we've fully implemented the interface, we're ready to try our component out! All we need to\ndo is place it inside a `<mat-form-field>`\n\n```html\n<mat-form-field>\n  <example-tel-input></example-tel-input>\n</mat-form-field>\n\n```\n\nWe also get all the features that come with `<mat-form-field>` such as floating placeholder,\nprefix, suffix, hints, and errors (if we've given the form field an `NgControl` and correctly report\nthe error state).\n\n```html\n<mat-form-field>\n  <example-tel-input placeholder=\"Phone number\" required></example-tel-input>\n  <mat-icon matPrefix>phone</mat-icon>\n  <mat-hint>Include area code</mat-hint>\n</mat-form-field>\n\n```\n\nGuide Content\n\nAzure & Blue theme selected.\n\nSelect a version of the documentation\n\nSelect a theme for the documentation\n\nEdit Form field with custom telephone number input control. example in StackBlitz\n\nCopy link to example\n\nView code",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-3fe562f5-e66e-486a-ac12-75c71f953ea9.png"
  },
  "metadata": {
    "ogDescription": "UI component infrastructure and Material Design components for Angular web applications.",
    "ogSiteName": "Angular Material",
    "twitter:description": "UI component infrastructure and Material Design components for Angular web applications.",
    "og:image": "https://material.angular.io/assets/img/site-preview.png",
    "apple-mobile-web-app-status-bar-style": "translucent",
    "author": "Angular Components Team",
    "og:image:width": "1339",
    "twitter:card": "summary",
    "twitter:site": "@Angular",
    "theme-color": "#d7e3ff",
    "og:image:secure_url": "https://material.angular.io/assets/img/site-preview.png",
    "og:site_name": "Angular Material",
    "og:image:height": "943",
    "ogUrl": "https://material.angular.io/",
    "apple-mobile-web-app-capable": "yes",
    "og:image:type": "image/png",
    "title": "Custom form field control | Angular Material",
    "og:type": "website",
    "keywords": "angular, material design, material, angular material, web, ui, components, responsive, accessibility, typescript, css, mobile web, open source",
    "twitter:creator": "@Angular",
    "twitter:image": "https://material.angular.io/assets/img/site-preview.png",
    "mobile-web-app-capable": "yes",
    "viewport": "width=device-width, initial-scale=1",
    "og:locale": "en_US",
    "og:url": "https://material.angular.io/",
    "language": "en-US",
    "ogImage": "https://material.angular.io/assets/img/site-preview.png",
    "twitter:title": "Angular Material",
    "ogLocale": "en_US",
    "og:description": "UI component infrastructure and Material Design components for Angular web applications.",
    "description": "UI component infrastructure and Material Design components for mobile and desktop Angular web applications.",
    "favicon": "https://material.angular.io/guide/assets/img/favicon.ico?v=19.1.0",
    "og:title": "Angular Material",
    "ogTitle": "Angular Material",
    "scrapeId": "dbb2aff8-9225-435f-b05d-8620c8f6e705",
    "sourceURL": "https://material.angular.io/guide/creating-a-custom-form-field-control",
    "url": "https://material.angular.io/guide/creating-a-custom-form-field-control",
    "statusCode": 200
  }
}