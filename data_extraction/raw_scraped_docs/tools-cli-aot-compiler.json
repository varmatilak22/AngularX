{
  "scrapeId": "98778e41-c3cc-46ae-a80b-1b9c61175bdf",
  "sourceURL": "https://angular.dev/tools/cli/aot-compiler",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backAngular CLI\n  - [Overview](https://angular.dev/tools/cli)\n  - [Local set-up](https://angular.dev/tools/cli/setup-local)\n  - [Building Angular apps](https://angular.dev/tools/cli/build)\n  - [Serving Angular apps for development](https://angular.dev/tools/cli/serve)\n  - [Deployment](https://angular.dev/tools/cli/deployment)\n  - [End-to-End Testing](https://angular.dev/tools/cli/end-to-end)\n  - [Migrating to new build system](https://angular.dev/tools/cli/build-system-migration)\n  - [Build environments](https://angular.dev/tools/cli/environments)\n  - [Angular CLI builders](https://angular.dev/tools/cli/cli-builder)\n  - [Generating code using schematics](https://angular.dev/tools/cli/schematics)\n  - [Authoring schematics](https://angular.dev/tools/cli/schematics-authoring)\n  - [Schematics for libraries](https://angular.dev/tools/cli/schematics-for-libraries)\n  - [Template type checking](https://angular.dev/tools/cli/template-typecheck)\n  - [Ahead-of-time (AOT) compilation](https://angular.dev/tools/cli/aot-compiler)\n  - [AOT metadata errors](https://angular.dev/tools/cli/aot-metadata-errors)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nAn Angular application consists mainly of components and their HTML templates.\nBecause the components and templates provided by Angular cannot be understood by the browser directly, Angular applications require a compilation process before they can run in a browser.\n\nThe Angular ahead-of-time (AOT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase _before_ the browser downloads and runs that code.\nCompiling your application during the build process provides a faster rendering in the browser.\n\nThis guide explains how to specify metadata and apply available compiler options to compile your applications efficiently using the AOT compiler.\n\n**HELPFUL:** [Watch Alex Rickabaugh explain the Angular compiler](https://www.youtube.com/watch?v=anphffaCZrQ) at AngularConnect 2019.\n\nHere are some reasons you might want to use AOT.\n\n| Reasons | Details |\n| :-- | :-- |\n| Faster rendering | With AOT, the browser downloads a pre-compiled version of the application. The browser loads executable code so it can render the application immediately, without waiting to compile the application first. |\n| Fewer asynchronous requests | The compiler _inlines_ external HTML templates and CSS style sheets within the application JavaScript, eliminating separate ajax requests for those source files. |\n| Smaller Angular framework download size | There's no need to download the Angular compiler if the application is already compiled. The compiler is roughly half of Angular itself, so omitting it dramatically reduces the application payload. |\n| Detect template errors earlier | The AOT compiler detects and reports template binding errors during the build step before users can see them. |\n| Better security | AOT compiles HTML templates and components into JavaScript files long before they are served to the client. With no templates to read and no risky client-side HTML or JavaScript evaluation, there are fewer opportunities for injection attacks. |\n\n## [Choosing a compiler](https://angular.dev/tools/cli/aot-compiler\\#choosing-a-compiler)\n\nAngular offers two ways to compile your application:\n\n| Angular compile | Details |\n| :-- | :-- |\n| Just-in-Time (JIT) | Compiles your application in the browser at runtime. This was the default until Angular 8. |\n| Ahead-of-Time (AOT) | Compiles your application and libraries at build time. This is the default starting in Angular 9. |\n\nWhen you run the [`ng build`](https://angular.dev/tools/cli/cli/build) (build only) or [`ng serve`](https://angular.dev/tools/cli/cli/serve) (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the `aot` property in your build configuration specified in `angular.json`.\nBy default, `aot` is set to `true` for new CLI applications.\n\nSee the [CLI command reference](https://angular.dev/tools/cli/cli) and [Building and serving Angular apps](https://angular.dev/tools/cli/tools/cli/build) for more information.\n\n## [How AOT works](https://angular.dev/tools/cli/aot-compiler\\#how-aot-works)\n\nThe Angular AOT compiler extracts **metadata** to interpret the parts of the application that Angular is supposed to manage.\nYou can specify the metadata explicitly in **decorators** such as `@Component()` and `@Input()`, or implicitly in the constructor declarations of the decorated classes.\nThe metadata tells Angular how to construct instances of your application classes and interact with them at runtime.\n\nIn the following example, the `@Component()` metadata object and the class constructor tell Angular how to create and display an instance of `TypicalComponent`.\n\n```\n      @Component({  selector: 'app-typical',  template: '<div>A typical component for {{data.name}}</div>'})export class TypicalComponent {  @Input() data: TypicalData;  private someService = inject(SomeService);}\n\n```\n\ncheck\n\nThe Angular compiler extracts the metadata _once_ and generates a _factory_ for `TypicalComponent`.\nWhen it needs to create a `TypicalComponent` instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.\n\n### [Compilation phases](https://angular.dev/tools/cli/aot-compiler\\#compilation-phases)\n\nThere are three phases of AOT compilation.\n\n|  | Phase | Details |\n| :-- | :-- | :-- |\n| 1 | code analysis | In this phase, the TypeScript compiler and _AOT collector_ create a representation of the source. The collector does not attempt to interpret the metadata it collects. It represents the metadata as best it can and records errors when it detects a metadata syntax violation. |\n| 2 | code generation | In this phase, the compiler's `StaticReflector` interprets the metadata collected in phase 1, performs additional validation of the metadata, and throws an error if it detects a metadata restriction violation. |\n| 3 | template type checking | In this optional phase, the Angular _template compiler_ uses the TypeScript compiler to validate the binding expressions in templates. You can enable this phase explicitly by setting the `strictTemplates` configuration option; see [Angular compiler options](https://angular.dev/tools/cli/reference/configs/angular-compiler-options). |\n\n### [Metadata restrictions](https://angular.dev/tools/cli/aot-compiler\\#metadata-restrictions)\n\nYou write metadata in a _subset_ of TypeScript that must conform to the following general constraints:\n\n- Limit [expression syntax](https://angular.dev/tools/cli/aot-compiler#expression-syntax-limitations) to the supported subset of JavaScript\n- Only reference exported symbols after [code folding](https://angular.dev/tools/cli/aot-compiler#code-folding)\n- Only call [functions supported](https://angular.dev/tools/cli/aot-compiler#supported-classes-and-functions) by the compiler\n- Input/Outputs and data-bound class members must be public or protected.For additional guidelines and instructions on preparing an application for AOT compilation, see [Angular: Writing AOT-friendly applications](https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f).\n\n**HELPFUL:** Errors in AOT compilation commonly occur because of metadata that does not conform to the compiler's requirements (as described more fully below).\nFor help in understanding and resolving these problems, see [AOT Metadata Errors](https://angular.dev/tools/cli/tools/cli/aot-metadata-errors).\n\n### [Configuring AOT compilation](https://angular.dev/tools/cli/aot-compiler\\#configuring-aot-compilation)\n\nYou can provide options in the [TypeScript configuration file](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) that controls the compilation process.\nSee [Angular compiler options](https://angular.dev/tools/cli/reference/configs/angular-compiler-options) for a complete list of available options.\n\n## [Phase 1: Code analysis](https://angular.dev/tools/cli/aot-compiler\\#phase-1-code-analysis)\n\nThe TypeScript compiler does some of the analytic work of the first phase.\nIt emits the `.d.ts` _type definition files_ with type information that the AOT compiler needs to generate application code.\nAt the same time, the AOT **collector** analyzes the metadata recorded in the Angular decorators and outputs metadata information in **`.metadata.json`** files, one per `.d.ts` file.\n\nYou can think of `.metadata.json` as a diagram of the overall structure of a decorator's metadata, represented as an [abstract syntax tree (AST)](https://en.wikipedia.org/wiki/Abstract_syntax_tree).\n\n**HELPFUL:** Angular's [schema.ts](https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts) describes the JSON format as a collection of TypeScript interfaces.\n\n### [Expression syntax limitations](https://angular.dev/tools/cli/aot-compiler\\#expression-syntax-limitations)\n\nThe AOT collector only understands a subset of JavaScript.\nDefine metadata objects with the following limited syntax:\n\n| Syntax | Example |\n| :-- | :-- |\n| Literal object | `{cherry: true, apple: true, mincemeat: false}` |\n| Literal array | `['cherries', 'flour', 'sugar']` |\n| Spread in literal array | `['apples', 'flour', â€¦]` |\n| Calls | `bake(ingredients)` |\n| New | `new Oven()` |\n| Property access | `pie.slice` |\n| Array index | `ingredients[0]` |\n| Identity reference | `Component` |\n| A template string | `pie is ${multiplier} times better than cake` |\n| Literal string | `'pi'` |\n| Literal number | `3.14153265` |\n| Literal boolean | `true` |\n| Literal null | `null` |\n| Supported prefix operator | `!cake` |\n| Supported binary operator | `a+b` |\n| Conditional operator | `a ? b : c` |\n| Parentheses | `(a+b)` |\n\nIf an expression uses unsupported syntax, the collector writes an error node to the `.metadata.json` file.\nThe compiler later reports the error if it needs that piece of metadata to generate the application code.\n\n**HELPFUL:** If you want `ngc` to report syntax errors immediately rather than produce a `.metadata.json` file with errors, set the `strictMetadataEmit` option in the TypeScript configuration file.\n\n```\n      \"angularCompilerOptions\": {  â€¦  \"strictMetadataEmit\" : true}\n\n```\n\ncheck\n\nAngular libraries have this option to ensure that all Angular `.metadata.json` files are clean and it is a best practice to do the same when building your own libraries.\n\n### [No arrow functions](https://angular.dev/tools/cli/aot-compiler\\#no-arrow-functions)\n\nThe AOT compiler does not support [function expressions](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function)\nand [arrow functions](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions), also called _lambda_ functions.\n\nConsider the following component decorator:\n\n```\n      @Component({  â€¦  providers: [{provide: server, useFactory: () => new Server()}]})\n\n```\n\ncheck\n\nThe AOT collector does not support the arrow function, `() => new Server()`, in a metadata expression.\nIt generates an error node in place of the function.\nWhen the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an _exported function_.\n\nYou can fix the error by converting to this:\n\n```\n      export function serverFactory() {  return new Server();}@Component({  â€¦  providers: [{provide: server, useFactory: serverFactory}]})\n\n```\n\ncheck\n\nIn version 5 and later, the compiler automatically performs this rewriting while emitting the `.js` file.\n\n### [Code folding](https://angular.dev/tools/cli/aot-compiler\\#code-folding)\n\nThe compiler can only resolve references to _**exported**_ symbols.\nThe collector, however, can evaluate an expression during collection and record the result in the `.metadata.json`, rather than the original expression.\nThis allows you to make limited use of non-exported symbols within expressions.\n\nFor example, the collector can evaluate the expression `1 + 2 + 3 + 4` and replace it with the result, `10`.\nThis process is called _folding_.\nAn expression that can be reduced in this manner is _foldable_.\n\nThe collector can evaluate references to module-local `const` declarations and initialized `var` and `let` declarations, effectively removing them from the `.metadata.json` file.\n\nConsider the following component definition:\n\n```\n      const template = '<div>{{hero.name}}</div>';@Component({  selector: 'app-hero',  template: template})export class HeroComponent {  @Input() hero: Hero;}\n\n```\n\ncheck\n\nThe compiler could not refer to the `template` constant because it isn't exported.\nThe collector, however, can fold the `template` constant into the metadata definition by in-lining its contents.\nThe effect is the same as if you had written:\n\n```\n      @Component({  selector: 'app-hero',  template: '<div>{{hero.name}}</div>'})export class HeroComponent {  @Input() hero: Hero;}\n\n```\n\ncheck\n\nThere is no longer a reference to `template` and, therefore, nothing to trouble the compiler when it later interprets the _collector's_ output in `.metadata.json`.\n\nYou can take this example a step further by including the `template` constant in another expression:\n\n```\n      const template = '<div>{{hero.name}}</div>';@Component({  selector: 'app-hero',  template: template + '<div>{{hero.title}}</div>'})export class HeroComponent {  @Input() hero: Hero;}\n\n```\n\ncheck\n\nThe collector reduces this expression to its equivalent _folded_ string:\n\n```\n      '<div>{{hero.name}}</div><div>{{hero.title}}</div>'\n\n```\n\ncheck\n\n#### [Foldable syntax](https://angular.dev/tools/cli/aot-compiler\\#foldable-syntax)\n\nThe following table describes which expressions the collector can and cannot fold:\n\n| Syntax | Foldable |\n| :-- | :-- |\n| Literal object | yes |\n| Literal array | yes |\n| Spread in literal array | no |\n| Calls | no |\n| New | no |\n| Property access | yes, if target is foldable |\n| Array index | yes, if target and index are foldable |\n| Identity reference | yes, if it is a reference to a local |\n| A template with no substitutions | yes |\n| A template with substitutions | yes, if the substitutions are foldable |\n| Literal string | yes |\n| Literal number | yes |\n| Literal boolean | yes |\n| Literal null | yes |\n| Supported prefix operator | yes, if operand is foldable |\n| Supported binary operator | yes, if both left and right are foldable |\n| Conditional operator | yes, if condition is foldable |\n| Parentheses | yes, if the expression is foldable |\n\nIf an expression is not foldable, the collector writes it to `.metadata.json` as an [AST](https://en.wikipedia.org/wiki/Abstract*syntax*tree) for the compiler to resolve.\n\n## [Phase 2: code generation](https://angular.dev/tools/cli/aot-compiler\\#phase-2-code-generation)\n\nThe collector makes no attempt to understand the metadata that it collects and outputs to `.metadata.json`.\nIt represents the metadata as best it can and records errors when it detects a metadata syntax violation.\nIt's the compiler's job to interpret the `.metadata.json` in the code generation phase.\n\nThe compiler understands all syntax forms that the collector supports, but it may reject _syntactically_ correct metadata if the _semantics_ violate compiler rules.\n\n### [Public or protected symbols](https://angular.dev/tools/cli/aot-compiler\\#public-or-protected-symbols)\n\nThe compiler can only reference _exported symbols_.\n\n- Decorated component class members must be public or protected.\nYou cannot make an `@Input()` property private.\n\n- Data bound properties must also be public or protected\n\n\n### [Supported classes and functions](https://angular.dev/tools/cli/aot-compiler\\#supported-classes-and-functions)\n\nThe collector can represent a function call or object creation with `new` as long as the syntax is valid.\nThe compiler, however, can later refuse to generate a call to a _particular_ function or creation of a _particular_ object.\n\nThe compiler can only create instances of certain classes, supports only core decorators, and only supports calls to macros (functions or static methods) that return expressions.\n\n| Compiler action | Details |\n| :-- | :-- |\n| New instances | The compiler only allows metadata that create instances of the class `InjectionToken` from `@angular/core`. |\n| Supported decorators | The compiler only supports metadata for the [Angular decorators in the `@angular/core` module](https://angular.dev/tools/cli/api/core#decorators). |\n| Function calls | Factory functions must be exported, named functions. The AOT compiler does not support lambda expressions (\"arrow functions\") for factory functions. |\n\n### [Functions and static method calls](https://angular.dev/tools/cli/aot-compiler\\#functions-and-static-method-calls)\n\nThe collector accepts any function or static method that contains a single `return` statement.\nThe compiler, however, only supports macros in the form of functions or static methods that return an _expression_.\n\nFor example, consider the following function:\n\n```\n      export function wrapInArray<T>(value: T): T[] {  return [value];}\n\n```\n\ncheck\n\nYou can call the `wrapInArray` in a metadata definition because it returns the value of an expression that conforms to the compiler's restrictive JavaScript subset.\n\nYou might use `wrapInArray()` like this:\n\n```\n      @NgModule({  declarations: wrapInArray(TypicalComponent)})export class TypicalModule {}\n\n```\n\ncheck\n\nThe compiler treats this usage as if you had written:\n\n```\n      @NgModule({  declarations: [TypicalComponent]})export class TypicalModule {}\n\n```\n\ncheck\n\nThe Angular [`RouterModule`](https://angular.dev/tools/cli/api/router/RouterModule) exports two macro static methods, `forRoot` and `forChild`, to help declare root and child routes.\nReview the [source code](https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139 \"RouterModule.forRoot\")\nfor these methods to see how macros can simplify configuration of complex [NgModules](https://angular.dev/tools/cli/guide/ngmodules).\n\n### [Metadata rewriting](https://angular.dev/tools/cli/aot-compiler\\#metadata-rewriting)\n\nThe compiler treats object literals containing the fields `useClass`, `useValue`, `useFactory`, and `data` specially, converting the expression initializing one of these fields into an exported variable that replaces the expression.\nThis process of rewriting these expressions removes all the restrictions on what can be in them because\nthe compiler doesn't need to know the expression's value â€” it just needs to be able to generate a reference to the value.\n\nYou might write something like:\n\n```\n      class TypicalServer {}@NgModule({  providers: [{provide: SERVER, useFactory: () => TypicalServer}]})export class TypicalModule {}\n\n```\n\ncheck\n\nWithout rewriting, this would be invalid because lambdas are not supported and `TypicalServer` is not exported.\nTo allow this, the compiler automatically rewrites this to something like:\n\n```\n      class TypicalServer {}export const Î¸0 = () => new TypicalServer();@NgModule({  providers: [{provide: SERVER, useFactory: Î¸0}]})export class TypicalModule {}\n\n```\n\ncheck\n\nThis allows the compiler to generate a reference to `Î¸0` in the factory without having to know what the value of `Î¸0` contains.\n\nThe compiler does the rewriting during the emit of the `.js` file.\nIt does not, however, rewrite the `.d.ts` file, so TypeScript doesn't recognize it as being an export.\nAnd it does not interfere with the ES module's exported API.\n\n## [Phase 3: Template type checking](https://angular.dev/tools/cli/aot-compiler\\#phase-3-template-type-checking)\n\nOne of the Angular compiler's most helpful features is the ability to type-check expressions within templates, and catch any errors before they cause crashes at runtime.\nIn the template type-checking phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.\n\nEnable this phase explicitly by adding the compiler option `\"fullTemplateTypeCheck\"` in the `\"angularCompilerOptions\"` of the project's TypeScript configuration file\n(see [Angular Compiler Options](https://angular.dev/tools/cli/reference/configs/angular-compiler-options)).\n\nTemplate validation produces error messages when a type error is detected in a template binding\nexpression, similar to how type errors are reported by the TypeScript compiler against code in a `.ts`\nfile.\n\nFor example, consider the following component:\n\n```\n      @Component({  selector: 'my-component',  template: '{{person.addresss.street}}'})class MyComponent {  person?: Person;}\n\n```\n\ncheck\n\nThis produces the following error:\n\n```\n      my.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n\n```\n\ncheck\n\nThe file name reported in the error message, `my.component.ts.MyComponent.html`, is a synthetic file\ngenerated by the template compiler that holds contents of the `MyComponent` class template.\nThe compiler never writes this file to disk.\nThe line and column numbers are relative to the template string in the `@Component` annotation of the class, `MyComponent` in this case.\nIf a component uses `templateUrl` instead of `template`, the errors are reported in the HTML file referenced by the `templateUrl` instead of a synthetic file.\n\nThe error location is the beginning of the text node that contains the interpolation expression with the error.\nIf the error is in an attribute binding such as `[value]=\"person.address.street\"`, the error\nlocation is the location of the attribute that contains the error.\n\nThe validation uses the TypeScript type checker and the options supplied to the TypeScript compiler to control how detailed the type validation is.\nFor example, if the `strictTypeChecks` is specified, the error\n\n```\n      my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'\n\n```\n\ncheck\n\nis reported as well as the above error message.\n\n### [Type narrowing](https://angular.dev/tools/cli/aot-compiler\\#type-narrowing)\n\nThe expression used in an `ngIf` directive is used to narrow type unions in the Angular\ntemplate compiler, the same way the `if` expression does in TypeScript.\nFor example, to avoid `Object is possibly 'undefined'` error in the template above, modify it to only emit the interpolation if the value of `person` is initialized as shown below:\n\n```\n      @Component({  selector: 'my-component',  template: '<span *ngIf=\"person\"> {{person.address.street}} </span>'})class MyComponent {  person?: Person;}\n\n```\n\ncheck\n\nUsing `*ngIf` allows the TypeScript compiler to infer that the `person` used in the binding expression will never be `undefined`.\n\nFor more information about input type narrowing, see [Improving template type checking for custom directives](https://angular.dev/tools/cli/guide/directives/structural-directives#directive-type-checks).\n\n### [Non-null type assertion operator](https://angular.dev/tools/cli/aot-compiler\\#non-null-type-assertion-operator)\n\nUse the non-null type assertion operator to suppress the `Object is possibly 'undefined'` error when it is inconvenient to use `*ngIf` or when some constraint in the component ensures that the expression is always non-null when the binding expression is interpolated.\n\nIn the following example, the `person` and `address` properties are always set together, implying that `address` is always non-null if `person` is non-null.\nThere is no convenient way to describe this constraint to TypeScript and the template compiler, but the error is suppressed in the example by using `address!.street`.\n\n```\n      @Component({  selector: 'my-component',  template: '<span *ngIf=\"person\"> {{person.name}} lives on {{address!.street}} </span>'})class MyComponent {  person?: Person;  address?: Address;  setData(person: Person, address: Address) {    this.person = person;    this.address = address;  }}\n\n```\n\ncheck\n\nThe non-null assertion operator should be used sparingly as refactoring of the component might break this constraint.\n\nIn this example it is recommended to include the checking of `address` in the `*ngIf` as shown below:\n\n```\n      @Component({  selector: 'my-component',  template: '<span *ngIf=\"person && address\"> {{person.name}} lives on {{address.street}} </span>'})class MyComponent {  person?: Person;  address?: Address;  setData(person: Person, address: Address) {    this.person = person;    this.address = address;  }}\n\n```\n\ncheck",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-b8ab01b5-85fd-4599-b178-47b98d4b5dbf.png"
  },
  "metadata": {
    "ogTitle": "Angular",
    "application-name": "Angular",
    "theme-color": "#ffffff",
    "msapplication-TileColor": "#e90464",
    "og:url": "https://angular.dev/",
    "viewport": "width=device-width, initial-scale=1",
    "title": "Ahead-of-time (AOT) compilation â€¢ Angular",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "description": "The web development framework for building modern apps.",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:description": "The web development framework for building modern apps.",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "ogUrl": "https://angular.dev/",
    "ogDescription": "The web development framework for building modern apps.",
    "og:type": "website",
    "og:description": "The web development framework for building modern apps.",
    "twitter:url": "https://angular.dev/",
    "twitter:card": "summary_large_image",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "og:title": "Angular",
    "twitter:title": "Angular",
    "language": "en",
    "apple-mobile-web-app-title": "Angular",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "scrapeId": "98778e41-c3cc-46ae-a80b-1b9c61175bdf",
    "sourceURL": "https://angular.dev/tools/cli/aot-compiler",
    "url": "https://angular.dev/tools/cli/aot-compiler",
    "statusCode": 200
  }
}