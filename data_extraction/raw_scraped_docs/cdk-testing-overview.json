{
  "scrapeId": "ffea313b-8249-4cc0-ba2e-027d971169fb",
  "sourceURL": "https://material.angular.io/cdk/testing/overview",
  "statusCode": 200,
  "data": {
    "markdown": "[Accessibility](https://material.angular.io/cdk/a11y) [Accordion](https://material.angular.io/cdk/accordion) [Bidirectionality](https://material.angular.io/cdk/bidi) [Clipboard](https://material.angular.io/cdk/clipboard) [Coercion](https://material.angular.io/cdk/coercion) [Collections](https://material.angular.io/cdk/collections) [Component Harnesses](https://material.angular.io/cdk/testing) [Dialog](https://material.angular.io/cdk/dialog) [Drag and Drop](https://material.angular.io/cdk/drag-drop) [Layout](https://material.angular.io/cdk/layout) [Listbox](https://material.angular.io/cdk/listbox) [Menu](https://material.angular.io/cdk/menu) [Observers](https://material.angular.io/cdk/observers) [Overlay](https://material.angular.io/cdk/overlay) [Platform](https://material.angular.io/cdk/platform) [Portal](https://material.angular.io/cdk/portal) [Scrolling](https://material.angular.io/cdk/scrolling) [Stepper](https://material.angular.io/cdk/stepper) [Table](https://material.angular.io/cdk/table) [Text field](https://material.angular.io/cdk/text-field) [Tree](https://material.angular.io/cdk/tree)\n\n## Overview for testing\n\n`@angular/cdk/testing` provides infrastructure to help with testing Angular components.\n\n### [link](https://material.angular.io/cdk/testing/overview\\#component-test-harnesses)  Component test harnesses\n\nA component harness is a class that lets a test interact with a component via a supported API.\nEach harness's API interacts with a component the same way a user would. By using the harness API,\na test insulates itself against updates to the internals of a component, such as changing its DOM\nstructure. The idea for component harnesses comes from the\n[PageObject](https://martinfowler.com/bliki/PageObject.html) pattern commonly used for integration\ntesting.\n\n`@angular/cdk/testing` contains infrastructure for creating and using component test harnesses. You\ncan create test harnesses for any component, ranging from small reusable widgets to full application\npages.\n\nThe component harness system supports multiple testing environments. You can use the same harness\nimplementation in both unit and end-to-end tests. This means that users only need to learn one API,\nand component authors don't have to maintain separate unit and end-to-end test implementations.\n\nCommon component libraries, in particular, benefit from this infrastructure due to the wide use of\ntheir components. Providing a test harness allows the consumers of a component to write tests that\navoid dependencies on any private implementation details. By capturing these implementation details\nin a single place, consumers can more easily update to new library versions.\n\nThis document provides guidance for three types of developers:\n\n1. [Test authors](https://material.angular.io/cdk/testing/overview#api-for-test-authors)\n2. [Component harness authors](https://material.angular.io/cdk/testing/overview#api-for-component-harness-authors)\n3. [Harness environment authors](https://material.angular.io/cdk/testing/overview#api-for-harness-environment-authors)\n\nSince many developers fall into only one of these categories, the relevant APIs are broken out by\ndeveloper type in the sections below.\n\n### [link](https://material.angular.io/cdk/testing/overview\\#api-for-test-authors)  API for test authors\n\nTest authors are developers using component harnesses written by someone else to test their\napplication. For example, this could be an app developer who uses a third-party menu component and\nneeds to interact with the menu in a unit test.\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#working-with-componentharness-classes)  Working with `ComponentHarness` classes\n\n`ComponentHarness` is the abstract base class for all component harnesses. Every harness extends\nthis class. All `ComponentHarness` subclasses have a static property, `hostSelector`, that\nmatches the harness class to instances of the component in the DOM. Beyond that, the API of any\ngiven harness is specific to its corresponding component; refer to the component's documentation to\nlearn how to use a specific harness.\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#using-testbedharnessenvironment-and-seleniumwebdriverharnessenvironment)  Using `TestbedHarnessEnvironment` and `SeleniumWebDriverHarnessEnvironment`\n\nThese classes correspond to different implementations of the component harness system with bindings\nfor specific test environments. Any given test must only import _one_ of these classes. Karma-based\nunit tests should use the `TestbedHarnessEnvironment`, while Selenium WebDriver-based end-to-end tests\nshould use the `SeleniumWebDriverHarnessEnvironment`. Additional environments require custom bindings; see\n[API for harness environment authors](https://material.angular.io/cdk/testing/overview#api-for-harness-environment-authors) for more information on\nalternate test environments.\n\nThese classes are primarily used to create a `HarnessLoader` instance, and in certain cases, to\ncreate `ComponentHarness` instances directly.\n\n`TestbedHarnessEnvironment` offers the following static methods:\n\n| Method | Description |\n| --- | --- |\n| `loader(fixture: ComponentFixture<unknown>): HarnessLoader` | Gets a `HarnessLoader` instance for the given fixture, rooted at the fixture's root element. Should be used to create harnesses for elements contained inside the fixture |\n| `documentRootLoader(fixture: ComponentFixture<unknown>): HarnessLoader` | Gets a `HarnessLoader` instance for the given fixture, rooted at the HTML document's root element. Can be used to create harnesses for elements that fall outside of the fixture |\n| `harnessForFixture<T extends ComponentHarness>(fixture: ComponentFixture<unknown>, harnessType: ComponentHarnessConstructor<T>): Promise<T>` | Used to create a `ComponentHarness` instance for the fixture's root element directly. This is necessary when bootstrapping the test with the component you plan to load a harness for, because Angular does not set the proper tag name when creating the fixture. |\n\nIn most cases, you can create a `HarnessLoader` in the `beforeEach` block using\n`TestbedHarnessEnvironment.loader(fixture)` and then use that `HarnessLoader` to create any\nnecessary `ComponentHarness` instances. The other methods cover special cases as shown in this\nexample:\n\nConsider a reusable dialog-button component that opens a dialog on click, containing the following\ncomponents, each with a corresponding harness:\n\n- `MyDialogButton` (composes the `MyButton` and `MyDialog` with a convenient API)\n- `MyButton` (a simple button component)\n- `MyDialog` (a dialog appended to `document.body` by `MyDialogButton` upon click)\n\nThe following code loads harnesses for each of these components:\n\n```ts\nlet fixture: ComponentFixture<MyDialogButton>;\nlet loader: HarnessLoader;\nlet rootLoader: HarnessLoader;\n\nbeforeEach(() => {\n  fixture = TestBed.createComponent(MyDialogButton);\n  loader = TestbedHarnessEnvironment.loader(fixture);\n  rootLoader = TestbedHarnessEnvironment.documentRootLoader(fixture);\n});\n\nit('loads harnesses', async () => {\n  // Load a harness for the bootstrapped component with `harnessForFixture`\n  dialogButtonHarness =\n      await TestbedHarnessEnvironment.harnessForFixture(fixture, MyDialogButtonHarness);\n\n  // The button element is inside the fixture's root element, so we use `loader`.\n  const buttonHarness = await loader.getHarness(MyButtonHarness);\n\n  // Click the button to open the dialog\n  await buttonHarness.click();\n\n  // The dialog is appended to `document.body`, outside of the fixture's root element,\n  // so we use `rootLoader` in this case.\n  const dialogHarness = await rootLoader.getHarness(MyDialogHarness);\n\n  // ... make some assertions\n});\n\n```\n\n`SeleniumWebDriverHarnessEnvironment` has an API that offers a single static method:\n\n| Method | Description |\n| --- | --- |\n| `loader(): HarnessLoader` | Gets a `HarnessLoader` instance for the current HTML document, rooted at the document's root element. |\n\nSince Selenium WebDriver does not deal with fixtures, the API in this environment is simpler. The\n`HarnessLoader` returned by the `loader()` method should be sufficient for loading all necessary\n`ComponentHarness` instances.\n\nPlease note that harnesses may not behave _exactly_ the same in all environments. There will always\nbe some difference between the real browser-generated event sequence when a user clicks or types in\nan element, versus the simulated event sequence generated in unit tests. Instead, the CDK makes a\nbest effort to normalize the behavior and simulate the most important events in the sequence.\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#creating-harnesses-with-harnessloader)  Creating harnesses with `HarnessLoader`\n\nInstances of this class correspond to a specific DOM element (the \"root element\" of the loader) and\nare used to create `ComponentHarness` instances for elements under this root element.\n\n`HarnessLoader` instances have the following methods:\n\n| Method | Description |\n| --- | --- |\n| `getChildLoader(selector: string): Promise<HarnessLoader>` | Searches for an element matching the given selector below the root element of this `HarnessLoader`, and returns a new `HarnessLoader` rooted at the first matching element |\n| `getAllChildLoaders(selector: string): Promise<HarnessLoader[]>` | Acts like `getChildLoader`, but returns an array of `HarnessLoader` instances, one for each matching element, rather than just the first matching element |\n| `getHarness<T extends ComponentHarness>(harnessType: ComponentHarnessConstructor<T> | HarnessPredicate<T>): Promise<T>` | Searches for an instance of the given `ComponentHarness` class or `HarnessPredicate` below the root element of this `HarnessLoader` and returns an instance of the harness corresponding to the first matching element |\n| `getAllHarnesses<T extends ComponentHarness>(harnessType: ComponentHarnessConstructor<T> | HarnessPredicate<T>): Promise<T[]>` | Acts like `getHarness`, but returns an array of harness instances, one for each matching element, rather than just the first matching element |\n\nCalls to `getHarness` and `getAllHarnesses` can either take `ComponentHarness` subclass or a\n`HarnessPredicate`. `HarnessPredicate` applies additional restrictions to the search (e.g. searching\nfor a button that has some particular text, etc). The\n[details of `HarnessPredicate`](https://material.angular.io/cdk/testing/overview#filtering-harness-instances-with-harnesspredicate) are discussed in\nthe [API for component harness authors](https://material.angular.io/cdk/testing/overview#api-for-component-harness-authors); harness authors should\nprovide convenience methods on their `ComponentHarness` subclass to facilitate the creation of\n`HarnessPredicate` instances. However, if the harness author's API is not sufficient, they can be\ncreated manually.\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#change-detection)  Change detection\n\nBy default, test harnesses will run Angular's change detection before reading the state of a DOM\nelement and after interacting with a DOM element. While convenient in most cases, there may be times\nthat you need finer-grained control over change detection. For example, you may want to check the\nstate of a component while an async operation is pending. In these cases you can use the\n`manualChangeDetection` function to disable automatic handling of change detection for a block of\ncode. For example:\n\n```ts\nit('checks state while async action is in progress', async () => {\n  const buttonHarness = loader.getHarness(MyButtonHarness);\n  await manualChangeDetection(async () => {\n    await buttonHarness.click();\n    fixture.detectChanges();\n    // Check expectations while async click operation is in progress.\n    expect(isProgressSpinnerVisible()).toBe(true);\n    await fixture.whenStable();\n    // Check expectations after async click operation complete.\n    expect(isProgressSpinnerVisible()).toBe(false);\n  });\n});\n\n```\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#working-with-asynchronous-component-harness-methods)  Working with asynchronous component harness methods\n\nTo support both unit and end-to-end tests, and to insulate tests against changes in\nasynchronous behavior, almost all harness methods are asynchronous and return a `Promise`;\ntherefore, the Angular team recommends using\n[ES2017 `async`/ `await` syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\nto improve the test readability.\n\nNote that `await` statements block the execution of your test until the associated `Promise`\nresolves. Occasionally, you may want to perform multiple actions simultaneously and wait until\nthey're all done rather than performing each action sequentially. For example, reading multiple\nproperties off a single component. In these situations use the `parallel` function to parallelize\nthe operations. The parallel function works similarly to `Promise.all`, while also optimizing change\ndetection, so it is not run an excessive number of times. The following code demonstrates how you\ncan read multiple properties from a harness with `parallel`:\n\n```ts\nit('reads properties in parallel', async () => {\n  const checkboxHarness = loader.getHarness(MyCheckboxHarness);\n  // Read the checked and intermediate properties simultaneously.\n  const [checked, indeterminate] = await parallel(() => [\\\n    checkboxHarness.isChecked(),\\\n    checkboxHarness.isIndeterminate()\\\n  ]);\n  expect(checked).toBe(false);\n  expect(indeterminate).toBe(true);\n});\n\n```\n\n### [link](https://material.angular.io/cdk/testing/overview\\#api-for-component-harness-authors)  API for component harness authors\n\nComponent harness authors are developers who maintain some reusable Angular component, and want to\ncreate a test harness for it, that users of the component can use in their tests. For example, this\ncould be an author of a third party Angular component library or a developer who maintains a set of\ncommon components for a large Angular application.\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#extending-componentharness)  Extending `ComponentHarness`\n\nThe abstract `ComponentHarness` class is the base class for all component harnesses. To create a\ncustom component harness, extend `ComponentHarness` and implement the static property\n`hostSelector`. The `hostSelector` property identifies elements in the DOM that match this harness\nsubclass. In most cases, the `hostSelector` should be the same as the `selector` of the corresponding\n`Component` or `Directive`. For example, consider a simple popup component:\n\n```ts\n@Component({\n  selector: 'my-popup',\n  template: `\n    <button (click)=\"toggle()\">{{triggerText}}</button>\n    <div *ngIf=\"open\" class=\"my-popup-content\"><ng-content></ng-content></div>\n  `\n})\nclass MyPopup {\n  @Input() triggerText: string;\n\n  open = false;\n\n  toggle() {\n    this.open = !this.open;\n  }\n}\n\n```\n\nIn this case, a minimal harness for the component would look like the following:\n\n```ts\nclass MyPopupHarness extends ComponentHarness {\n  static hostSelector = 'my-popup';\n}\n\n```\n\nWhile `ComponentHarness` subclasses require only the `hostSelector` property, most harnesses should\nalso implement a static `with` method to generate `HarnessPredicate` instances. The\n[`HarnessPredicate`](https://material.angular.io/cdk/testing/overview#filtering-harness-instances-with-harnesspredicate) section below covers this\nin more detail.\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#finding-elements-in-the-components-dom)  Finding elements in the component's DOM\n\nEach instance of a `ComponentHarness` subclass represents a particular instance of the\ncorresponding component. You can access the component's host element via the `host` method from\nthe `ComponentHarness` base class.\n\n`ComponentHarness` additionally offers several methods for locating elements within the component's\nDOM. These methods are `locatorFor`, `locatorForOptional`, and `locatorForAll`.\nNote, though, that these methods do not directly find elements. Instead, they _create functions_\nthat find elements. This approach safeguards against caching references to out-of-date elements. For\nexample, when an `ngIf` hides and then shows an element, the result is a new DOM element; using\nfunctions ensures that tests always reference the current state of the DOM.\n\n| Method | Description |\n| --- | --- |\n| `host(): Promise<TestElement>` | Returns a `Promise` for the host element of the corresponding component instance. |\n| `locatorFor(selector: string): () => Promise<TestElement>` | Creates a function that returns a `Promise` for the first element matching the given selector when called. If no matching element is found, the `Promise` rejects. |\n| `locatorForOptional(selector: string): () => Promise<TestElement | null>` | Creates a function that returns a `Promise` for the first element matching the given selector when called. If no matching element is found, the `Promise` is resolved with `null`. |\n| `locatorForAll(selector: string): () => Promise<TestElement[]>` | Creates a function that returns a `Promise` for a list of all elements matching the given selector when called. |\n\nFor example, the `MyPopupHarness` class discussed above could provide methods to get the trigger\nand content elements as follows:\n\n```ts\nclass MyPopupHarness extends ComponentHarness {\n  static hostSelector = 'my-popup';\n\n  /** Gets the trigger element */\n  getTriggerElement = this.locatorFor('button');\n\n  /** Gets the content element. */\n  getContentElement = this.locatorForOptional('.my-popup-content');\n}\n\n```\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#working-with-testelement-instances)  Working with `TestElement` instances\n\nThe functions created with the locator methods described above all return `TestElement` instances.\n`TestElement` offers a number of methods to interact with the underlying DOM:\n\n| Method | Description |\n| --- | --- |\n| `blur(): Promise<void>` | Blurs the element. |\n| `clear(): Promise<void>` | Clears the text in the element (intended for `<input>` and `<textarea>` only). |\n| `click(relativeX?: number, relativeY?: number): Promise<void>` | Clicks the element (at the given position relative to the element's top-left corner). |\n| `focus(): Promise<void>` | Focuses the element. |\n| `getCssValue(property: string): Promise<string>` | Gets the computed value of the given CSS property for the element. |\n| `hover(): Promise<void>` | Hovers over the element. |\n| `sendKeys(modifiers?: ModifierKeys, ...keys: (string | TestKey)[]): Promise<void>` | Sends the given list of key presses to the element (with optional modifier keys). |\n| `text(): Promise<string>` | Gets the text content of the element |\n| `getAttribute(name: string): Promise<string | null>` | Gets the value of the given HTML attribute for the element. |\n| `hasClass(name: string): Promise<boolean>` | Checks whether the element has the given class applied. |\n| `getDimensions(): Promise<ElementDimensions>` | Gets the dimensions of the element. |\n| `getProperty(name: string): Promise<any>` | Gets the value of the given JS property for the element. |\n| `matchesSelector(selector: string): Promise<boolean>` | Checks whether the element matches the given CSS selector. |\n| `setInputValue(value: string): Promise<void>;` | Sets the value of a property of an input. |\n| `selectOptions(...optionIndexes: number[]): Promise<void>;` | Selects the options at the specified indexes inside of a native `select` element. |\n| `dispatchEvent(name: string, data?: Record<string, EventData>): Promise<void>;` | Dispatches an event with a particular name. |\n\n`TestElement` is an abstraction designed to work across different test environments (Karma,\nSelenium WebDriver, etc). When using harnesses, you should perform all DOM interaction via this interface.\nOther means of accessing DOM elements (e.g. `document.querySelector`) will not work in all test\nenvironments.\n\nAs a best practice, you should not expose `TestElement` instances to users of a harness\nunless its an element the component consumer defines directly (e.g. the host element). Exposing\n`TestElement` instances for internal elements leads users to depend on a component's internal DOM\nstructure.\n\nInstead, provide more narrow-focused methods for particular actions the end-user will\ntake or particular state they may want to check. For example, `MyPopupHarness` could provide methods\nlike `toggle` and `isOpen`:\n\n```ts\nclass MyPopupHarness extends ComponentHarness {\n  static hostSelector = 'my-popup';\n\n  protected getTriggerElement = this.locatorFor('button');\n  protected getContentElement = this.locatorForOptional('.my-popup-content');\n\n  /** Toggles the open state of the popup. */\n  async toggle() {\n    const trigger = await this.getTriggerElement();\n    return trigger.click();\n  }\n\n  /** Checks if the popup us open. */\n  async isOpen() {\n    const content = await this.getContentElement();\n    return !!content;\n  }\n}\n\n```\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#loading-harnesses-for-subcomponents)  Loading harnesses for subcomponents\n\nLarger components often compose smaller components. You can reflect this structure in a\ncomponent's harness as well. Each of the `locatorFor` methods on `ComponentHarness` discussed\nearlier has an alternate signature that can be used for locating sub-harnesses rather than elements.\n\n| Method | Description |\n| --- | --- |\n| `locatorFor<T extends ComponentHarness>(harnessType: ComponentHarnessConstructor<T>): () => Promise<T>` | Creates a function that returns a `Promise` for the first harness matching the given harness type when called. If no matching harness is found, the `Promise` rejects. |\n| `locatorForOptional<T extends ComponentHarness>(harnessType: ComponentHarnessConstructor<T>): () => Promise<T | null>` | Creates a function that returns a `Promise` for the first harness matching the given harness type when called. If no matching harness is found, the `Promise` is resolved with `null`. |\n| `locatorForAll<T extends ComponentHarness>(harnessType: ComponentHarnessConstructor<T>): () => Promise<T[]>` | Creates a function that returns a `Promise` for a list of all harnesses matching the given harness type when called. |\n\nFor example, consider a menu build using the popup shown above:\n\n```ts\n@Component({\n  selector: 'my-menu',\n  template: `\n    <my-popup>\n      <ng-content></ng-content>\n    </my-popup>\n  `\n})\nclass MyMenu {\n  @Input() triggerText: string;\n\n  @ContentChildren(MyMenuItem) items: QueryList<MyMenuItem>;\n}\n\n@Directive({\n  selector: 'my-menu-item'\n})\nclass MyMenuItem {}\n\n```\n\nThe harness for `MyMenu` can then take advantage of other harnesses for `MyPopup` and `MyMenuItem`:\n\n```ts\nclass MyMenuHarness extends ComponentHarness {\n  static hostSelector = 'my-menu';\n\n  protected getPopupHarness = this.locatorFor(MyPopupHarness);\n\n  /** Gets the currently shown menu items (empty list if menu is closed). */\n  getItems = this.locatorForAll(MyMenuItemHarness);\n\n  /** Toggles open state of the menu. */\n  async toggle() {\n    const popupHarness = await this.getPopupHarness();\n    return popupHarness.toggle();\n  }\n}\n\nclass MyMenuItemHarness extends ComponentHarness {\n  static hostSelector = 'my-menu-item';\n}\n\n```\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#filtering-harness-instances-with-harnesspredicate)  Filtering harness instances with `HarnessPredicate`\n\nWhen a page contains multiple instances of a particular component, you may want to filter based on\nsome property of the component to get a particular component instance. For example, you may want\na button with some specific text, or a menu with a specific ID. The `HarnessPredicate`\nclass can capture criteria like this for a `ComponentHarness` subclass. While the\ntest author is able to construct `HarnessPredicate` instances manually, it's easier when the\n`ComponentHarness` subclass provides a helper method to construct predicates for common filters.\n\nThe recommended approach to providing this helper is to create a static `with` method on each\n`ComponentHarness` subclass that returns a `HarnessPredicate` for that class. This allows test\nauthors to write easily understandable code, e.g.\n`loader.getHarness(MyMenuHarness.with({selector: '#menu1'}))`. In addition to the standard\n`selector` and `ancestor` options, the `with` method should add any other options that make sense\nfor the particular subclass.\n\nHarnesses that need to add additional options should extend the `BaseHarnessFilters` interface and\nadditional optional properties as needed. `HarnessPredicate` provides several convenience methods\nfor adding options.\n\n| Method | Description |\n| --- | --- |\n| `static stringMatches(s: string | Promise<string>, pattern: string | RegExp): Promise<boolean>` | Compares a string or `Promise` of a string against a `string` or `RegExp` and returns a boolean `Promise` indicating whether it matches. |\n| `addOption<O>(name: string, option: O | undefined, predicate: (harness: T, option: O) => Promise<boolean>): HarnessPredicate<T>` | Creates a new `HarnessPredicate` that enforces all of the conditions of the current one, plus the new constraint specified by the `predicate` parameter. If the `option` parameter is `undefined` the `predicate` is considered to be always true. |\n| `add(description: string, predicate: (harness: T) => Promise<boolean>): HarnessPredicate<T>` | Creates a new `HarnessPredicate` that enforces all of the conditions of the current one, plus the new constraint specified by the `predicate` parameter. |\n\nFor example, when working with a menu it would likely be useful to add a way to filter based on\ntrigger text and to filter menu items based on their text:\n\n```ts\ninterface MyMenuHarnessFilters extends BaseHarnessFilters {\n  /** Filters based on the trigger text for the menu. */\n  triggerText?: string | RegExp;\n}\n\ninterface MyMenuItemHarnessFilters extends BaseHarnessFilters {\n  /** Filters based on the text of the menu item. */\n  text?: string | RegExp;\n}\n\nclass MyMenuHarness extends ComponentHarness {\n  static hostSelector = 'my-menu';\n\n  /** Creates a `HarnessPredicate` used to locate a particular `MyMenuHarness`. */\n  static with(options: MyMenuHarnessFilters): HarnessPredicate<MyMenuHarness> {\n    return new HarnessPredicate(MyMenuHarness, options)\n        .addOption('trigger text', options.triggerText,\n            (harness, text) => HarnessPredicate.stringMatches(harness.getTriggerText(), text));\n  }\n\n  protected getPopupHarness = this.locatorFor(MyPopupHarness);\n\n  /** Gets the text of the menu trigger. */\n  async getTriggerText(): Promise<string> {\n    const popupHarness = await this.getPopupHarness();\n    return popupHarness.getTriggerText();\n  }\n\n  ...\n}\n\nclass MyMenuItemHarness extends ComponentHarness {\n  static hostSelector = 'my-menu-item';\n\n  /** Creates a `HarnessPredicate` used to locate a particular `MyMenuItemHarness`. */\n  static with(options: MyMenuItemHarnessFilters): HarnessPredicate<MyMenuItemHarness> {\n    return new HarnessPredicate(MyMenuItemHarness, options)\n        .addOption('text', options.text,\n            (harness, text) => HarnessPredicate.stringMatches(harness.getText(), text));\n  }\n\n  /** Gets the text of the menu item. */\n  async getText(): Promise<string> {\n    const host = await this.host();\n    return host.text();\n  }\n}\n\n```\n\nYou can pass a `HarnessPredicate` in place of a `ComponentHarness` class to any of the APIs on\n`HarnessLoader`, `LocatorFactory`, or `ComponentHarness`. This allows test authors to easily target\na particular component instance when creating a harness instance. It also allows the harness author\nto leverage the same `HarnessPredicate` to enable more powerful APIs on their harness class. For\nexample, consider the `getItems` method on the `MyMenuHarness` shown above.\nThis can now easily be expanded to allow users of the harness to search for particular menu items:\n\n```ts\nclass MyMenuHarness extends ComponentHarness {\n  static hostSelector = 'my-menu';\n\n  /** Gets a list of items in the menu, optionally filtered based on the given criteria. */\n  async getItems(filters: MyMenuItemHarnessFilters = {}): Promise<MyMenuItemHarness[]> {\n    const getFilteredItems = this.locatorForAll(MyMenuItemHarness.with(filters));\n    return getFilteredItems();\n  }\n\n  ...\n}\n\n```\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#creating-a-harnessloader-for-an-element)  Creating a `HarnessLoader` for an element\n\nSome components use `<ng-content>` to project additional content into the component's template. When\ncreating a harness for such a component, you can give the harness user a `HarnessLoader` instance\nscoped to the element containing the `<ng-content>`. This allows the user of the harness to load\nadditional harnesses for whatever components were passed in as content. `ComponentHarness` has\nseveral APIs that can be used to create `HarnessLoader` instances for cases like this.\n\n| Method | Description |\n| --- | --- |\n| `harnessLoaderFor(selector: string): Promise<HarnessLoader>` | Gets a `Promise` for a `HarnessLoader` rooted at the first element matching the given selector, if no element is found the `Promise` rejects. |\n| `harnessLoaderForOptional(selector: string): Promise<HarnessLoader | null>` | Gets a `Promise` for a `HarnessLoader` rooted at the first element matching the given selector, if no element is found the `Promise` resolves to `null`. |\n| `harnessLoaderForAll(selector: string): Promise<HarnessLoader[]>` | Gets a `Promise` for a list of `HarnessLoader`, one rooted at each element matching the given selector. |\n\nThe `MyPopup` component discussed earlier is a good example of a component with arbitrary content\nthat users may want to load harnesses for. `MyPopupHarness` could add support for this by\nextending `ContentContainerComponentHarness`.\n\n```ts\nclass MyPopupHarness extends ContentContainerComponentHarness<string> {\n  static hostSelector = 'my-popup';\n}\n\n```\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#accessing-elements-outside-of-the-components-host-element)  Accessing elements outside of the component's host element\n\nThere are times when a component harness might need to access elements outside of its corresponding\ncomponent's host element. Components that use [CDK overlay](https://material.angular.io/cdk/overlay/overview) serve as examples of this. The CDK overlay creates an element that is attached directly to the body, outside of the component's host element. In this case,\n`ComponentHarness` provides a method that can be used to get a `LocatorFactory` for the root element\nof the document. The `LocatorFactory` supports most of the same APIs as the `ComponentHarness` base\nclass, and can then be used to query relative to the document's root element.\n\n| Method | Description |\n| --- | --- |\n| `documentRootLocatorFactory(): LocatorFactory` | Creates a `LocatorFactory` rooted at the document's root element. |\n\nConsider if the `MyPopup` component above used the CDK overlay for the popup content, rather than an\nelement in its own template. In this case, `MyPopupHarness` would have to access the content element\nvia `documentRootLocatorFactory()`:\n\n```ts\nclass MyPopupHarness extends ComponentHarness {\n  static hostSelector = 'my-popup';\n\n  /** Gets a `HarnessLoader` whose root element is the popup's content element. */\n  async getHarnessLoaderForContent(): Promise<HarnessLoader> {\n    const rootLocator = this.documentRootLocatorFactory();\n    return rootLocator.harnessLoaderFor('my-popup-content');\n  }\n}\n\n```\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#waiting-for-asynchronous-tasks)  Waiting for asynchronous tasks\n\nThe methods on `TestElement` automatically trigger Angular's change detection and wait for tasks\ninside the `NgZone`, so in most cases no special effort is required for harness authors to wait on\nasynchronous tasks. However, there are some edge cases where this may not be sufficient.\n\nUnder some circumstances, Angular animations may require a second cycle of change detection and\nsubsequent `NgZone` stabilization before animation events are fully flushed. In cases where this is\nneeded, the `ComponentHarness` offers a `forceStabilize()` method that can be called to do the\nsecond round.\n\nAdditionally, some components may intentionally schedule tasks _outside_ of `NgZone`, this is\ntypically accomplished by using `NgZone.runOutsideAngular`. In this case, the corresponding harness\nmay need to explicitly wait for tasks outside `NgZone`, as this does not happen automatically.\n`ComponentHarness` offers a method called `waitForTasksOutsideAngular` for this purpose.\n\n| Method | Description |\n| --- | --- |\n| `forceStabilize(): Promise<void>` | Explicitly runs a round of change detection in Angular and waits for `NgZone` to stabilize. |\n| `waitForTasksOutsideAngular(): Promise<void>` | Waits for tasks scheduled outside of `NgZone` to complete. |\n\n### [link](https://material.angular.io/cdk/testing/overview\\#api-for-harness-environment-authors)  API for harness environment authors\n\nHarness environment authors are developers who want to add support for using component harnesses in\nadditional testing environments. Out-of-the-box, Angular CDK's component harnesses can be used in\nSelenium WebDriver E2E tests and Karma unit tests. Developers can support additional environments by\ncreating custom implementations of `TestElement` and `HarnessEnvironment`.\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#creating-a-testelement-implementation-for-the-environment)  Creating a `TestElement` implementation for the environment\n\nThe first step in adding support for a new testing environment is to create a `TestElement`\nimplementation. The `TestElement` interface serves as an environment-agnostic representation of a\nDOM element; it lets harnesses interact with DOM elements regardless of the underlying environment.\nBecause some environments don't support interacting with DOM elements synchronously\n(e.g. WebDriver), all of the `TestElement` methods are asynchronous, returning a `Promise` with the\nresult of the operation.\n\n| Method | Description |\n| --- | --- |\n| `blur(): Promise<void>` | Blurs the element. |\n| `clear(): Promise<void>` | Clears the text from an element (only applies for `<input>` and `<textarea>`). |\n| `click(relativeX?: number, relativeY?: number): Promise<void>` | Clicks an element at a point relative to it's top-left corner. |\n| `focus(): Promise<void>` | Focuses the element. |\n| `getCssValue(property: string): Promise<string>` | Gets the computed CSS value of the given property for the element. |\n| `hover(): Promise<void>` | Hovers the mouse over the element. |\n| `sendKeys(...keys: (string | TestKey)[]): Promise<void>` | Sends a sequence of key events to the element. |\n| `sendKeys(modifiers: ModifierKeys, ...keys: (string | TestKey)[]): Promise<void>` | Sends a sequence of key events to the element, while holding a set of modifier keys. |\n| `text(): Promise<string>` | Gets the text content of the element. |\n| `getAttribute(name: string): Promise<string | null>` | Gets the value of the given HTML attribute for the element. |\n| `hasClass(name: string): Promise<boolean>` | Checks whether the element has the given class. |\n| `getDimensions(): Promise<ElementDimensions>` | Gets the dimensions of the element. |\n| `getProperty(name: string): Promise<any>` | Gets the value of the given property for the element. |\n| `matchesSelector(selector: string): Promise<boolean>` | Checks whether the given selector matches the element. |\n| `setInputValue(value: string): Promise<void>;` | Sets the value of a property of an input. |\n| `selectOptions(...optionIndexes: number[]): Promise<void>;` | Selects the options at the specified indexes inside of a native `select` element. |\n| `dispatchEvent(name: string, data?: Record<string, EventData>): Promise<void>;` | Dispatches an event with a particular name. |\n\nThe `TestElement` interface consists largely of methods that resemble methods\navailable on `HTMLElement`; similar methods exist in most test environments, which makes\nimplementing the methods fairly straightforward. However, one important difference to note when\nimplementing the `sendKeys` method, is that the key codes in the `TestKey`\nenum likely differ from the key codes used in the test environment. Environment authors should\nmaintain a mapping from `TestKey` codes to the codes used in the particular testing environment.\n\nThe\n[`UnitTestElement`](https://github.com/angular/components/blob/main/src/cdk/testing/testbed/unit-test-element.ts#L57)\nand\n[`SeleniumWebDriverElement`](https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-web-driver-element.ts#L22)\nimplementations in Angular CDK serve as good examples of implementations of this interface.\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#creating-a-harnessenvironment-implementation-for-the-environment)  Creating a `HarnessEnvironment` implementation for the environment\n\nTest authors use `HarnessEnvironment` to create component harness instances for use in tests.\n\n`HarnessEnvironment` is an abstract class that must be extended to create a concrete subclass for\nthe new environment. When supporting a new test environment, you must create a `HarnessEnvironment`\nsubclass that adds concrete implementations for all abstract members.\n\nYou will notice that `HarnessEnvironment` has a generic type parameter: `HarnessEnvironment<E>`.\nThis parameter, `E`, represents the raw element type of the environment. For example, this parameter\nis `Element` for unit test environments.\n\nThe following are the abstract methods that must be implemented:\n\n| Method | Description |\n| --- | --- |\n| `abstract getDocumentRoot(): E` | Gets the root element for the environment (e.g. `document.body`). |\n| `abstract createTestElement(element: E): TestElement` | Creates a `TestElement` for the given raw element. |\n| `abstract createEnvironment(element: E): HarnessEnvironment` | Creates a `HarnessEnvironment` rooted at the given raw element. |\n| `abstract getAllRawElements(selector: string): Promise<E[]>` | Gets all of the raw elements under the root element of the environment matching the given selector. |\n| `abstract forceStabilize(): Promise<void>` | Gets a `Promise` that resolves when the `NgZone` is stable. Additionally, if applicable, tells `NgZone` to stabilize (e.g. calling `flush()` in a `fakeAsync` test). |\n| `abstract waitForTasksOutsideAngular(): Promise<void>` | Gets a `Promise` that resolves when the parent zone of `NgZone` is stable. |\n\nIn addition to implementing the missing methods, this class should provide a way for test authors to\nget `ComponentHarness` instances. The recommended approach is to have a protected constructor and\nprovide a static method called `loader` that returns a `HarnessLoader` instance. This allows test\nauthors to write code like: `SomeHarnessEnvironment.loader().getHarness(...)`. Depending on the\nneeds of the particular environment, the class may provide several different static methods or\nrequire arguments to be passed. (e.g. the `loader` method on `TestbedHarnessEnvironment` takes a\n`ComponentFixture`, and the class provides additional static methods called `documentRootLoader` and\n`harnessForFixture`).\n\nThe\n[`TestbedHarnessEnvironment`](https://github.com/angular/components/blob/main/src/cdk/testing/testbed/testbed-harness-environment.ts#L20)\nand\n[`SeleniumWebDriverHarnessEnvironment`](https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-web-driver-harness-environment.ts#L71)\nimplementations in Angular CDK serve as good examples of implementations of this interface.\n\n#### [link](https://material.angular.io/cdk/testing/overview\\#handling-auto-change-detection-status)  Handling auto change detection status\n\nIn order to support the `manualChangeDetection` and `parallel` APIs, your environment should install\na handler for the auto change detection status.\n\nWhen your environment wants to start handling the auto change detection status it can call\n`handleAutoChangeDetectionStatus(handler)`. The handler function will receive a\n`AutoChangeDetectionStatus` which has two properties:\n\n- `isDisabled: boolean` \\- Indicates whether auto change detection is currently disabled. When true,\nyour environment's `forceStabilize` method should act as a no-op. This allows users to trigger\nchange detection manually instead.\n- `onDetectChangesNow?: () => void` \\- If this optional callback is specified, your environment\nshould trigger change detection immediately and call the callback when change detection finishes.\n\nIf your environment wants to stop handling auto change detection status it can call\n`stopHandlingAutoChangeDetectionStatus()`.\n\nOverview Content\n\nAzure & Blue theme selected.\n\nSelect a version of the documentation\n\nSelect a theme for the documentation",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-f506466a-3041-4943-bb0f-8729e37bb3f0.png"
  },
  "metadata": {
    "keywords": "angular, material design, material, angular material, web, ui, components, responsive, accessibility, typescript, css, mobile web, open source",
    "author": "Angular Components Team",
    "description": "UI component infrastructure and Material Design components for mobile and desktop Angular web applications.",
    "ogDescription": "UI component infrastructure and Material Design components for Angular web applications.",
    "og:image": "https://material.angular.io/assets/img/site-preview.png",
    "apple-mobile-web-app-capable": "yes",
    "ogLocale": "en_US",
    "favicon": "https://material.angular.io/cdk/testing/assets/img/favicon.ico?v=19.1.0",
    "ogTitle": "Angular Material",
    "ogSiteName": "Angular Material",
    "theme-color": "#d7e3ff",
    "viewport": "width=device-width, initial-scale=1",
    "og:image:width": "1339",
    "og:type": "website",
    "apple-mobile-web-app-status-bar-style": "translucent",
    "twitter:card": "summary",
    "twitter:creator": "@Angular",
    "twitter:image": "https://material.angular.io/assets/img/site-preview.png",
    "title": "Component Harnesses | Angular Material",
    "og:image:type": "image/png",
    "og:image:height": "943",
    "og:title": "Angular Material",
    "og:image:secure_url": "https://material.angular.io/assets/img/site-preview.png",
    "twitter:site": "@Angular",
    "og:url": "https://material.angular.io/",
    "og:site_name": "Angular Material",
    "mobile-web-app-capable": "yes",
    "twitter:description": "UI component infrastructure and Material Design components for Angular web applications.",
    "og:description": "UI component infrastructure and Material Design components for Angular web applications.",
    "ogImage": "https://material.angular.io/assets/img/site-preview.png",
    "twitter:title": "Angular Material",
    "og:locale": "en_US",
    "language": "en-US",
    "ogUrl": "https://material.angular.io/",
    "scrapeId": "ffea313b-8249-4cc0-ba2e-027d971169fb",
    "sourceURL": "https://material.angular.io/cdk/testing/overview",
    "url": "https://material.angular.io/cdk/testing/overview",
    "statusCode": 200
  }
}