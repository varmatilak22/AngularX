{
  "scrapeId": "cfcb80a7-36c4-41a7-842a-5f9def5343e7",
  "sourceURL": "https://angular.dev/guide/hybrid-rendering",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backServer-side & hybrid-rendering\n  - [Overview](https://angular.dev/guide/performance)\n  - [Server-side rendering](https://angular.dev/guide/ssr)\n  - [Build-time prerendering](https://angular.dev/guide/prerendering)\n  - [Hybrid rendering with server routing](https://angular.dev/guide/hybrid-rendering)\n  - [Hydration](https://angular.dev/guide/hydration)\n  - [Incremental Hydration](https://angular.dev/guide/incremental-hydration)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\n## [What is hybrid rendering?](https://angular.dev/guide/hybrid-rendering\\#what-is-hybrid-rendering)\n\nHybrid rendering combines the benefits of server-side rendering (SSR), pre-rendering (also known as \"static site generation\" or SSG) and client-side rendering (CSR) to optimize your Angular application. It allows you to render different parts of your application using different strategies, giving you fine-grained control over how your app is delivered to users.\n\nAngularâ€™s new **developer preview** server rendering APIs offer a more efficient and adaptable approach to building modern web applications. These APIs give you complete control over your appâ€™s rendering, allowing for optimizations that enhance performance, Search Engine Optimization (SEO), and overall user experience.\n\n**Benefits of these new APIs:**\n\n- **Greater flexibility:**\n  - Leverage fine-grained control over rendering allows you to optimize for performance and user experience in different parts of your application.\n  - Choose the best rendering strategy for each route, whether it's server-side rendering for fast initial load times, client-side rendering for dynamic interactivity, or a hybrid approach.\n- **Built-in internationalization (i18n):**\n  - Easily adapt your application to different languages and regions with out-of-the-box i18n support.\n- **Environment agnostic:**\n  - Use these APIs with any JavaScript runtime environment, not just Node.js.\n  - Enjoy the benefits of enhanced rendering capabilities regardless of your technology stack.\n- **Seamless dev server integration:**\n  - Take advantage of a smooth and efficient development experience from a fully integrated development server.\n\nThis developer preview gives you a first look at these powerful new features. The Angular team encourages you to explore them and provide feedback to help shape the future of Angular server rendering.\n\n## [Setting up hybrid rendering](https://angular.dev/guide/hybrid-rendering\\#setting-up-hybrid-rendering)\n\nYou can create a **new** project with server-side routing with the Angular CLI:\n\n```\n      ng new --ssr --server-routing\n\n```\n\ncheck\n\nYou can also add server-side routing to an existing project with the `ng add` command:\n\n```\n      ng add @angular/ssr --server-routing\n\n```\n\ncheck\n\n## [Server routing](https://angular.dev/guide/hybrid-rendering\\#server-routing)\n\n### [Configuring server routes](https://angular.dev/guide/hybrid-rendering\\#configuring-server-routes)\n\nYou can create a server route config by declaring an array of [`ServerRoute`](https://angular.dev/guide/api/ssr/ServerRoute \"API\") objects. This configuration typically lives in a file named `app.routes.server.ts`.\n\n```\n      // app.routes.server.tsimport { RenderMode, ServerRoute } from '@angular/ssr';export const serverRoutes: ServerRoute[] = [  {    path: '', // This renders the \"/\" route on the client (CSR)    renderMode: RenderMode.Client,  },  {    path: 'about', // This page is static, so we prerender it (SSG)    renderMode: RenderMode.Prerender,  },  {    path: 'profile', // This page requires user-specific data, so we use SSR    renderMode: RenderMode.Server,  },  {    path: '**', // All other routes will be rendered on the server (SSR)    renderMode: RenderMode.Server,  },];\n\n```\n\ncheck\n\nYou can add this config to your application using the [`provideServerRouting`](https://angular.dev/guide/api/ssr/provideServerRouting \"API\") function.\n\n```\n      import { provideServerRouting } from '@angular/ssr';import { serverRoutes } from './app.routes.server';// app.config.server.tsconst serverConfig: ApplicationConfig = {  providers: [    provideServerRendering(),    provideServerRouting(serverRoutes),    // ... other providers ...  ]};\n\n```\n\ncheck\n\nWhen using the [App shell pattern](https://angular.dev/guide/ecosystem/service-workers/app-shell), you must specify the route to be used as the app shell for client-side rendered routes. To do this, provide an options object with the `appShellRoute` property to [`provideServerRouting`](https://angular.dev/guide/api/ssr/provideServerRouting \"API\"):\n\n```\n      import { provideServerRouting, withAppShell } from '@angular/ssr';import { AppShellComponent } from './app-shell/app-shell.component';const serverConfig: ApplicationConfig = {  providers: [    provideServerRouting(serverRoutes, withAppShell(AppShellComponent)),    // ... other providers ...  ]};\n\n```\n\ncheck\n\n### [Rendering modes](https://angular.dev/guide/hybrid-rendering\\#rendering-modes)\n\nThe server routing configuration lets you specify how each route in your application should render by setting a [`RenderMode`](https://angular.dev/guide/api/ssr/RenderMode \"API\"):\n\n| Rendering mode | Description |\n| --- | --- |\n| **Server (SSR)** | Renders the application on the server for each request, sending a fully populated HTML page to the browser. See the [Server-Side Rendering (SSR) guide](https://angular.dev/guide/guide/ssr) for more information. |\n| **Client (CSR)** | Renders the application in the browser. This is the default Angular behavior. |\n| **Prerender (SSG)** | Prerenders the application at build time, generating static HTML files for each route. See the [Prerendering guide](https://angular.dev/guide/guide/prerendering) for more information. |\n\n#### [Choosing a rendering mode](https://angular.dev/guide/hybrid-rendering\\#choosing-a-rendering-mode)\n\nEach rendering mode has different benefits and drawbacks. You can choose rendering modes based on the specific needs of your application.\n\n##### [Client-side rendering](https://angular.dev/guide/hybrid-rendering\\#client-side-rendering)\n\nClient-side rendering has the simplest development model, as you can write code that assumes it always runs in a web browser. This lets you use a wide range of client-side libraries that also assume they run in a browser.\n\nClient-side rendering generally has worse performance than other rendering modes, as it must download, parse, and execute your page's JavaScript before the user can see any rendered content. If your page fetches more data from the server as it renders, users also have to wait for those additional requests before they can view the complete content.\n\nIf your page is indexed by search crawlers, client-side rendering may negatively affect search engine optimization (SEO), as search crawlers have limits to how much JavaScript they execute when indexing a page.\n\nWhen client-side rendering, the server does not need to do any work to render a page beyond serving static JavaScript assets. You may consider this factor if server cost is a concern.\n\nApplications that support installable, offline experiences with [service workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) can rely on client-side rendering without needing to communicate with a server.\n\n##### [Server-side rendering](https://angular.dev/guide/hybrid-rendering\\#server-side-rendering)\n\nServer-side rendering offers faster page loads than client-side rendering. Instead of waiting for JavaScript to download and run, the server directly renders an HTML document upon receiving a request from the browser. The user experiences only the latency necessary for the server to fetch data and render the requested page. This mode also eliminates the need for additional network requests from the browser, as your code can fetch data during rendering on the server.\n\nServer-side rendering generally has excellent search engine optimization (SEO), as search crawlers receive a fully rendered HTML document.\n\nServer-side rendering requires you to author code that does not strictly depend on browser APIs and limits your selection of JavaScript libraries that assume they run in a browser.\n\nWhen server-side rendering, your server runs Angular to produce an HTML response for every request. This additional cost may affect server hosting costs.\n\n##### [Build-time prerendering](https://angular.dev/guide/hybrid-rendering\\#build-time-prerendering)\n\nPrerendering offers faster page loads than both client-side rendering and server-side rendering. Because prerendering creates HTML documents at _build-time_, the server can directly respond to requests with the static HTML document without any additional work.\n\nPrerendering requires that all information necessary to render a page is available at _build-time_. This means that prerendered pages cannot include any data to the specific user loading the page. This means that prerendering is primarily useful for pages that are the same for all users of your application.\n\nBecause prerendering occurs at build-time, it may add significant time to your production builds. Using [`getPrerenderParams`](https://angular.dev/guide/api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams \"API\") to produce a large number of HTML documents may affect the total file size of your deployments, and thus lead to slower deployments.\n\nIt may also add time to your deployments based on the number of static HTML documents included in your build output.\n\nPrerendering generally has excellent search engine optimization (SEO), as search crawlers receive a fully rendered HTML document.\n\nPrerendering requires you to author code that does not strictly depend on browser APIs and limits your selection of JavaScript libraries that assume they run in a browser.\n\nPrerendering incurs extremely little overhead per server request, as your server responds with static HTML documents. Static files are also easily cached by Content Delivery Networks (CDNs), browsers, and intermediate caching layers for even faster subsequent page loads. Deploying static HTML files to a CDN improves scalability by offloading work from your application web server, which is impactful for high-traffic applications.\n\n### [Setting headers and status codes](https://angular.dev/guide/hybrid-rendering\\#setting-headers-and-status-codes)\n\nYou can set custom headers and status codes for individual server routes using the `headers` and `status` properties in the `ServerRoute` configuration.\n\n```\n      // app.routes.server.tsimport { RenderMode, ServerRoute } from '@angular/ssr';export const serverRoutes: ServerRoute[] = [  {    path: 'profile',    renderMode: RenderMode.Server,    headers: {      'X-My-Custom-Header': 'some-value',    },    status: 201,  },  // ... other routes];\n\n```\n\ncheck\n\n### [Redirects](https://angular.dev/guide/hybrid-rendering\\#redirects)\n\nAngular handles redirects specified by the [`redirectTo`](https://angular.dev/guide/api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams \"API\") property in route configurations, differently on the server-side.\n\n**Server-Side Rendering (SSR)**\nRedirects are performed using standard HTTP redirects (e.g., 301, 302) within the server-side rendering process.\n\n**Prerendering (SSG)**\nRedirects are implemented as \"soft redirects\" using `<meta http-equiv=\"refresh\">` tags in the prerendered HTML. This allows for redirects without requiring a round trip to the server.\n\n### [Customizing build-time prerendering (SSG)](https://angular.dev/guide/hybrid-rendering\\#customizing-build-time-prerendering-ssg)\n\nWhen using [`RenderMode.Prerender`](https://angular.dev/guide/api/ssr/RenderMode#Prerender \"API\"), you can specify several configuration options to customize the prerendering and serving process.\n\n#### [Parameterized routes](https://angular.dev/guide/hybrid-rendering\\#parameterized-routes)\n\nFor each route with [`RenderMode.Prerender`](https://angular.dev/guide/api/ssr/RenderMode#Prerender \"API\"), you can specify a [`getPrerenderParams`](https://angular.dev/guide/api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams \"API\") function. This function lets you control which specific parameters produce separate prerendered documents.\n\nThe [`getPrerenderParams`](https://angular.dev/guide/api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams \"API\") function returns a `Promise` that resolves to an array of objects. Each object is a key-value map of route parameter name to value. For example, if you define a route like `posts/:id`, `getPrerenderParams ` could return the array `[{id: 123}, {id: 456}]`, and thus render separate documents for `posts/123` and `posts/456`.\n\nThe body of [`getPrerenderParams`](https://angular.dev/guide/api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams \"API\") can use Angular's [`inject`](https://angular.dev/guide/api/core/inject \"API\") function to inject dependencies and perform any work to determine which routes to prerender. This typically includes making requests to fetch data to construct the array of parameter values.\n\n```\n      // app.routes.server.tsimport { RenderMode, ServerRoute } from '@angular/ssr';export const serverRoutes: ServerRoute[] = [  {    path: 'post/:id',    renderMode: RenderMode.Prerender,    async getPrerenderParams() {      const dataService = inject(PostService);      const ids = await dataService.getIds(); // Assuming this returns ['1', '2', '3']      return ids.map(id => ({ id })); // Transforms IDs into an array of objects for prerendering      // This will prerender the paths: `/post/1`, `/post/2` and `/post/3`    },  },];\n\n```\n\ncheck\n\nBecause [`getPrerenderParams`](https://angular.dev/guide/api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams \"API\") exclusively applies to [`RenderMode.Prerender`](https://angular.dev/guide/api/ssr/RenderMode#Prerender \"API\"), this function always runs at _build-time_. `getPrerenderParams` must not rely on any browser-specific or server-specific APIs for data. If the route does not specify a [`fallback`](https://angular.dev/guide/api/ssr/ServerRoutePrerenderWithParams#fallback \"API\") option, the route falls back to [`PrerenderFallback.Server`](https://angular.dev/guide/api/ssr/PrerenderFallback#Server \"API\") (SSR) by default.\n\n**IMPORTANT:** When using [`inject`](https://angular.dev/guide/api/core/inject \"API\") inside `getPrerenderParams`, please remember that `inject` must be used synchronously. It cannot be invoked within asynchronous callbacks or following any `await` statements. For more information, refer to [`runInInjectionContext` API reference](https://angular.dev/guide/api/core/runInInjectionContext).\n\n#### [Fallback strategies](https://angular.dev/guide/hybrid-rendering\\#fallback-strategies)\n\nWhen using [`RenderMode.Prerender`](https://angular.dev/guide/api/ssr/RenderMode#Prerender \"API\") mode, you can specify a fallback strategy to handle requests for paths that haven't been prerendered.\n\nThe available fallback strategies are:\n\n- **Server:** Fallback to server-side rendering. This is the **default** behavior if no `fallback` property is specified.\n- **Client:** Fallback to client-side rendering.\n- **None:** No fallback. Angular will not handle requests for paths that are not prerendered.\n\n```\n      // app.routes.server.tsimport { RenderMode, PrerenderFallback, ServerRoute } from '@angular/ssr';export const serverRoutes: ServerRoute[] = [  {    path: 'post/:id',    renderMode: RenderMode.Prerender,    fallback: PrerenderFallback.Client, // Fallback to CSR if not prerendered    async getPrerenderParams() {      // This function returns an array of objects representing prerendered posts at the paths:      // `/post/1`, `/post/2`, and `/post/3`.      // The path `/post/4` will utilize the fallback behavior if it's requested.      return [{ id: 1 }, { id: 2 }, { id: 3 }];    },  },];\n\n```\n\ncheck\n\n## [Accessing Request and Response via DI](https://angular.dev/guide/hybrid-rendering\\#accessing-request-and-response-via-di)\n\nThe `@angular/core` package provides several tokens for interacting with the server-side rendering environment. These tokens give you access to crucial information and objects within your Angular application during SSR.\n\n- **[`REQUEST`](https://angular.dev/guide/api/core/REQUEST \"API\"):** Provides access to the current request object, which is of type [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) from the Web API. This allows you to access headers, cookies, and other request information.\n- **[`RESPONSE_INIT`](https://angular.dev/guide/api/core/RESPONSE_INIT \"API\"):** Provides access to the response initialization options, which is of type [`ResponseInit`](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#parameters) from the Web API. This allows you to set headers and the status code for the response dynamically. Use this token to set headers or status codes that need to be determined at runtime.\n- **[`REQUEST_CONTEXT`](https://angular.dev/guide/api/core/REQUEST_CONTEXT \"API\"):** Provides access to additional context related to the current request. This context can be passed as the second parameter of the [`handle`](https://angular.dev/guide/api/ssr/AngularAppEngine#handle \"API\") function. Typically, this is used to provide additional request-related information that is not part of the standard Web API.\n\n```\n      import { inject, REQUEST } from '@angular/core';@Component({  selector: 'app-my-component',  template: `<h1>My Component</h1>`,})export class MyComponent {  constructor() {    const request = inject(REQUEST);    console.log(request?.url);  }}\n\n```\n\ncheck\n\n**IMPORTANT:** The above tokens will be `null` in the following scenarios:\n\n- During the build processes.\n- When the application is rendered in the browser (client-side rendering).\n- When performing static site generation (SSG).\n- During route extraction in development (at the time of the request).\n\n## [Configuring a non-Node.js Server](https://angular.dev/guide/hybrid-rendering\\#configuring-a-non-nodejs-server)\n\nThe `@angular/ssr` provides essential APIs for server-side rendering your Angular application on platforms other than Node.js. It leverages the standard [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) and [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) objects from the Web API, enabling you to integrate Angular SSR into various server environments. For detailed information and examples, refer to the [`@angular/ssr` API reference](https://angular.dev/guide/api/ssr/AngularAppEngine).\n\n```\n      // server.tsimport { AngularAppEngine, createRequestHandler } from '@angular/ssr';const angularApp = new AngularAppEngine();/** * This is a request handler used by the Angular CLI (dev-server and during build). */const reqHandler = createRequestHandler(async (req: Request) => {  const res: Response|null = await angularApp.render(req);  // ...});\n\n```\n\ncheck\n\n## [Configuring a Node.js Server](https://angular.dev/guide/hybrid-rendering\\#configuring-a-nodejs-server)\n\nThe `@angular/ssr/node` extends `@angular/ssr` specifically for Node.js environments. It provides APIs that make it easier to implement server-side rendering within your Node.js application. For a complete list of functions and usage examples, refer to the [`@angular/ssr/node` API reference](https://angular.dev/guide/api/ssr/node/AngularNodeAppEngine) API reference.\n\n```\n      // server.tsimport { AngularNodeAppEngine, createNodeRequestHandler, writeResponseToNodeResponse } from '@angular/ssr/node';import express from 'express';const app = express();const angularApp = new AngularNodeAppEngine();app.use('*', (req, res, next) => {  angularApp    .handle(req)    .then(response => {      if (response) {        writeResponseToNodeResponse(response, res);      } else {        next(); // Pass control to the next middleware      }    })    .catch(next);});/** * The request handler used by the Angular CLI (dev-server and during build). */export const reqHandler = createNodeRequestHandler(app);\n\n```\n\ncheck",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-84eab6d6-b748-49ec-9b4d-0dab992bb50a.png"
  },
  "metadata": {
    "ogTitle": "Angular",
    "og:title": "Angular",
    "og:description": "The web development framework for building modern apps.",
    "twitter:card": "summary_large_image",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "ogDescription": "The web development framework for building modern apps.",
    "language": "en",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "title": "Hybrid rendering with server routing â€¢ Angular",
    "msapplication-TileColor": "#e90464",
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "ogUrl": "https://angular.dev/",
    "apple-mobile-web-app-title": "Angular",
    "application-name": "Angular",
    "og:type": "website",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:url": "https://angular.dev/",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:description": "The web development framework for building modern apps.",
    "description": "The web development framework for building modern apps.",
    "viewport": "width=device-width, initial-scale=1",
    "og:url": "https://angular.dev/",
    "theme-color": "#ffffff",
    "twitter:title": "Angular",
    "scrapeId": "cfcb80a7-36c4-41a7-842a-5f9def5343e7",
    "sourceURL": "https://angular.dev/guide/hybrid-rendering",
    "url": "https://angular.dev/guide/hybrid-rendering",
    "statusCode": 200
  }
}