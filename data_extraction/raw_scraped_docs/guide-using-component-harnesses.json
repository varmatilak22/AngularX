{
  "scrapeId": "9aead749-d334-4721-8b36-6d43d750c7fb",
  "sourceURL": "https://material.angular.io/guide/using-component-harnesses",
  "statusCode": 200,
  "data": {
    "markdown": "# Using Angular Material's component harnesses in your tests\n\nThe Angular CDK provides code for creating component test harnesses. A component harness is\na class that lets a test interact with a component via a supported API. Each harness's API\ninteracts with a component the same way a user would. By using the harness API, a test insulates\nitself against updates to the internals of a component, such as changing its DOM structure. The\nidea for component harnesses comes from the\n[PageObject](https://martinfowler.com/bliki/PageObject.html) pattern commonly used for integration\ntesting.\n\nAngular Material offers test harnesses for many of its components. The Angular team strongly\nencourages developers to use these harnesses for testing to avoid creating brittle tests that rely\non a component's internals.\n\nThis guide discusses the advantages of using component test harnesses and shows how to use them.\n\n## [link](https://material.angular.io/guide/using-component-harnesses\\#benefits-of-component-test-harnesses)  Benefits of component test harnesses\n\nThere are two primary benefits to using the Angular Material component harnesses in your tests:\n\n1. Harnesses make tests easier to read and understand with straightforward APIs.\n2. Harnesses make tests more robust and less likely to break when updating Angular Material.\n\nThe following sections will illustrate these benefits in more detail.\n\n## [link](https://material.angular.io/guide/using-component-harnesses\\#which-kinds-of-tests-can-use-harnesses)  Which kinds of tests can use harnesses?\n\nThe Angular CDK's component harnesses are designed to work in multiple different test environments.\nSupport currently includes Angular's Testbed environment in Karma unit tests and Selenium WebDriver\nend-to-end (e2e) tests. You can also support additional environments by creating custom extensions\nof the CDK's `HarnessEnvironment` and `TestElement` classes.\n\n## [link](https://material.angular.io/guide/using-component-harnesses\\#getting-started)  Getting started\n\nThe foundation for all test harnesses lives in `@angular/cdk/testing`. Start by importing either\n`TestbedHarnessEnvironment` or `SeleniumWebDriverHarnessEnvironment` based on whether you're writing a\nunit test or an e2e test. From the `HarnessEnvironment`, you can get a `HarnessLoader` instance,\nwhich you will use to load Angular Material component harnesses. For example, if we're writing unit\ntests for a `UserProfile` component, the code might look like this:\n\n```ts\nimport {HarnessLoader} from '@angular/cdk/testing';\nimport {TestbedHarnessEnvironment} from '@angular/cdk/testing/testbed';\n\nlet loader: HarnessLoader;\n\ndescribe('my-component', () => {\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({imports: [MyModule], declarations: [UserProfile]})\n        .compileComponents();\n    fixture = TestBed.createComponent(UserProfile);\n    loader = TestbedHarnessEnvironment.loader(fixture);\n  });\n}\n\n```\n\nThis code creates a fixture for `UserProfile` and then creates a `HarnessLoader` for that fixture.\nThe `HarnessLoader` can then locate Angular Material components inside `UserProfile` and create\nharnesses for them. Note that `HarnessLoader` and `TestbedHarnessEnvironment` are loaded from\ndifferent paths.\n\n- `@angular/cdk/testing` contains symbols that are shared regardless of the environment your tests\nare in.\n- `@angular/cdk/testing/testbed` contains symbols that are used only in Karma tests.\n- `@angular/cdk/testing/selenium-webdriver` (not shown above) contains symbols that are used only in\nSelenium WebDriver tests.\n\n## [link](https://material.angular.io/guide/using-component-harnesses\\#loading-an-angular-material-harness)  Loading an Angular Material harness\n\nThe `HarnessLoader` provides two methods that can be used to load harnesses, `getHarness` and\n`getAllHarnesses`. The `getHarness` method gets a harness for the first instance\nof the matching component, while `getAllHarnesses` gets a list of harnesses, one\nfor each instance of the corresponding component. For example, suppose `UserProfile` contains three\n`MatButton` instances. We could load harnesses for them as follows:\n\n```ts\nimport {MatButtonHarness} from '@angular/material/button/testing';\n\n...\n\nit('should work', async () => {\n  const buttons = await loader.getAllHarnesses(MatButtonHarness); // length: 3\n  const firstButton = await loader.getHarness(MatButtonHarness); // === buttons[0]\n});\n\n```\n\nNotice the example code uses `async` and `await` syntax. All component harness APIs are\nasynchronous and return `Promise` objects. Because of this, the Angular team recommends using the\n[ES2017 `async`/ `await` syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\nwith your tests.\n\nThe example above retrieves all button harnesses and uses an array index to get the harness for a\nspecific button. However, if the number or order of buttons changes, this test will break. You can\nwrite a less brittle test by instead asking for only a subset of harnesses inside `UserProfile`.\n\nYou can load harnesses for a sub-section of the DOM within `UserProfile` with the `getChildLoader`\nmethod on `HarnessLoader`. For example, say that we know `UserProfile` has a div,\n`<div class=\"footer\">`, and we want the button inside that specific `<div>`. We can accomplish this\nwith the following code:\n\n```ts\nit('should work', async () => {\n  const footerLoader = await loader.getChildLoader('.footer');\n  const footerButton = await footerLoader.getHarness(MatButtonHarness);\n});\n\n```\n\nYou can also use the static `with` method implemented on all Angular Material component harnesses.\nThis method creates a `HarnessPredicate`, an object that filters loaded harnesses based on the\nprovided constraints. The particular constraint options vary depending on the harness class, but all\nharnesses support at least:\n\n- `selector` \\- CSS selector that the component must match (in addition to its host selector, such\nas `[mat-button]`)\n- `ancestor` \\- CSS selector for a some ancestor element above the component in the DOM\n\nIn addition to these standard options, `MatButtonHarness` also supports\n\n- `text` \\- String text or regular expressions that matches the text content of the button\n\nUsing this method we could locate buttons as follows in our test:\n\n```ts\nit('should work', async () => {\n  // Harness for mat-button whose id is 'more-info'.\n  const info = await loader.getHarness(MatButtonHarness.with({selector: '#more-info'}));\n  // Harness for mat-button whose text is 'Cancel'.\n  const cancel = await loader.getHarness(MatButtonHarness.with({text: 'Cancel'}));\n  // Harness for mat-button with class 'confirm' and whose text is either 'Ok' or 'Okay'.\n  const okButton = await loader.getHarness(\n      MatButtonHarness.with({selector: '.confirm', text: /^(Ok|Okay)$/}));\n});\n\n```\n\n## [link](https://material.angular.io/guide/using-component-harnesses\\#using-a-harness-to-interact-with-an-angular-material-component)  Using a harness to interact with an Angular Material component\n\nThe Angular Material component harnesses generally expose methods to either perform actions that a\nreal user could perform or to inspect component state that a real user might perceive. For\nexample, `MatButtonHarness` has methods to click, focus, and blur the `mat-button`, as well as\nmethods to get the text of the button and its disabled state. Because `MatButton` is a very simple\ncomponent, these harness methods might not seem very different from working directly with the DOM.\nHowever, more complex harnesses like `MatSelectHarness` have methods like `open` and `isOpen` which\ncapture more knowledge about the component's internals.\n\nA test using the `MatButtonHarness` to interact with a `mat-button` might look like the following:\n\n```ts\nit('should mark confirmed when ok button clicked', async () => {\n  const okButton = await loader.getHarness(MatButtonHarness.with({selector: '.confirm'});\n  expect(fixture.componentInstance.confirmed).toBe(false);\n  expect(await okButton.isDisabled()).toBe(false);\n  await okButton.click();\n  expect(fixture.componentInstance.confirmed).toBe(true);\n});\n\n```\n\nNote that the code above does not call `fixture.detectChanges()`, something you commonly see in\nunit tests. The CDK's component harnesses automatically invoke change detection after performing\nactions and before reading state. The harness also automatically waits for the fixture to be stable,\nwhich will cause the test to wait for `setTimeout`, `Promise`, etc.\n\n## [link](https://material.angular.io/guide/using-component-harnesses\\#comparison-with-and-without-component-harnesses)  Comparison with and without component harnesses\n\nConsider an `<issue-report-selector>` component that you want to test. It allows a user to\nchoose an issue type and display the necessary form create report for that issue type. You need a\ntest to verify that when the user chooses an issue type the proper report displays. First consider\nwhat the test might look like without using component harnesses:\n\n```ts\ndescribe('issue-report-selector', () => {\n  let fixture: ComponentFixture<IssueReportSelector>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [IssueReportSelectorModule],\n      declarations: [IssueReportSelector],\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(IssueReportSelector);\n    fixture.detectChanges();\n  });\n\n  it('should switch to bug report template', async () => {\n    expect(fixture.debugElement.query('bug-report-form')).toBeNull();\n    const selectTrigger = fixture.debugElement.query(By.css('.mat-select-trigger'));\n    selectTrigger.triggerEventHandler('click', {});\n    fixture.detectChanges();\n    await fixture.whenStable();\n    const options = document.querySelectorAll('.mat-select-panel mat-option');\n    options[1].click(); // Click the second option, \"Bug\".\n    fixture.detectChanges();\n    await fixture.whenStable();\n    expect(fixture.debugElement.query('bug-report-form')).not.toBeNull();\n  });\n});\n\n```\n\nThe same test, using the Angular Material component harnesses might look like the following:\n\n```ts\ndescribe('issue-report-selector', () => {\n  let fixture: ComponentFixture<IssueReportSelector>;\n  let loader: HarnessLoader;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [IssueReportSelectorModule],\n      declarations: [IssueReportSelector],\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(IssueReportSelector);\n    fixture.detectChanges();\n    loader = TestbedHarnessEnvironment.loader(fixture);\n  });\n\n  it('should switch to bug report template', async () => {\n    expect(fixture.debugElement.query('bug-report-form')).toBeNull();\n    const select = await loader.getHarness(MatSelectHarness);\n    await select.open();\n    const bugOption = await select.getOption({text: 'Bug'});\n    await bugOption.click();\n    expect(fixture.debugElement.query('bug-report-form')).not.toBeNull();\n  });\n});\n\n```\n\n### [link](https://material.angular.io/guide/using-component-harnesses\\#tests-that-are-easier-to-read-and-understand)  Tests that are easier to read and understand\n\nThe code above shows that adopting the harnesses in tests can make them easier to understand.\nSpecifically in this example, it makes the \"open the mat-select\" logic more obvious. An unfamiliar\nreader may not know what clicking on `.mat-select-trigger` does, but `await select.open()` is\nself-explanatory.\n\nThe harnesses also make clear which option should be selected. Without the harness, you need a comment that\nexplains what `options[1]` means. With `MatSelectHarness`, however, the filter API makes the code\nself-documenting.\n\nFinally, the repeated calls to `detectChanges` and `whenStable()` can obfuscate the underlying\nintent of the test. By using the harness APIs, you eliminate these calls, making the test more\nconcise.\n\n### [link](https://material.angular.io/guide/using-component-harnesses\\#tests-that-are-more-robust)  Tests that are more robust\n\nNotice that the test without harnesses directly uses CSS selectors to query elements within\n`<mat-select>`, such as `.mat-select-trigger`. If the internal DOM of `<mat-select>` changes, these\nqueries may stop working. While the Angular team tries to minimize this type of change, some\nfeatures and bug fixes ultimately require restructuring the DOM. By using the Angular Material\nharnesses, you avoid depending on internal DOM structure directly.\n\nIn addition to DOM structure, component asynchronicity often offers a challenge when updating\ncomponents. If a component changes between synchronous and asynchronous, downstream unit tests may\nbreak due to expectations around timing. Tests then require the addition or removal of some\narcane combination of `whenStable`, `flushMicroTasks`, `tick`, or `detectChanges`. Component\nharnesses, however, avoid this problem by normalizing the asynchronicity of all component behaviors\nwith all asynchronous APIs. When a test uses these harnesses, changes to asynchronicity become\nfar more manageable.\n\nBoth DOM structure and asynchronicity are _implementation details_ of Angular Material's components.\nWhen tests depend on the implementation details, they become a common source of failures due to\nlibrary changes. Angular CDK's test harnesses makes component library updates easier for both\napplication authors and the Angular team, as the Angular team only has to update the harness once\nfor everyone.\n\nGuide Content\n\nAzure & Blue theme selected.\n\nSelect a version of the documentation\n\nSelect a theme for the documentation",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-0a04358c-0fef-465e-8224-a594cf8d76ee.png"
  },
  "metadata": {
    "theme-color": "#d7e3ff",
    "og:locale": "en_US",
    "language": "en-US",
    "og:image:height": "943",
    "favicon": "https://material.angular.io/guide/assets/img/favicon.ico?v=19.1.0",
    "og:type": "website",
    "og:image:width": "1339",
    "og:image:secure_url": "https://material.angular.io/assets/img/site-preview.png",
    "og:title": "Angular Material",
    "og:description": "UI component infrastructure and Material Design components for Angular web applications.",
    "ogImage": "https://material.angular.io/assets/img/site-preview.png",
    "twitter:site": "@Angular",
    "twitter:title": "Angular Material",
    "og:image:type": "image/png",
    "og:site_name": "Angular Material",
    "mobile-web-app-capable": "yes",
    "ogLocale": "en_US",
    "ogTitle": "Angular Material",
    "ogSiteName": "Angular Material",
    "og:url": "https://material.angular.io/",
    "ogDescription": "UI component infrastructure and Material Design components for Angular web applications.",
    "apple-mobile-web-app-status-bar-style": "translucent",
    "keywords": "angular, material design, material, angular material, web, ui, components, responsive, accessibility, typescript, css, mobile web, open source",
    "twitter:description": "UI component infrastructure and Material Design components for Angular web applications.",
    "ogUrl": "https://material.angular.io/",
    "og:image": "https://material.angular.io/assets/img/site-preview.png",
    "viewport": "width=device-width, initial-scale=1",
    "title": "Testing with component harnesses | Angular Material",
    "twitter:creator": "@Angular",
    "description": "UI component infrastructure and Material Design components for mobile and desktop Angular web applications.",
    "author": "Angular Components Team",
    "twitter:image": "https://material.angular.io/assets/img/site-preview.png",
    "apple-mobile-web-app-capable": "yes",
    "twitter:card": "summary",
    "scrapeId": "9aead749-d334-4721-8b36-6d43d750c7fb",
    "sourceURL": "https://material.angular.io/guide/using-component-harnesses",
    "url": "https://material.angular.io/guide/using-component-harnesses",
    "statusCode": 200
  }
}