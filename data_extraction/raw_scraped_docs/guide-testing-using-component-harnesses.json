{
  "scrapeId": "d99a5531-4542-4406-9ed4-247fc4914be5",
  "sourceURL": "https://angular.dev/guide/testing/using-component-harnesses",
  "statusCode": 200,
  "data": {
    "markdown": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! ðŸš€](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backTesting\n  - [Overview](https://angular.dev/guide/testing)\n  - [Code coverage](https://angular.dev/guide/testing/code-coverage)\n  - [Testing services](https://angular.dev/guide/testing/services)\n  - [Basics of testing components](https://angular.dev/guide/testing/components-basics)\n  - [Component testing scenarios](https://angular.dev/guide/testing/components-scenarios)\n  - [Testing attribute directives](https://angular.dev/guide/testing/attribute-directives)\n  - [Testing pipes](https://angular.dev/guide/testing/pipes)\n  - [Debugging tests](https://angular.dev/guide/testing/debugging)\n  - [Testing utility APIs](https://angular.dev/guide/testing/utility-apis)\n  - [Component harnesses overview](https://angular.dev/guide/testing/component-harnesses-overview)\n  - [Using component harnesses in tests](https://angular.dev/guide/testing/using-component-harnesses)\n  - [Creating harnesses for your components](https://angular.dev/guide/testing/creating-component-harnesses)\n  - [Adding harness support for additional testing environments](https://angular.dev/guide/testing/component-harnesses-testing-environments)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\n## [Before you start](https://angular.dev/guide/testing/using-component-harnesses\\#before-you-start)\n\n**TIP:** This guide assumes you've already read the [component harnesses overview guide](https://angular.dev/guide/testing/guide/testing/component-harnesses-overview). Read that first if you're new to using component harnesses.\n\n### [CDK Installation](https://angular.dev/guide/testing/using-component-harnesses\\#cdk-installation)\n\nThe [Component Dev Kit (CDK)](https://material.angular.io/cdk/categories) is a set of behavior primitives for building components. To use the component harnesses, first install `@angular/cdk` from npm. You can do this from your terminal using the Angular CLI:\n\n```\n      ng add @angular/cdk\n\n```\n\ncheck\n\n## [Test harness environments and loaders](https://angular.dev/guide/testing/using-component-harnesses\\#test-harness-environments-and-loaders)\n\nYou can use component test harnesses in different test environments. Angular CDK supports two built-in environments:\n\n- Unit tests with Angular's `TestBed`\n- End-to-end tests with [WebDriver](https://developer.mozilla.org/en-US/docs/Web/WebDriver)\n\nEach environment provides a **harness loader**. The loader creates the harness instances you use throughout your tests. See below for more specific guidance on supported testing environments.\n\nAdditional testing environments require custom bindings. See the [adding harness support for additional testing environments guide](https://angular.dev/guide/testing/guide/testing/component-harnesses-testing-environments) for more information.\n\n### [Using the loader from `TestbedHarnessEnvironment` for unit tests](https://angular.dev/guide/testing/using-component-harnesses\\#using-the-loader-from-testbedharnessenvironment-for-unit-tests)\n\nFor unit tests you can create a harness loader from [TestbedHarnessEnvironment](https://material.angular.io/cdk/testing/api#TestbedHarnessEnvironment). This environment uses a [component fixture](https://angular.dev/guide/testing/api/core/testing/ComponentFixture) created by Angular's `TestBed`.\n\nTo create a harness loader rooted at the fixture's root element, use the `loader()` method:\n\n```\n      const fixture = TestBed.createComponent(MyComponent);// Create a harness loader from the fixtureconst loader = TestbedHarnessEnvironment.loader(fixture);...// Use the loader to get harness instancesconst myComponentHarness = await loader.getHarness(MyComponent);\n\n```\n\ncheck\n\nTo create a harness loader for harnesses for elements that fall outside the fixture, use the `documentRootLoader()` method. For example, code that displays a floating element or pop-up often attaches DOM elements directly to the document body, such as the `Overlay` service in Angular CDK.\n\nYou can also create a harness loader directly with `harnessForFixture()` for a harness at that fixture's root element directly.\n\n### [Using the loader from `SeleniumWebDriverHarnessEnvironment` for end-to-end tests](https://angular.dev/guide/testing/using-component-harnesses\\#using-the-loader-from-seleniumwebdriverharnessenvironment-for-end-to-end-tests)\n\nFor WebDriver-based end-to-end tests you can create a harness loader with `SeleniumWebDriverHarnessEnvironment`.\n\nUse the `loader()` method to get the harness loader instance for the current HTML document, rooted at the document's root element. This environment uses a WebDriver client.\n\n```\n      let wd: webdriver.WebDriver = getMyWebDriverClient();const loader = SeleniumWebDriverHarnessEnvironment.loader(wd);...const myComponentHarness = await loader.getHarness(MyComponent);\n\n```\n\ncheck\n\n## [Using a harness loader](https://angular.dev/guide/testing/using-component-harnesses\\#using-a-harness-loader)\n\nHarness loader instances correspond to a specific DOM element and are used to create component harness instances for elements under that specific element.\n\nTo get `ComponentHarness` for the first instance of the element, use the `getHarness()` method. To get all `ComponentHarness` instances, use the `getAllHarnesses()` method.\n\n```\n      // Get harness for first instance of the elementconst myComponentHarness = await loader.getHarness(MyComponent);// Get harnesses for all instances of the elementconst myComponentHarnesses = await loader.getHarnesses(MyComponent);\n\n```\n\ncheck\n\nAs an example, consider a reusable dialog-button component that opens a dialog on click. It contains the following components, each with a corresponding harness:\n\n- `MyDialogButton` (composes the `MyButton` and `MyDialog` with a convenient API)\n- `MyButton` (a standard button component)\n- `MyDialog` (a dialog appended to `document.body` by `MyDialogButton` upon click)\n\nThe following test loads harnesses for each of these components:\n\n```\n      let fixture: ComponentFixture<MyDialogButton>;let loader: HarnessLoader;let rootLoader: HarnessLoader;beforeEach(() => {  fixture = TestBed.createComponent(MyDialogButton);  loader = TestbedHarnessEnvironment.loader(fixture);  rootLoader = TestbedHarnessEnvironment.documentRootLoader(fixture);});it('loads harnesses', async () => {  // Load a harness for the bootstrapped component with `harnessForFixture`  dialogButtonHarness =      await TestbedHarnessEnvironment.harnessForFixture(fixture, MyDialogButtonHarness);  // The button element is inside the fixture's root element, so we use `loader`.  const buttonHarness = await loader.getHarness(MyButtonHarness);  // Click the button to open the dialog  await buttonHarness.click();  // The dialog is appended to `document.body`, outside of the fixture's root element,  // so we use `rootLoader` in this case.  const dialogHarness = await rootLoader.getHarness(MyDialogHarness);  // ... make some assertions});\n\n```\n\ncheck\n\n### [Harness behavior in different environments](https://angular.dev/guide/testing/using-component-harnesses\\#harness-behavior-in-different-environments)\n\nHarnesses may not behave exactly the same in all environments. Some differences are unavoidable between the real user interaction versus the simulated events generated in unit tests. Angular CDK makes a best effort to normalize the behavior to the extent possible.\n\n### [Interacting with child elements](https://angular.dev/guide/testing/using-component-harnesses\\#interacting-with-child-elements)\n\nTo interact with elements below the root element of this harness loader, use the `HarnessLoader` instance of a child element. For the first instance of the child element, use the `getChildLoader()` method. For all instances of the child element, use the `getAllChildLoaders()` method.\n\n```\n      const myComponentHarness = await loader.getHarness(MyComponent);// Get loader for first instance of child element with '.child' selectorconst childLoader = await myComponentHarness.getLoader('.child');// Get loaders for all instances of child elements with '.child' selectorconst allChildLoaders = await myComponentHarness.getAllChildLoaders('.child');\n\n```\n\ncheck\n\n### [Filtering harnesses](https://angular.dev/guide/testing/using-component-harnesses\\#filtering-harnesses)\n\nWhen a page contains multiple instances of a particular component, you may want to filter based on some property of the component to get a particular component instance. You can use a **harness predicate**, a class used to associate a `ComponentHarness` class with predicates functions that can be used to filter component instances, to do so.\n\nWhen you ask a `HarnessLoader` for a harness, you're actually providing a HarnessQuery. A query can be one of two things:\n\n- A harness constructor. This just gets that harness\n- A `HarnessPredicate`, which gets harnesses that are filtered based on one or more conditions\n\n`HarnessPredicate` does support some base filters (selector, ancestor) that work on anything that extends `ComponentHarness`.\n\n```\n      // Example of loading a MyButtonComponentHarness with a harness predicateconst disabledButtonPredicate = new HarnessPredicate(MyButtonComponentHarness, {selector: '[disabled]'});const disabledButton = await loader.getHarness(disabledButtonPredicate);\n\n```\n\ncheck\n\nHowever it's common for harnesses to implement a static `with()` method that accepts component-specific filtering options and returns a `HarnessPredicate`.\n\n```\n      // Example of loading a MyButtonComponentHarness with a specific selectorconst button = await loader.getHarness(MyButtonComponentHarness.with({selector: 'btn'}))\n\n```\n\ncheck\n\nFor more details refer to the specific harness documentation since additional filtering options are specific to each harness implementation.\n\n## [Using test harness APIs](https://angular.dev/guide/testing/using-component-harnesses\\#using-test-harness-apis)\n\nWhile every harness defines an API specific to its corresponding component, they all share a common base class, [ComponentHarness](https://material.angular.io/cdk/testing/api#ComponentHarness). This base class defines a static property, `hostSelector`, that matches the harness class to instances of the component in the DOM.\n\nBeyond that, the API of any given harness is specific to its corresponding component; refer to the component's documentation to learn how to use a specific harness.\n\nAs an example, the following is a test for a component that uses the [Angular Material slider component harness](https://material.angular.io/components/slider/api#MatSliderHarness):\n\n```\n      it('should get value of slider thumb', async () => {    const slider = await loader.getHarness(MatSliderHarness);    const thumb = await slider.getEndThumb();    expect(await thumb.getValue()).toBe(50);});\n\n```\n\ncheck\n\n## [Interop with Angular change detection](https://angular.dev/guide/testing/using-component-harnesses\\#interop-with-angular-change-detection)\n\nBy default, test harnesses runs Angular's [change detection](https://angular.dev/best-practices/runtime-performance) before reading the state of a DOM element and after interacting with a DOM element.\n\nThere may be times that you need finer-grained control over change detection in your tests. such as checking the state of a component while an async operation is pending. In these cases use the `manualChangeDetection` function to disable automatic handling of change detection for a block of code.\n\n```\n      it('checks state while async action is in progress', async () => {  const buttonHarness = loader.getHarness(MyButtonHarness);  await manualChangeDetection(async () => {    await buttonHarness.click();    fixture.detectChanges();    // Check expectations while async click operation is in progress.    expect(isProgressSpinnerVisible()).toBe(true);    await fixture.whenStable();    // Check expectations after async click operation complete.    expect(isProgressSpinnerVisible()).toBe(false);  });});\n\n```\n\ncheck\n\nAlmost all harness methods are asynchronous and return a `Promise` to support the following:\n\n- Support for unit tests\n- Support for end-to-end tests\n- Insulate tests against changes in asynchronous behavior\n\nThe Angular team recommends using [await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) to improve the test readability. Calling `await` blocks the execution of your test until the associated `Promise` resolves.\n\nOccasionally, you may want to perform multiple actions simultaneously and wait until they're all done rather than performing each action sequentially. For example, read multiple properties of a single component. In these situations use the `parallel` function to parallelize the operations. The parallel function works similarly to `Promise.all`, while also optimizing change detection checks.\n\n```\n      it('reads properties in parallel', async () => {  const checkboxHarness = loader.getHarness(MyCheckboxHarness);  // Read the checked and intermediate properties simultaneously.  const [checked, indeterminate] = await parallel(() => [    checkboxHarness.isChecked(),    checkboxHarness.isIndeterminate()  ]);  expect(checked).toBe(false);  expect(indeterminate).toBe(true);});\n\n```\n\ncheck",
    "screenshot": "https://service.firecrawl.dev/storage/v1/object/public/media/screenshot-33bce81d-a0f2-4e0a-9351-a7c0d4f931ad.png"
  },
  "metadata": {
    "favicon": "https://angular.dev/assets/icons/favicon-48x48.png",
    "ogDescription": "The web development framework for building modern apps.",
    "og:title": "Angular",
    "og:description": "The web development framework for building modern apps.",
    "msapplication-config": "/assets/icons/browserconfig.xml",
    "twitter:image": "https://angular.dev/assets/images/ng-image.jpg",
    "og:type": "website",
    "ogTitle": "Angular",
    "apple-mobile-web-app-title": "Angular",
    "ogUrl": "https://angular.dev/",
    "application-name": "Angular",
    "viewport": "width=device-width, initial-scale=1",
    "ogImage": "https://angular.dev/assets/images/ng-image.jpg",
    "theme-color": "#ffffff",
    "twitter:card": "summary_large_image",
    "twitter:url": "https://angular.dev/",
    "twitter:title": "Angular",
    "msapplication-TileColor": "#e90464",
    "description": "The web development framework for building modern apps.",
    "language": "en",
    "title": "Using component harnesses in tests â€¢ Angular",
    "og:url": "https://angular.dev/",
    "og:image": "https://angular.dev/assets/images/ng-image.jpg",
    "twitter:description": "The web development framework for building modern apps.",
    "scrapeId": "d99a5531-4542-4406-9ed4-247fc4914be5",
    "sourceURL": "https://angular.dev/guide/testing/using-component-harnesses",
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "statusCode": 200
  }
}