{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backDependency Injection\n  - [Overview](https://angular.dev/guide/di)\n  - [Understanding dependency injection](https://angular.dev/guide/di/dependency-injection)\n  - [Creating an injectable service](https://angular.dev/guide/di/creating-injectable-service)\n  - [Defining dependency providers](https://angular.dev/guide/di/dependency-injection-providers)\n  - [Injection context](https://angular.dev/guide/di/dependency-injection-context)\n  - [Hierarchical injectors](https://angular.dev/guide/di/hierarchical-dependency-injection)\n  - [Optimizing injection tokens](https://angular.dev/guide/di/lightweight-injection-tokens)\n  - [DI in action](https://angular.dev/guide/di/di-in-action)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nThis page provides a conceptual overview of a dependency injection technique that is recommended for library developers.\nDesigning your library with _lightweight injection tokens_ helps optimize the bundle size of client applications that use your library.\n\nYou can manage the dependency structure among your components and injectable services to optimize bundle size by using tree-shakable providers.\nThis normally ensures that if a provided component or service is never actually used by the application, the compiler can remove its code from the bundle.\n\nDue to the way Angular stores injection tokens, it is possible that such an unused component or service can end up in the bundle anyway.\nThis page describes a dependency injection design pattern that supports proper tree-shaking by using lightweight injection tokens.\n\nThe lightweight injection token design pattern is especially important for library developers.\nIt ensures that when an application uses only some of your library's capabilities, the unused code can be eliminated from the client's application bundle.\n\nWhen an application uses your library, there might be some services that your library supplies which the client application doesn't use.\nIn this case, the application developer should expect that service to be tree-shaken, and not contribute to the size of the compiled application.\nBecause the application developer cannot know about or remedy a tree-shaking problem in the library, it is the responsibility of the library developer to do so.\nTo prevent the retention of unused components, your library should use the lightweight injection token design pattern.\n\n## [When tokens are retained](https://angular.dev/guide/di/lightweight-injection-tokens\\#when-tokens-are-retained)\n\nTo better explain the condition under which token retention occurs, consider a library that provides a library-card component.\nThis component contains a body and can contain an optional header:\n\n```\n      <lib-card>;  <lib-header>\u2026</lib-header>;</lib-card>;\n\n```\n\ncheck\n\nIn a likely implementation, the `<lib-card>` component uses `@ContentChild()` or `@ContentChildren()` to get `<lib-header>` and `<lib-body>`, as in the following:\n\n```\n      @Component({  selector: 'lib-header',  \u2026,})class LibHeaderComponent {}@Component({  selector: 'lib-card',  \u2026,})class LibCardComponent {  @ContentChild(LibHeaderComponent) header: LibHeaderComponent|null = null;}\n\n```\n\ncheck\n\nBecause `<lib-header>` is optional, the element can appear in the template in its minimal form, `<lib-card></lib-card>`.\nIn this case, `<lib-header>` is not used and you would expect it to be tree-shaken, but that is not what happens.\nThis is because `LibCardComponent` actually contains two references to the `LibHeaderComponent`:\n\n```\n      @ContentChild(LibHeaderComponent) header: LibHeaderComponent;\n\n```\n\ncheck\n\n- One of these reference is in the _type position_\\-\\- that is, it specifies `LibHeaderComponent` as a type: `header: LibHeaderComponent;`.\n- The other reference is in the _value position_\\-\\- that is, LibHeaderComponent is the value of the `@ContentChild()` parameter decorator: `@ContentChild(LibHeaderComponent)`.\n\nThe compiler handles token references in these positions differently:\n\n- The compiler erases _type position_ references after conversion from TypeScript, so they have no impact on tree-shaking.\n- The compiler must keep _value position_ references at runtime, which **prevents** the component from being tree-shaken.\n\nIn the example, the compiler retains the `LibHeaderComponent` token that occurs in the value position.\nThis prevents the referenced component from being tree-shaken, even if the application does not actually use `<lib-header>` anywhere.\nIf `LibHeaderComponent` 's code, template, and styles combine to become too large, including it unnecessarily can significantly increase the size of the client application.\n\n## [When to use the lightweight injection token pattern](https://angular.dev/guide/di/lightweight-injection-tokens\\#when-to-use-the-lightweight-injection-token-pattern)\n\nThe tree-shaking problem arises when a component is used as an injection token.\nThere are two cases when that can happen:\n\n- The token is used in the value position of a [content query](https://angular.dev/guide/di/guide/components/queries#content-queries).\n- The token is used as a type specifier for constructor injection.\n\nIn the following example, both uses of the `OtherComponent` token cause retention of `OtherComponent`, preventing it from being tree-shaken when it is not used:\n\n```\n      class MyComponent {  constructor(@Optional() other: OtherComponent) {}  @ContentChild(OtherComponent) other: OtherComponent|null;}\n\n```\n\ncheck\n\nAlthough tokens used only as type specifiers are removed when converted to JavaScript, all tokens used for dependency injection are needed at runtime.\nThese effectively change `constructor(@Optional() other: OtherComponent)` to `constructor(@Optional() @Inject(OtherComponent) other)`.\nThe token is now in a value position, which causes the tree-shaker to keep the reference.\n\n**HELPFUL:** Libraries should use [tree-shakable providers](https://angular.dev/guide/di/guide/di/dependency-injection#providing-dependency) for all services, providing dependencies at the root level rather than in components or modules.\n\n## [Using lightweight injection tokens](https://angular.dev/guide/di/lightweight-injection-tokens\\#using-lightweight-injection-tokens)\n\nThe lightweight injection token design pattern consists of using a small abstract class as an injection token, and providing the actual implementation at a later stage.\nThe abstract class is retained, not tree-shaken, but it is small and has no material impact on the application size.\n\nThe following example shows how this works for the `LibHeaderComponent`:\n\n```\n      abstract class LibHeaderToken {}@Component({  selector: 'lib-header',  providers: [    {provide: LibHeaderToken, useExisting: LibHeaderComponent}  ]  \u2026,})class LibHeaderComponent extends LibHeaderToken {}@Component({  selector: 'lib-card',  \u2026,})class LibCardComponent {  @ContentChild(LibHeaderToken) header: LibHeaderToken|null = null;}\n\n```\n\ncheck\n\nIn this example, the `LibCardComponent` implementation no longer refers to `LibHeaderComponent` in either the type position or the value position.\nThis lets full tree-shaking of `LibHeaderComponent` take place.\nThe `LibHeaderToken` is retained, but it is only a class declaration, with no concrete implementation.\nIt is small and does not materially impact the application size when retained after compilation.\n\nInstead, `LibHeaderComponent` itself implements the abstract `LibHeaderToken` class.\nYou can safely use that token as the provider in the component definition, allowing Angular to correctly inject the concrete type.\n\nTo summarize, the lightweight injection token pattern consists of the following:\n\n1. A lightweight injection token that is represented as an abstract class.\n2. A component definition that implements the abstract class.\n3. Injection of the lightweight pattern, using `@ContentChild()` or `@ContentChildren()`.\n4. A provider in the implementation of the lightweight injection token which associates the lightweight injection token with the implementation.\n\n### [Use the lightweight injection token for API definition](https://angular.dev/guide/di/lightweight-injection-tokens\\#use-the-lightweight-injection-token-for-api-definition)\n\nA component that injects a lightweight injection token might need to invoke a method in the injected class.\nThe token is now an abstract class. Since the injectable component implements that class, you must also declare an abstract method in the abstract lightweight injection token class.\nThe implementation of the method, with all its code overhead, resides in the injectable component that can be tree-shaken.\nThis lets the parent communicate with the child, if it is present, in a type-safe manner.\n\nFor example, the `LibCardComponent` now queries `LibHeaderToken` rather than `LibHeaderComponent`.\nThe following example shows how the pattern lets `LibCardComponent` communicate with the `LibHeaderComponent` without actually referring to `LibHeaderComponent`:\n\n```\n      abstract class LibHeaderToken {  abstract doSomething(): void;}@Component({  selector: 'lib-header',  providers: [    {provide: LibHeaderToken, useExisting: LibHeaderComponent}  ]  \u2026,})class LibHeaderComponent extends LibHeaderToken {  doSomething(): void {    // Concrete implementation of `doSomething`  }}@Component({  selector: 'lib-card',  \u2026,})class LibCardComponent implement AfterContentInit {  @ContentChild(LibHeaderToken) header: LibHeaderToken|null = null;  ngAfterContentInit(): void {    if (this.header !== null) {      this.header?.doSomething();    }  }}\n\n```\n\ncheck\n\nIn this example, the parent queries the token to get the child component, and stores the resulting component reference if it is present.\nBefore calling a method in the child, the parent component checks to see if the child component is present.\nIf the child component has been tree-shaken, there is no runtime reference to it, and no call to its method.\n\n### [Naming your lightweight injection token](https://angular.dev/guide/di/lightweight-injection-tokens\\#naming-your-lightweight-injection-token)\n\nLightweight injection tokens are only useful with components.\nThe Angular style guide suggests that you name components using the \"Component\" suffix.\nThe example \"LibHeaderComponent\" follows this convention.\n\nYou should maintain the relationship between the component and its token while still distinguishing between them.\nThe recommended style is to use the component base name with the suffix \" `Token`\" to name your lightweight injection tokens: \" `LibHeaderToken`.\"",
  "title": "Optimizing injection tokens \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "injection",
    "angular",
    "https",
    "token",
    "component",
    "dev",
    "lightweight",
    "libheadercomponent",
    "guide",
    "class"
  ],
  "sourceURL": "https://angular.dev/guide/di/lightweight-injection-tokens"
}