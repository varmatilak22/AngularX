{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backExperimental features\n  - [Zoneless](https://angular.dev/guide/experimental/zoneless)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\n## [Why use Zoneless?](https://angular.dev/guide/experimental/zoneless\\#why-use-zoneless)\n\nThe main advantages to removing ZoneJS as a dependency are:\n\n- **Improved performance**: ZoneJS uses DOM events and async tasks as indicators of when application state _might_ have updated and subsequently triggers application synchronization to run change detection on the application's views. ZoneJS does not have any insight into whether application state actually changed and so this synchronization is triggered more frequently than necessary.\n- **Improved Core Web Vitals**: ZoneJS brings a fair amount of overhead, both in payload size and in startup time cost.\n- **Improved debugging experience**: ZoneJS makes debugging code more difficult. Stack traces are harder to understand with ZoneJS. It's also difficult to understand when code breaks as a result of being outside the Angular Zone.\n- **Better ecosystem compatibility**: ZoneJS works by patching browser APIs but does not automatically have patches for every new browser API. Some APIs cannot be patched effectively, such as `async`/ `await`, and have to be downleveled to work with ZoneJS. Sometimes libraries in the ecosystem are also incompatible with the way ZoneJS patches the native APIs. Removing ZoneJS as a dependency ensures better long-term compatibility by removing a source of complexity, monkey patching, and ongoing maintenance.\n\n## [Enabling Zoneless in an application](https://angular.dev/guide/experimental/zoneless\\#enabling-zoneless-in-an-application)\n\nThe API for enabling Zoneless is currently experimental. Neither the shape, nor the underlying behavior is stable and can change\nin patch versions. There are known feature gaps, including the lack of an ergonomic API which prevents the application from serializing too early with Server Side Rendering.\n\n```\n      // standalone bootstrapbootstrapApplication(MyApp, {providers: [  provideExperimentalZonelessChangeDetection(),]});// NgModule bootstrapplatformBrowser().bootstrapModule(AppModule);@NgModule({  providers: [provideExperimentalZonelessChangeDetection()]})export class AppModule {}\n\n```\n\ncheck\n\n## [Removing ZoneJS](https://angular.dev/guide/experimental/zoneless\\#removing-zonejs)\n\nZoneless applications should remove ZoneJS entirely from the build to reduce bundle size. ZoneJS is typically\nloaded via the `polyfills` option in `angular.json`, both in the `build` and `test` targets. Remove `zone.js`\nand `zone.js/testing` from both to remove it from the build. Projects which use an explicit `polyfills.ts` file\nshould remove `import 'zone.js';` and `import 'zone.js/testing';` from the file.\n\nAfter removing ZoneJS from the build, there is no longer a need for a `zone.js` dependency either and the\npackage can be removed entirely:\n\n```\n      npm uninstall zone.js\n\n```\n\ncheck\n\n## [Requirements for Zoneless compatibility](https://angular.dev/guide/experimental/zoneless\\#requirements-for-zoneless-compatibility)\n\nAngular relies on notifications from core APIs in order to determine when to run change detection and on which views.\nThese notifications include:\n\n- `ChangeDetectorRef.markForCheck` (called automatically by `AsyncPipe`)\n- `ComponentRef.setInput`\n- Updating a signal that's read in a template\n- Bound host or template listeners callbacks\n- Attaching a view that was marked dirty by one of the above\n\n### [`OnPush`-compatible components](https://angular.dev/guide/experimental/zoneless\\#onpush-compatible-components)\n\nOne way to ensure that a component is using the correct notification mechanisms from above is to\nuse [ChangeDetectionStrategy.OnPush](https://angular.dev/best-practices/skipping-subtrees#using-onpush).\n\nThe `OnPush` change detection strategy is not required, but it is a recommended step towards zoneless compatibility for application components. It is not always possible for library components to use `ChangeDetectionStrategy.OnPush`.\nWhen a library component is a host for user-components which might use `ChangeDetectionStrategy.Default`, it cannot use `OnPush` because that would prevent the child component from being refreshed if it is not `OnPush` compatible and relies on ZoneJS to trigger change detection. Components can use the `Default` strategy as long as they notify Angular when change detection needs to run (calling `markForCheck`, using signals, `AsyncPipe`, etc.).\nBeing a host for a user component means using an API such as `ViewContainerRef.createComponent` and not just hosting a portion of a template from a user component (i.e. content projection or a using a template ref input).\n\n### [Remove `NgZone.onMicrotaskEmpty`, `NgZone.onUnstable`, `NgZone.isStable`, or `NgZone.onStable`](https://angular.dev/guide/experimental/zoneless\\#remove-ngzoneonmicrotaskempty-ngzoneonunstable-ngzoneisstable-or-ngzoneonstable)\n\nApplications and libraries need to remove uses of `NgZone.onMicrotaskEmpty`, `NgZone.onUnstable` and `NgZone.onStable`.\nThese observables will never emit when an Application enables zoneless change detection.\nSimilarly, `NgZone.isStable` will always be `true` and should not be used as a condition for code execution.\n\nThe `NgZone.onMicrotaskEmpty` and `NgZone.onStable` observables are most often used to wait for Angular to\ncomplete change detection before performing a task. Instead, these can be replaced by `afterNextRender`\nif they need to wait for a single change detection or `afterRender` if there is some condition that might span\nseveral change detection rounds. In other cases, these observables were used because they happened to be\nfamiliar and have similar timing to what was needed. More straightforward or direct DOM APIs can be used instead,\nsuch as `MutationObserver` when code needs to wait for certain DOM state (rather than waiting for it indirectly\nthrough Angular's render hooks).\n\n### NgZone.run and NgZone.runOutsideAngular are compatible with Zoneless\n\n`NgZone.run` and `NgZone.runOutsideAngular` do not need to be removed in order for code to be compatible with\nZoneless applications. In fact, removing these calls can lead to performance regressions for libraries that\nare used in applications that still rely on ZoneJS.\n\n### [`PendingTasks` for Server Side Rendering (SSR)](https://angular.dev/guide/experimental/zoneless\\#pendingtasks-for-server-side-rendering-ssr)\n\nIf you are using SSR with Angular, you may know that it relies on ZoneJS to help determine when the application\nis \"stable\" and can be serialized. If there are asynchronous tasks that should prevent serialization, an application\nnot using ZoneJS must make Angular aware of these with the [PendingTasks](https://angular.dev/api/core/PendingTasks) service. Serialization\nwill wait for the first moment that all pending tasks have been removed.\n\nThe two most straightforward uses of pending tasks are the `run` method:\n\n```\n      const taskService = inject(PendingTasks);taskService.run(async () => {  const someResult = await doSomeWorkThatNeedsToBeRendered();  this.someState.set(someResult);});\n\n```\n\ncheck\n\nFor more complicated use-cases, you can manuall add and remove a pending tasks:\n\n```\n      const taskService = inject(PendingTasks);const taskCleanup = taskService.add();try {  await doSomeWorkThatNeedsToBeRendered();} catch {  // handle error} finally {  taskCleanup();}\n\n```\n\ncheck\n\nIn addition, the [pendingUntilEvent](https://angular.dev/api/core/rxjs-interop/pendingUntilEvent#) helper in `rxjs-interop` ensures\nthe application remains unstable until the observable emits, complets, errors, or is unsubscribed.\n\n```\n      readonly myObservableState = someObservable.pipe(pendingUntilEvent());\n\n```\n\ncheck\n\nThe framework uses this service internally as well to prevent serialization until asynchronous tasks are complete. These include, but are not limited to,\nan ongoing Router navigation and an incomplete `HttpClient` request.\n\n## [Testing and Debugging](https://angular.dev/guide/experimental/zoneless\\#testing-and-debugging)\n\n### [Using Zoneless in `TestBed`](https://angular.dev/guide/experimental/zoneless\\#using-zoneless-in-testbed)\n\nThe zoneless provider function can also be used with `TestBed` to help\nensure the components under test are compatible with a Zoneless\nAngular application.\n\n```\n      TestBed.configureTestingModule({  providers: [provideExperimentalZonelessChangeDetection()]});const fixture = TestBed.createComponent(MyComponent);await fixture.whenStable();\n\n```\n\ncheck\n\nTo ensure tests have the most similar behavior to production code,\navoid using `fixture.detectChanges()` when possible. This forces\nchange detection to run when Angular might otherwise have not\nscheduled change detection. Tests should ensure these notifications\nare happening and allow Angular to handle when to synchronize\nstate rather than manually forcing it to happen in the test.\n\nFor existing test suites, using `fixture.detectChanges()` is a common pattern\nand it is likely not worth the effort of converting these to\n`await fixture.whenStable()`. `TestBed` will still enforce that the\nfixture's component is `OnPush` compatible and throws `ExpressionChangedAfterItHasBeenCheckedError`\nif it finds that template values were updated without a\nchange notification (i.e. `fixture.componentInstance.someValue = 'newValue';`).\nIf the component is used in production, this issue should be addressed by updating\nthe component to use signals for state or call `ChangeDetectorRef.markForCheck()`.\nIf the component is only used as a test wrapper and never used in an application,\nit is acceptable to use `fixture.changeDetectorRef.markForCheck()`.\n\n### [Debug-mode check to ensure updates are detected](https://angular.dev/guide/experimental/zoneless\\#debug-mode-check-to-ensure-updates-are-detected)\n\nAngular also provides an additional tool to help verify that an application is making\nupdates to state in a zoneless-compatible way. `provideExperimentalCheckNoChangesForDebug`\ncan be used to periodically check to ensure that no bindings have been updated\nwithout a notification. Angular throws `ExpressionChangedAfterItHasBeenCheckedError`\nif there is an updated binding that would not have refreshed by the zoneless change\ndetection.",
  "title": "Zoneless \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "angular",
    "https",
    "zoneless",
    "dev",
    "zonejs",
    "application",
    "change",
    "guide",
    "ngzone",
    "experimental"
  ],
  "sourceURL": "https://angular.dev/guide/experimental/zoneless"
}