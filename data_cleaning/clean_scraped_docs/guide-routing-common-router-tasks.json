{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backRouting\n  - [Overview](https://angular.dev/guide/routing)\n  - [Common routing tasks](https://angular.dev/guide/routing/common-router-tasks)\n  - [Routing in single-page applications](https://angular.dev/guide/routing/router-tutorial)\n  - [Creating custom route matches](https://angular.dev/guide/routing/routing-with-urlmatcher)\n  - [Router reference](https://angular.dev/guide/routing/router-reference)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nThis topic describes how to implement many of the common tasks associated with adding the Angular router to your application.\n\n## [Generate an application with routing enabled](https://angular.dev/guide/routing/common-router-tasks\\#generate-an-application-with-routing-enabled)\n\nThe following command uses the Angular CLI to generate a basic Angular application with application routes. The application name in the following example is `routing-app`.\n\n```\n      ng new routing-app\n\n```\n\ncheck\n\n### [Adding components for routing](https://angular.dev/guide/routing/common-router-tasks\\#adding-components-for-routing)\n\nTo use the Angular router, an application needs to have at least two components so that it can navigate from one to the other. To create a component using the CLI, enter the following at the command line where `first` is the name of your component:\n\n```\n      ng generate component first\n\n```\n\ncheck\n\nRepeat this step for a second component but give it a different name. Here, the new name is `second`.\n\n```\n      ng generate component second\n\n```\n\ncheck\n\nThe CLI automatically appends `Component`, so if you were to write `first-component`, your component would be `FirstComponentComponent`.\n\n### `base href`\n\nThis guide works with a CLI-generated Angular application. If you are working manually, make sure that you have `<base href=\"/\">` in the `<head>` of your index.html file.\nThis assumes that the `app` folder is the application root, and uses `\"/\"`.\n\n### [Importing your new components](https://angular.dev/guide/routing/common-router-tasks\\#importing-your-new-components)\n\nTo use your new components, import them into `app.routes.ts` at the top of the file, as follows:\n\n```\n      import {FirstComponent} from './first/first.component';import {SecondComponent} from './second/second.component';\n\n```\n\ncheck\n\n## [Defining a basic route](https://angular.dev/guide/routing/common-router-tasks\\#defining-a-basic-route)\n\nThere are three fundamental building blocks to creating a route.\n\nImport the routes into `app.config.ts` and add it to the `provideRouter` function. The following is the default `ApplicationConfig` using the CLI.\n\n```\n      export const appConfig: ApplicationConfig = {  providers: [provideRouter(routes)]};\n\n```\n\ncheck\n\nThe Angular CLI performs this step for you. However, if you are creating an application manually or working with an existing, non-CLI application, verify that the imports and configuration are correct.\n\n1. ### [Set up a `Routes` array for your routes](https://angular.dev/guide/routing/common-router-tasks\\#set-up-a-routes-array-for-your-routes)\n\n\nThe Angular CLI performs this step automatically.\n\n\n\n```\n         import { Routes } from '@angular/router';export const routes: Routes = [];\n\n```\n\ncheck\n\n2. ### [Define your routes in your `Routes` array](https://angular.dev/guide/routing/common-router-tasks\\#define-your-routes-in-your-routes-array)\n\n\nEach route in this array is a JavaScript object that contains two properties. The first property, `path`, defines the URL path for the route. The second property, `component`, defines the component Angular should use for the corresponding path.\n\n\n\n```\n         const routes: Routes = [  { path: 'first-component', component: FirstComponent },  { path: 'second-component', component: SecondComponent },];\n\n```\n\ncheck\n\n3. ### [Add your routes to your application](https://angular.dev/guide/routing/common-router-tasks\\#add-your-routes-to-your-application)\n\n\nNow that you have defined your routes, add them to your application. First, add links to the two components. Assign the anchor tag that you want to add the route to the `routerLink` attribute. Set the value of the attribute to the component to show when a user clicks on each link. Next, update your component template to include `<router-outlet>`. This element informs Angular to update the application view with the component for the selected route.\n\n\n\n```\n         <h1>Angular Router App</h1><nav>  <ul>    <li><a routerLink=\"/first-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">First Component</a></li>    <li><a routerLink=\"/second-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Second Component</a></li>  </ul></nav><!-- The routed views render in the <router-outlet>--><router-outlet />\n\n```\n\ncheck\n\nYou also need to add the `RouterLink`, `RouterLinkActive`, and `RouterOutlet` to the `imports` array of `AppComponent`.\n\n\n\n```\n         @Component({  selector: 'app-root',  imports: [RouterOutlet, RouterLink, RouterLinkActive],  templateUrl: './app.component.html',  styleUrls: ['./app.component.css']})export class AppComponent {  title = 'routing-app';}\n\n```\n\ncheck\n\n\n### [Route order](https://angular.dev/guide/routing/common-router-tasks\\#route-order)\n\nThe order of routes is important because the `Router` uses a first-match wins strategy when matching routes, so more specific routes should be placed above less specific routes.\nList routes with a static path first, followed by an empty path route, which matches the default route.\nThe [wildcard route](https://angular.dev/guide/routing/guide/routing/common-router-tasks#setting-up-wildcard-routes) comes last because it matches every URL and the `Router` selects it only if no other routes match first.\n\n## [Getting route information](https://angular.dev/guide/routing/common-router-tasks\\#getting-route-information)\n\nOften, as a user navigates your application, you want to pass information from one component to another.\nFor example, consider an application that displays a shopping list of grocery items.\nEach item in the list has a unique `id`.\nTo edit an item, users click an Edit button, which opens an `EditGroceryItem` component.\nYou want that component to retrieve the `id` for the grocery item so it can display the right information to the user.\n\nUse a route to pass this type of information to your application components.\nTo do so, you use the [withComponentInputBinding](https://angular.dev/guide/routing/api/router/withComponentInputBinding) feature with `provideRouter` or the `bindToComponentInputs` option of `RouterModule.forRoot`.\n\nTo get information from a route:\n\n1. ### [Add `withComponentInputBinding`](https://angular.dev/guide/routing/common-router-tasks\\#add-withcomponentinputbinding)\n\n\nAdd the `withComponentInputBinding` feature to the `provideRouter` method.\n\n\n\n```\n         providers: [  provideRouter(appRoutes, withComponentInputBinding()),]\n\n```\n\ncheck\n\n2. ### [Add an `Input` to the component](https://angular.dev/guide/routing/common-router-tasks\\#add-an-input-to-the-component)\n\n\nUpdate the component to have an `Input` matching the name of the parameter.\n\n\n\n```\n         @Input()set id(heroId: string) {  this.hero$ = this.service.getHero(heroId);}\n\n```\n\ncheck\n\nNOTE: You can bind all route data with key, value pairs to component inputs: static or resolved route data, path parameters, matrix parameters, and query parameters.\nIf you want to use the parent components route info you will need to set the router `paramsInheritanceStrategy` option:\n`withRouterConfig({paramsInheritanceStrategy: 'always'})`\n\n\n## [Setting up wildcard routes](https://angular.dev/guide/routing/common-router-tasks\\#setting-up-wildcard-routes)\n\nA well-functioning application should gracefully handle when users attempt to navigate to a part of your application that does not exist.\nTo add this functionality to your application, you set up a wildcard route.\nThe Angular router selects this route any time the requested URL doesn't match any router paths.\n\nTo set up a wildcard route, add the following code to your `routes` definition.\n\n```\n      { path: '**', component: <component-name> }\n\n```\n\ncheck\n\nThe two asterisks, `**`, indicate to Angular that this `routes` definition is a wildcard route.\nFor the component property, you can define any component in your application.\nCommon choices include an application-specific `PageNotFoundComponent`, which you can define to [display a 404 page](https://angular.dev/guide/routing/guide/routing/common-router-tasks#displaying-a-404-page) to your users; or a redirect to your application's main component.\nA wildcard route is the last route because it matches any URL.\nFor more detail on why order matters for routes, see [Route order](https://angular.dev/guide/routing/guide/routing/common-router-tasks#route-order).\n\n## [Displaying a 404 page](https://angular.dev/guide/routing/common-router-tasks\\#displaying-a-404-page)\n\nTo display a 404 page, set up a [wildcard route](https://angular.dev/guide/routing/guide/routing/common-router-tasks#setting-up-wildcard-routes) with the `component` property set to the component you'd like to use for your 404 page as follows:\n\n```\n      const routes: Routes = [  { path: 'first-component', component: FirstComponent },  { path: 'second-component', component: SecondComponent },  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page];\n\n```\n\ncheck\n\nThe last route with the `path` of `**` is a wildcard route.\nThe router selects this route if the requested URL doesn't match any of the paths earlier in the list and sends the user to the `PageNotFoundComponent`.\n\n## [Setting up redirects](https://angular.dev/guide/routing/common-router-tasks\\#setting-up-redirects)\n\nTo set up a redirect, configure a route with the `path` you want to redirect from, the `component` you want to redirect to, and a `pathMatch` value that tells the router how to match the URL.\n\n```\n      const routes: Routes = [  { path: 'first-component', component: FirstComponent },  { path: 'second-component', component: SecondComponent },  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page];\n\n```\n\ncheck\n\nIn this example, the third route is a redirect so that the router defaults to the `first-component` route.\nNotice that this redirect precedes the wildcard route.\nHere, `path: ''` means to use the initial relative URL ( `''`).\n\nSometimes a redirect is not a simple, static redirect. The `redirectTo` property can also be a function\nwith more complex logic that returns a string or `UrlTree`.\n\n```\n      const routes: Routes = [  { path: \"first-component\", component: FirstComponent },  {    path: \"old-user-page\",    redirectTo: ({ queryParams }) => {      const errorHandler = inject(ErrorHandler);      const userIdParam = queryParams['userId'];      if (userIdParam !== undefined) {        return `/user/${userIdParam}`;      } else {        errorHandler.handleError(new Error('Attempted navigation to user page without user ID.'));        return `/not-found`;      }    },  },  { path: \"user/:userId\", component: OtherComponent },];\n\n```\n\ncheck\n\n## [Nesting routes](https://angular.dev/guide/routing/common-router-tasks\\#nesting-routes)\n\nAs your application grows more complex, you might want to create routes that are relative to a component other than your root component.\nThese types of nested routes are called child routes.\nThis means you're adding a second `<router-outlet>` to your app, because it is in addition to the `<router-outlet>` in `AppComponent`.\n\nIn this example, there are two additional child components, `child-a`, and `child-b`.\nHere, `FirstComponent` has its own `<nav>` and a second `<router-outlet>` in addition to the one in `AppComponent`.\n\n```\n      <h2>First Component</h2><nav>  <ul>    <li><a routerLink=\"child-a\">Child A</a></li>    <li><a routerLink=\"child-b\">Child B</a></li>  </ul></nav><router-outlet />\n\n```\n\ncheck\n\nA child route is like any other route, in that it needs both a `path` and a `component`.\nThe one difference is that you place child routes in a `children` array within the parent route.\n\n```\n      const routes: Routes = [  {    path: 'first-component',    component: FirstComponent, // this is the component with the <router-outlet> in the template    children: [      {        path: 'child-a', // child route path        component: ChildAComponent, // child route component that the router renders      },      {        path: 'child-b',        component: ChildBComponent, // another child route component that the router renders      },    ],  },];\n\n```\n\ncheck\n\n## [Setting the page title](https://angular.dev/guide/routing/common-router-tasks\\#setting-the-page-title)\n\nEach page in your application should have a unique title so that they can be identified in the browser history.\nThe `Router` sets the document's title using the `title` property from the `Route` config.\n\n```\n      const routes: Routes = [  {    path: 'first-component',    title: 'First component',    component: FirstComponent,  // this is the component with the <router-outlet> in the template    children: [      {        path: 'child-a',  // child route path        title: resolvedChildATitle,        component: ChildAComponent,  // child route component that the router renders      },      {        path: 'child-b',        title: 'child b',        component: ChildBComponent,  // another child route component that the router renders      },    ],  },];const resolvedChildATitle: ResolveFn<string> = () => Promise.resolve('child a');\n\n```\n\ncheck\n\n**HELPFUL:** The `title` property follows the same rules as static route `data` and dynamic values that implement `ResolveFn`.\n\nYou can also provide a custom title strategy by extending the `TitleStrategy`.\n\n```\n      @Injectable({ providedIn: 'root' })export class TemplatePageTitleStrategy extends TitleStrategy {  private readonly title = inject(Title);  override updateTitle(routerState: RouterStateSnapshot) {    const title = this.buildTitle(routerState);    if (title !== undefined) {      this.title.setTitle(`My Application | ${title}`);    }  }}export const appConfig: ApplicationConfig = {  providers: [    provideRouter(routes),    { provide: TitleStrategy, useClass: TemplatePageTitleStrategy },  ]};\n\n```\n\ncheck\n\n## [Using relative paths](https://angular.dev/guide/routing/common-router-tasks\\#using-relative-paths)\n\nRelative paths let you define paths that are relative to the current URL segment.\nThe following example shows a relative route to another component, `second-component`.\n`FirstComponent` and `SecondComponent` are at the same level in the tree, however, the link to `SecondComponent` is situated within the `FirstComponent`, meaning that the router has to go up a level and then into the second directory to find the `SecondComponent`.\nRather than writing out the whole path to get to `SecondComponent`, use the `../` notation to go up a level.\n\n```\n      <h2>First Component</h2><nav>  <ul>    <li><a routerLink=\"../second-component\">Relative Route to second component</a></li>  </ul></nav><router-outlet />\n\n```\n\ncheck\n\nIn addition to `../`, use `./` or no leading slash to specify the current level.\n\n### [Specifying a relative route](https://angular.dev/guide/routing/common-router-tasks\\#specifying-a-relative-route)\n\nTo specify a relative route, use the `NavigationExtras` `relativeTo` property.\nIn the component class, import `NavigationExtras` from the `@angular/router`.\n\nThen use `relativeTo` in your navigation method.\nAfter the link parameters array, which here contains `items`, add an object with the `relativeTo` property set to the `ActivatedRoute`, which is `this.route`.\n\n```\n      goToItems() {  this.router.navigate(['items'], { relativeTo: this.route });}\n\n```\n\ncheck\n\nThe `navigate()` arguments configure the router to use the current route as a basis upon which to append `items`.\n\nThe `goToItems()` method interprets the destination URI as relative to the activated route and navigates to the `items` route.\n\n## [Accessing query parameters and fragments](https://angular.dev/guide/routing/common-router-tasks\\#accessing-query-parameters-and-fragments)\n\nSometimes, a feature of your application requires accessing a part of a route, such as a query parameter or a fragment.\nIn this example, the route contains an `id` parameter we can use to target a specific hero page.\n\n```\n      import { ApplicationConfig } from \"@angular/core\";import { Routes } from '@angular/router';import { HeroListComponent } from './hero-list.component';export const routes: Routes = [  { path: 'hero/:id', component: HeroDetailComponent }];export const appConfig: ApplicationConfig = {  providers: [provideRouter(routes)],};\n\n```\n\ncheck\n\nFirst, import the following members in the component you want to navigate from.\n\n```\n      import { inject } from '@angular/core';import { ActivatedRoute } from '@angular/router';import { Observable, switchMap } from 'rxjs';\n\n```\n\ncheck\n\nNext inject the activated route service:\n\n```\n      private readonly route = inject(ActivatedRoute);\n\n```\n\ncheck\n\nConfigure the class so that you have an observable, `heroes$`, a `selectedId` to hold the `id` number of the hero, and the heroes in the `ngOnInit()`, add the following code to get the `id` of the selected hero.\nThis code snippet assumes that you have a heroes list, a hero service, a function to get your heroes, and the HTML to render your list and details, just as in the Tour of Heroes example.\n\n```\n      heroes$: Observable<Hero[]>;selectedId: number;heroes = HEROES;ngOnInit() {  this.heroes$ = this.route.paramMap.pipe(    switchMap(params => {      this.selectedId = Number(params.get('id'));      return this.service.getHeroes();    })  );}\n\n```\n\ncheck\n\nNext, in the component that you want to navigate to, import the following members.\n\n```\n      import { Router, ActivatedRoute, ParamMap } from '@angular/router';import { Observable } from 'rxjs';\n\n```\n\ncheck\n\nInject `ActivatedRoute` and `Router` in the constructor of the component class so they are available to this component:\n\n```\n      private readonly route = inject(ActivatedRoute);private readonly router = inject(Router);hero$: Observable<Hero>;ngOnInit() {  const heroId = this.route.snapshot.paramMap.get('id');  this.hero$ = this.service.getHero(heroId);}gotoItems(hero: Hero) {  const heroId = hero ? hero.id : null;  // Pass along the hero id if available  // so that the HeroList component can select that item.  this.router.navigate(['/heroes', { id: heroId }]);}\n\n```\n\ncheck\n\n## [Lazy loading](https://angular.dev/guide/routing/common-router-tasks\\#lazy-loading)\n\nYou can configure your routes to lazy load modules, which means that Angular only loads modules as needed, rather than loading all modules when the application launches.\nAdditionally, preload parts of your application in the background to improve the user experience.\n\nAny route can lazily load its routed, standalone component by using `loadComponent:`\n\n### Lazy loading a standalone component\n\n```\n      const routes: Routes = [  {    path: 'lazy',    loadComponent: () => import('./lazy.component').then(c => c.LazyComponent)  }];\n\n```\n\ncheck\n\nThis works as long as the loaded component is standalone.\n\n## [Preventing unauthorized access](https://angular.dev/guide/routing/common-router-tasks\\#preventing-unauthorized-access)\n\nUse route guards to prevent users from navigating to parts of an application without authorization.\nThe following route guards are available in Angular:\n\nTo use route guards, consider using [component-less routes](https://angular.dev/guide/routing/api/router/Route#componentless-routes) as this facilitates guarding child routes.\n\nCreate a file for your guard:\n\n```\n      ng generate guard your-guard\n\n```\n\ncheck\n\nIn your guard file, add the guard functions you want to use.\nThe following example uses `canActivateFn` to guard the route.\n\n```\n      export const yourGuardFunction: CanActivateFn = (  next: ActivatedRouteSnapshot,  state: RouterStateSnapshot) => {  // your  logic goes here}\n\n```\n\ncheck\n\nIn your routing module, use the appropriate property in your `routes` configuration.\nHere, `canActivate` tells the router to mediate navigation to this particular route.\n\n```\n      {  path: '/your-path',  component: YourComponent,  canActivate: [yourGuardFunction],}\n\n```\n\ncheck\n\n## [Link parameters array](https://angular.dev/guide/routing/common-router-tasks\\#link-parameters-array)\n\nA link parameters array holds the following ingredients for router navigation:\n\n- The path of the route to the destination component\n- Required and optional route parameters that go into the route URL\n\nBind the `RouterLink` directive to such an array like this:\n\n```\n      <a [routerLink]=\"['/heroes']\">Heroes</a>\n\n```\n\ncheck\n\nThe following is a two-element array when specifying a route parameter:\n\n```\n      <a [routerLink]=\"['/hero', hero.id]\">  <span class=\"badge\">{{ hero.id }}</span>{{ hero.name }}</a>\n\n```\n\ncheck\n\nProvide optional route parameters in an object, as in `{ foo: 'foo' }`:\n\n```\n      <a [routerLink]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center</a>\n\n```\n\ncheck\n\nThese three examples cover the needs of an application with one level of routing.\nHowever, with a child router, such as in the crisis center, you create new link array possibilities.\n\nThe following minimal `RouterLink` example builds upon a specified default child route for the crisis center.\n\n```\n      <a [routerLink]=\"['/crisis-center']\">Crisis Center</a>\n\n```\n\ncheck\n\nReview the following:\n\n- The first item in the array identifies the parent route ( `/crisis-center`)\n- There are no parameters for this parent route\n- There is no default for the child route so you need to pick one\n- You're navigating to the `CrisisListComponent`, whose route path is `/`, but you don't need to explicitly add the slash\n\nConsider the following router link that navigates from the root of the application down to the Dragon Crisis:\n\n```\n      <a [routerLink]=\"['/crisis-center', 1]\">Dragon Crisis</a>\n\n```\n\ncheck\n\n- The first item in the array identifies the parent route ( `/crisis-center`)\n- There are no parameters for this parent route\n- The second item identifies the child route details about a particular crisis ( `/:id`)\n- The details child route requires an `id` route parameter\n- You added the `id` of the Dragon Crisis as the second item in the array ( `1`)\n- The resulting path is `/crisis-center/1`\n\nYou could also redefine the `AppComponent` template with Crisis Center routes exclusively:\n\n```\n      @Component({  template: `    <h1 class=\"title\">Angular Router</h1>    <nav>      <a [routerLink]=\"['/crisis-center']\">Crisis Center</a>      <a [routerLink]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis</a>      <a [routerLink]=\"['/crisis-center/2']\">Shark Crisis</a>    </nav>    <router-outlet />  `})export class AppComponent {}\n\n```\n\ncheck\n\nIn summary, you can write applications with one, two or more levels of routing.\nThe link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects.\n\n## [`LocationStrategy` and browser URL styles](https://angular.dev/guide/routing/common-router-tasks\\#locationstrategy-and-browser-url-styles)\n\nWhen the router navigates to a new component view, it updates the browser's location and history with a URL for that view.\n\nModern HTML5 browsers support [history.pushState](https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries \"HTML5\"), a technique that changes a browser's location and history without triggering a server page request.\nThe router can compose a \"natural\" URL that is indistinguishable from one that would otherwise require a page load.\n\nHere's the Crisis Center URL in this \"HTML5 pushState\" style:\n\n```\n      localhost:3002/crisis-center\n\n```\n\ncheck\n\nOlder browsers send page requests to the server when the location URL changes unless the change occurs after a \"#\" (called the \"hash\").\nRouters can take advantage of this exception by composing in-application route URLs with hashes.\nHere's a \"hash URL\" that routes to the Crisis Center.\n\n```\n      localhost:3002/src/#/crisis-center\n\n```\n\ncheck\n\nThe router supports both styles with two `LocationStrategy` providers:\n\n| Providers | Details |\n| :-- | :-- |\n| `PathLocationStrategy` | The default \"HTML5 pushState\" style. |\n| `HashLocationStrategy` | The \"hash URL\" style. |\n\nThe `RouterModule.forRoot()` function sets the `LocationStrategy` to the `PathLocationStrategy`, which makes it the default strategy.\nYou also have the option of switching to the `HashLocationStrategy` with an override during the bootstrapping process.\n\n**HELPFUL:** For more information on providers and the bootstrap process, see [Dependency Injection](https://angular.dev/guide/routing/guide/di/dependency-injection-providers).\n\n## [Choosing a routing strategy](https://angular.dev/guide/routing/common-router-tasks\\#choosing-a-routing-strategy)\n\nYou must choose a routing strategy early in the development of your project because once the application is in production, visitors to your site use and depend on application URL references.\n\nAlmost all Angular projects should use the default HTML5 style.\nIt produces URLs that are easier for users to understand and it preserves the option to do server-side rendering.\n\nRendering critical pages on the server is a technique that can greatly improve perceived responsiveness when the application first loads.\nAn application that would otherwise take ten or more seconds to start could be rendered on the server and delivered to the user's device in less than a second.\n\nThis option is only available if application URLs look like normal web URLs without hash ( `#`) characters in the middle.\n\n## [`<base href>`](https://angular.dev/guide/routing/common-router-tasks\\#base-href)\n\nThe router uses the browser's [history.pushState](https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries \"HTML5\") for navigation.\n`pushState` lets you customize in-application URL paths; for example, `localhost:4200/crisis-center`.\nThe in-application URLs can be indistinguishable from server URLs.\n\nModern HTML5 browsers were the first to support `pushState` which is why many people refer to these URLs as \"HTML5 style\" URLs.\n\n**HELPFUL:** HTML5 style navigation is the router default.\nIn the [LocationStrategy and browser URL styles](https://angular.dev/guide/routing/common-router-tasks#locationstrategy-and-browser-url-styles) section, learn why HTML5 style is preferable, how to adjust its behavior, and how to switch to the older hash ( `#`) style, if necessary.\n\nYou must add a [`<base href>` element](https://developer.mozilla.org/docs/Web/HTML/Element/base \"base\") to the application's `index.html` for `pushState` routing to work.\nThe browser uses the `<base href>` value to prefix relative URLs when referencing CSS files, scripts, and images.\n\nAdd the `<base>` element just after the `<head>` tag.\nIf the `app` folder is the application root, as it is for this application, set the `href` value in `index.html` as shown here.\n\ncheck\n\n```\n      <!DOCTYPE html><html lang=\"en\">  <head>    <!-- Set the base href -->    <base href=\"/\">    <title>Angular Router</title>    <meta charset=\"UTF-8\">    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">  </head>  <body>    <app-root></app-root>  </body></html>\n\n```\n\n### [HTML5 URLs and the `<base href>`](https://angular.dev/guide/routing/common-router-tasks\\#html5-urls-and-the-base-href)\n\nThe guidelines that follow will refer to different parts of a URL.\nThis diagram outlines what those parts refer to:\n\n```\n      foo://example.com:8042/over/there?name=ferret#nose\\_/   \\______________/\\_________/ \\_________/ \\__/ |           |            |            |        |scheme    authority      path        query   fragment\n\n```\n\ncheck\n\nWhile the router uses the [HTML5 pushState](https://developer.mozilla.org/docs/Web/API/History_API#Adding_and_modifying_history_entries \"Browser\") style by default, you must configure that strategy with a `<base href>`.\n\nThe preferred way to configure the strategy is to add a [`<base href>` element](https://developer.mozilla.org/docs/Web/HTML/Element/base \"base\") tag in the `<head>` of the `index.html`.\n\n```\n      <base href=\"/\">\n\n```\n\ncheck\n\nWithout that tag, the browser might not be able to load resources (images, CSS, scripts) when \"deep linking\" into the application.\n\nSome developers might not be able to add the `<base>` element, perhaps because they don't have access to `<head>` or the `index.html`.\n\nThose developers can still use HTML5 URLs by taking the following two steps:\n\n1. Provide the router with an appropriate `APP_BASE_HREF` value.\n\n2. Use root URLs (URLs with an `authority`) for all web resources: CSS, images, scripts, and template HTML files.\n\n   - The `<base href>` `path` should end with a \"/\", as browsers ignore characters in the `path` that follow the right-most \" `/`\"\n\n   - If the `<base href>` includes a `query` part, the `query` is only used if the `path` of a link in the page is empty and has no `query`.\n     This means that a `query` in the `<base href>` is only included when using `HashLocationStrategy`.\n\n   - If a link in the page is a root URL (has an `authority`), the `<base href>` is not used.\n     In this way, an `APP_BASE_HREF` with an authority will cause all links created by Angular to ignore the `<base href>` value.\n\n   - A fragment in the `<base href>` is _never_ persisted\n\nFor more complete information on how `<base href>` is used to construct target URIs, see the [RFC](https://tools.ietf.org/html/rfc3986#section-5.2.2) section on transforming references.\n\n### [`HashLocationStrategy`](https://angular.dev/guide/routing/common-router-tasks\\#hashlocationstrategy)\n\nUse `HashLocationStrategy` by providing the `useHash: true` in an object as the second argument of the `RouterModule.forRoot()` in the `AppModule`.\n\n```\n      providers: [  provideRouter(appRoutes, withHashLocation())]\n\n```\n\ncheck\n\nWhen using `RouterModule.forRoot`, this is configured with the `useHash: true` in the second argument: `RouterModule.forRoot(routes, {useHash: true})`.",
  "title": "Common routing tasks \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "component",
    "router",
    "route",
    "angular",
    "https",
    "routes",
    "routing",
    "dev",
    "guide",
    "application"
  ],
  "sourceURL": "https://angular.dev/guide/routing/common-router-tasks"
}