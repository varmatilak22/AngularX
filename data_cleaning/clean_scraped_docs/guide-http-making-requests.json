{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backHTTP Client\n  - [Overview](https://angular.dev/guide/http)\n  - [Setting up HttpClient](https://angular.dev/guide/http/setup)\n  - [Making requests](https://angular.dev/guide/http/making-requests)\n  - [Intercepting requests and responses](https://angular.dev/guide/http/interceptors)\n  - [Testing](https://angular.dev/guide/http/testing)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\n`HttpClient` has methods corresponding to the different HTTP verbs used to make requests, both to load data and to apply mutations on the server. Each method returns an [RxJS `Observable`](https://rxjs.dev/guide/observable) which, when subscribed, sends the request and then emits the results when the server responds.\n\n**NOTE:** `Observable` s created by `HttpClient` may be subscribed any number of times and will make a new backend request for each subscription.\n\nThrough an options object passed to the request method, various properties of the request and the returned response type can be adjusted.\n\n## [Fetching JSON data](https://angular.dev/guide/http/making-requests\\#fetching-json-data)\n\nFetching data from a backend often requires making a GET request using the [`HttpClient.get()`](https://angular.dev/guide/http/api/common/http/HttpClient#get) method. This method takes two arguments: the string endpoint URL from which to fetch, and an _optional options_ object to configure the request.\n\nFor example, to fetch configuration data from a hypothetical API using the `HttpClient.get()` method:\n\n```\n      http.get<Config>('/api/config').subscribe(config => {  // process the configuration.});\n\n```\n\ncheck\n\nNote the generic type argument which specifies that the data returned by the server will be of type `Config`. This argument is optional, and if you omit it then the returned data will have type `Object`.\n\n**TIP:** When dealing with data of uncertain structure and potential `undefined` or `null` values, consider using the `unknown` type instead of `Object` as the response type.\n\n**CRITICAL:** The generic type of request methods is a type **assertion** about the data returned by the server. `HttpClient` does not verify that the actual return data matches this type.\n\n## [Fetching other types of data](https://angular.dev/guide/http/making-requests\\#fetching-other-types-of-data)\n\nBy default, `HttpClient` assumes that servers will return JSON data. When interacting with a non-JSON API, you can tell `HttpClient` what response type to expect and return when making the request. This is done with the `responseType` option.\n\n| **`responseType` value** | **Returned response type** |\n| --- | --- |\n| `'json'` (default) | JSON data of the given generic type |\n| `'text'` | string data |\n| `'arraybuffer'` | [`ArrayBuffer`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) containing the raw response bytes |\n| `'blob'` | [`Blob`](https://developer.mozilla.org/docs/Web/API/Blob) instance |\n\nFor example, you can ask `HttpClient` to download the raw bytes of a `.jpeg` image into an `ArrayBuffer`:\n\n```\n      http.get('/images/dog.jpg', {responseType: 'arraybuffer'}).subscribe(buffer => {  console.log('The image is ' + buffer.byteLength + ' bytes large');});\n\n```\n\ncheck\n\n### Literal value for `responseType`\n\nBecause the value of `responseType` affects the type returned by `HttpClient`, it must have a literal type and not a `string` type.\n\nThis happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as `responseType: 'text' as const`.\n\n## [Mutating server state](https://angular.dev/guide/http/making-requests\\#mutating-server-state)\n\nServer APIs which perform mutations often require making POST requests with a request body specifying the new state or the change to be made.\n\nThe [`HttpClient.post()`](https://angular.dev/guide/http/api/common/http/HttpClient#post) method behaves similarly to `get()`, and accepts an additional `body` argument before its options:\n\n```\n      http.post<Config>('/api/config', newConfig).subscribe(config => {  console.log('Updated config:', config);});\n\n```\n\ncheck\n\nMany different types of values can be provided as the request's `body`, and `HttpClient` will serialize them accordingly:\n\n| **`body` type** | **Serialized as** |\n| --- | --- |\n| string | Plain text |\n| number, boolean, array, or plain object | JSON |\n| [`ArrayBuffer`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | raw data from the buffer |\n| [`Blob`](https://developer.mozilla.org/docs/Web/API/Blob) | raw data with the `Blob`'s content type |\n| [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData) | `multipart/form-data` encoded data |\n| [`HttpParams`](https://angular.dev/guide/http/api/common/http/HttpParams) or [`URLSearchParams`](https://developer.mozilla.org/docs/Web/API/URLSearchParams) | `application/x-www-form-urlencoded` formatted string |\n\n**IMPORTANT:** Remember to `.subscribe()` to mutation request `Observable` s in order to actually fire the request.\n\n## [Setting URL parameters](https://angular.dev/guide/http/making-requests\\#setting-url-parameters)\n\nSpecify request parameters that should be included in the request URL using the `params` option.\n\nPassing an object literal is the simplest way of configuring URL parameters:\n\n```\n      http.get('/api/config', {  params: {filter: 'all'},}).subscribe(config => {  // ...});\n\n```\n\ncheck\n\nAlternatively, pass an instance of `HttpParams` if you need more control over the construction or serialization of the parameters.\n\n**IMPORTANT:** Instances of `HttpParams` are _immutable_ and cannot be directly changed. Instead, mutation methods such as `append()` return a new instance of `HttpParams` with the mutation applied.\n\n```\n      const baseParams = new HttpParams().set('filter', 'all');http.get('/api/config', {  params: baseParams.set('details', 'enabled'),}).subscribe(config => {  // ...});\n\n```\n\ncheck\n\nYou can instantiate `HttpParams` with a custom `HttpParameterCodec` that determines how `HttpClient` will encode the parameters into the URL.\n\n## [Setting request headers](https://angular.dev/guide/http/making-requests\\#setting-request-headers)\n\nSpecify request headers that should be included in the request using the `headers` option.\n\nPassing an object literal is the simplest way of configuring request headers:\n\n```\n      http.get('/api/config', {  headers: {    'X-Debug-Level': 'verbose',  }}).subscribe(config => {  // ...});\n\n```\n\ncheck\n\nAlternatively, pass an instance of `HttpHeaders` if you need more control over the construction of headers\n\n**IMPORTANT:** Instances of `HttpHeaders` are _immutable_ and cannot be directly changed. Instead, mutation methods such as `append()` return a new instance of `HttpHeaders` with the mutation applied.\n\n```\n      const baseHeaders = new HttpHeaders().set('X-Debug-Level', 'minimal');http.get<Config>('/api/config', {  headers: baseHeaders.set('X-Debug-Level', 'verbose'),}).subscribe(config => {  // ...});\n\n```\n\ncheck\n\n## [Interacting with the server response events](https://angular.dev/guide/http/making-requests\\#interacting-with-the-server-response-events)\n\nFor convenience, `HttpClient` by default returns an `Observable` of the data returned by the server (the response body). Occasionally it's desirable to examine the actual response, for example to retrieve specific response headers.\n\nTo access the entire response, set the `observe` option to `'response'`:\n\n```\n      http.get<Config>('/api/config', {observe: 'response'}).subscribe(res => {  console.log('Response status:', res.status);  console.log('Body:', res.body);});\n\n```\n\ncheck\n\n### Literal value for `observe`\n\nBecause the value of `observe` affects the type returned by `HttpClient`, it must have a literal type and not a `string` type.\n\nThis happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as `observe: 'response' as const`.\n\n## [Receiving raw progress events](https://angular.dev/guide/http/making-requests\\#receiving-raw-progress-events)\n\nIn addition to the response body or response object, `HttpClient` can also return a stream of raw _events_ corresponding to specific moments in the request lifecycle. These events include when the request is sent, when the response header is returned, and when the body is complete. These events can also include _progress events_ which report upload and download status for large request or response bodies.\n\nProgress events are disabled by default (as they have a performance cost) but can be enabled with the `reportProgress` option.\n\n**NOTE:** The optional `fetch` implementation of `HttpClient` does not report _upload_ progress events.\n\nTo observe the event stream, set the `observe` option to `'events'`:\n\n```\n      http.post('/api/upload', myData, {  reportProgress: true,  observe: 'events',}).subscribe(event => {  switch (event.type) {    case HttpEventType.UploadProgress:      console.log('Uploaded ' + event.loaded + ' out of ' + event.total + ' bytes');      break;    case HttpEventType.Response:      console.log('Finished uploading!');      break;  }});\n\n```\n\ncheck\n\n### Literal value for `observe`\n\nBecause the value of `observe` affects the type returned by `HttpClient`, it must have a literal type and not a `string` type.\n\nThis happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as `observe: 'events' as const`.\n\nEach `HttpEvent` reported in the event stream has a `type` which distinguishes what the event represents:\n\n| **`type` value** | **Event meaning** |\n| --- | --- |\n| `HttpEventType.Sent` | The request has been dispatched to the server |\n| `HttpEventType.UploadProgress` | An `HttpUploadProgressEvent` reporting progress on uploading the request body |\n| `HttpEventType.ResponseHeader` | The head of the response has been received, including status and headers |\n| `HttpEventType.DownloadProgress` | An `HttpDownloadProgressEvent` reporting progress on downloading the response body |\n| `HttpEventType.Response` | The entire response has been received, including the response body |\n| `HttpEventType.User` | A custom event from an Http interceptor. |\n\n## [Handling request failure](https://angular.dev/guide/http/making-requests\\#handling-request-failure)\n\nThere are two ways an HTTP request can fail:\n\n- A network or connection error can prevent the request from reaching the backend server.\n- The backend can receive the request but fail to process it, and return an error response.\n\n`HttpClient` captures both kinds of errors in an `HttpErrorResponse` which it returns through the `Observable`'s error channel. Network errors have a `status` code of `0` and an `error` which is an instance of [`ProgressEvent`](https://developer.mozilla.org/docs/Web/API/ProgressEvent). Backend errors have the failing `status` code returned by the backend, and the error response as the `error`. Inspect the response to identify the error's cause and the appropriate action to handle the error.\n\nThe [RxJS library](https://rxjs.dev/) offers several operators which can be useful for error handling.\n\nYou can use the `catchError` operator to transform an error response into a value for the UI. This value can tell the UI to display an error page or value, and capture the error's cause if necessary.\n\nSometimes transient errors such as network interruptions can cause a request to fail unexpectedly, and simply retrying the request will allow it to succeed. RxJS provides several _retry_ operators which automatically re-subscribe to a failed `Observable` under certain conditions. For example, the `retry()` operator will automatically attempt to re-subscribe a specified number of times.\n\n## [Http `Observable` s](https://angular.dev/guide/http/making-requests\\#http-observables)\n\nEach request method on `HttpClient` constructs and returns an `Observable` of the requested response type. Understanding how these `Observable` s work is important when using `HttpClient`.\n\n`HttpClient` produces what RxJS calls \"cold\" `Observable` s, meaning that no actual request happens until the `Observable` is subscribed. Only then is the request actually dispatched to the server. Subscribing to the same `Observable` multiple times will trigger multiple backend requests. Each subscription is independent.\n\n**TIP:** You can think of `HttpClient` `Observable` s as _blueprints_ for actual server requests.\n\nOnce subscribed, unsubscribing will abort the in-progress request. This is very useful if the `Observable` is subscribed via the `async` pipe, as it will automatically cancel the request if the user navigates away from the current page. Additionally, if you use the `Observable` with an RxJS combinator like `switchMap`, this cancellation will clean up any stale requests.\n\nOnce the response returns, `Observable` s from `HttpClient` usually complete (although interceptors can influence this).\n\nBecause of the automatic completion, there is usually no risk of memory leaks if `HttpClient` subscriptions are not cleaned up. However, as with any async operation, we strongly recommend that you clean up subscriptions when the component using them is destroyed, as the subscription callback may otherwise run and encounter errors when it attempts to interact with the destroyed component.\n\n**TIP:** Using the `async` pipe or the `toSignal` operation to subscribe to `Observable` s ensures that subscriptions are disposed properly.\n\n## [Best practices](https://angular.dev/guide/http/making-requests\\#best-practices)\n\nWhile `HttpClient` can be injected and used directly from components, generally we recommend you create reusable, injectable services which isolate and encapsulate data access logic. For example, this `UserService` encapsulates the logic to request data for a user by their id:\n\n```\n      @Injectable({providedIn: 'root'})export class UserService {  private http = inject(HttpClient);  getUser(id: string): Observable<User> {    return this.http.get<User>(`/api/user/${id}`);  }}\n\n```\n\ncheck\n\nWithin a component, you can combine `@if` with the `async` pipe to render the UI for the data only after it's finished loading:\n\n```\n      import { AsyncPipe } from '@angular/common';@Component({  imports: [AsyncPipe],  template: `    @if (user$ | async; as user) {      <p>Name: {{ user.name }}</p>      <p>Biography: {{ user.biography }}</p>    }  `,})export class UserProfileComponent {  @Input() userId!: string;  user$!: Observable<User>;  private userService = inject(UserService);  constructor(): void {    this.user$ = this.userService.getUser(this.userId);  }}\n\n```\n\ncheck",
  "title": "Making requests \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "https",
    "angular",
    "request",
    "http",
    "dev",
    "response",
    "httpclient",
    "type",
    "data",
    "guide"
  ],
  "sourceURL": "https://angular.dev/guide/http/making-requests"
}