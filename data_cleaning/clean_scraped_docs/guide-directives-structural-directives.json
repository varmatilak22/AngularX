{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backDirectives\n  - [Overview](https://angular.dev/guide/directives)\n  - [Attribute directives](https://angular.dev/guide/directives/attribute-directives)\n  - [Structural directives](https://angular.dev/guide/directives/structural-directives)\n  - [Directive composition API](https://angular.dev/guide/directives/directive-composition-api)\n  - [Optimizing images with NgOptimizedImage](https://angular.dev/guide/image-optimization)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nStructural directives are directives applied to an `<ng-template>` element that conditionally or repeatedly render the content of that `<ng-template>`.\n\n## [Example use case](https://angular.dev/guide/directives/structural-directives\\#example-use-case)\n\nIn this guide you'll build a structural directive which fetches data from a given data source and renders its template when that data is available. This directive is called `SelectDirective`, after the SQL keyword `SELECT`, and match it with an attribute selector `[select]`.\n\n`SelectDirective` will have an input naming the data source to be used, which you will call `selectFrom`. The `select` prefix for this input is important for the [shorthand syntax](https://angular.dev/guide/directives/structural-directives#structural-directive-shorthand). The directive will instantiate its `<ng-template>` with a template context providing the selected data.\n\nThe following is an example of using this directive directly on an `<ng-template>` would look like:\n\n```\n      <ng-template select let-data [selectFrom]=\"source\">  <p>The data is: {{ data }}</p></ng-template>\n\n```\n\ncheck\n\nThe structural directive can wait for the data to become available and then render its `<ng-template>`.\n\n**HELPFUL:** Note that Angular's `<ng-template>` element defines a template that doesn't render anything by default, if you just wrap elements in an `<ng-template>` without applying a structural directive those elements will not be rendered.\n\nFor more information, see the [ng-template API](https://angular.dev/guide/directives/api/core/ng-template) documentation.\n\n## [Structural directive shorthand](https://angular.dev/guide/directives/structural-directives\\#structural-directive-shorthand)\n\nAngular supports a shorthand syntax for structural directives which avoids the need to explicitly author an `<ng-template>` element.\n\nStructural directives can be applied directly on an element by prefixing the directive attribute selector with an asterisk ( `*`), such as `*select`. Angular transforms the asterisk in front of a structural directive into an `<ng-template>` that hosts the directive and surrounds the element and its descendants.\n\nYou can use this with `SelectDirective` as follows:\n\n```\n      <p *select=\"let data from source\">The data is: {{data}}</p>\n\n```\n\ncheck\n\nThis example shows the flexibility of structural directive shorthand syntax, which is sometimes called _microsyntax_.\n\nWhen used in this way, only the structural directive and its bindings are applied to the `<ng-template>`. Any other attributes or bindings on the `<p>` tag are left alone. For example, these two forms are equivalent:\n\n```\n      <!-- Shorthand syntax: --><p class=\"data-view\" *select=\"let data from source\">The data is: {{data}}</p><!-- Long-form syntax: --><ng-template select let-data [selectFrom]=\"source\">  <p class=\"data-view\">The data is: {{data}}</p></ng-template>\n\n```\n\ncheck\n\nShorthand syntax is expanded through a set of conventions. A more thorough [grammar](https://angular.dev/guide/directives/structural-directives#structural-directive-syntax-reference) is defined below, but in the above example, this transformation can be explained as follows:\n\nThe first part of the `*select` expression is `let data`, which declares a template variable `data`. Since no assignment follows, the template variable is bound to the template context property `$implicit`.\n\nThe second piece of syntax is a key-expression pair, `from source`. `from` is a binding key and `source` is a regular template expression. Binding keys are mapped to properties by transforming them to PascalCase and prepending the structural directive selector. The `from` key is mapped to `selectFrom`, which is then bound to the expression `source`. This is why many structural directives will have inputs that are all prefixed with the structural directive's selector.\n\n## [One structural directive per element](https://angular.dev/guide/directives/structural-directives\\#one-structural-directive-per-element)\n\nYou can only apply one structural directive per element when using the shorthand syntax. This is because there is only one `<ng-template>` element onto which that directive gets unwrapped. Multiple directives would require multiple nested `<ng-template>`, and it's unclear which directive should be first. `<ng-container>` can be used when to create wrapper layers when multiple structural directives need to be applied around the same physical DOM element or component, which allows the user to define the nested structure.\n\n## [Creating a structural directive](https://angular.dev/guide/directives/structural-directives\\#creating-a-structural-directive)\n\nThis section guides you through creating the `SelectDirective`.\n\n1. ### [Generate the directive](https://angular.dev/guide/directives/structural-directives\\#generate-the-directive)\n\n\nUsing the Angular CLI, run the following command, where `select` is the name of the directive:\n\n\n\n```\n         ng generate directive select\n\n```\n\ncheck\n\nAngular creates the directive class and specifies the CSS selector, `[select]`, that identifies the directive in a template.\n\n2. ### [Make the directive structural](https://angular.dev/guide/directives/structural-directives\\#make-the-directive-structural)\n\n\nImport `TemplateRef`, and `ViewContainerRef`. Inject `TemplateRef` and `ViewContainerRef` in the directive as private properties.\n\n\n\n```\n         import {Directive, TemplateRef, ViewContainerRef} from '@angular/core';@Directive({  selector: '[select]',})export class SelectDirective {  private templateRef = inject(TemplateRef);  private ViewContainerRef = inject(ViewContainerRef);}\n\n```\n\ncheck\n\n3. ### [Add the 'selectFrom' input](https://angular.dev/guide/directives/structural-directives\\#add-the-selectfrom-input)\n\n\nAdd a `selectFrom` `@Input()` property.\n\n\n\n```\n         export class SelectDirective {  // ...  @Input({required: true}) selectFrom!: DataSource;}\n\n```\n\ncheck\n\n4. ### [Add the business logic](https://angular.dev/guide/directives/structural-directives\\#add-the-business-logic)\n\n\nWith `SelectDirective` now scaffolded as a structural directive with its input, you can now add the logic to fetch the data and render the template with it:\n\n\n\n```\n         export class SelectDirective {  // ...  async ngOnInit() {    const data = await this.selectFrom.load();    this.viewContainerRef.createEmbeddedView(this.templateRef, {      // Create the embedded view with a context object that contains      // the data via the key `$implicit`.      $implicit: data,    });  }}\n\n```\n\ncheck\n\n\nThat's it - `SelectDirective` is up and running. A follow-up step might be to [add template type-checking support](https://angular.dev/guide/directives/structural-directives#typing-the-directives-context).\n\n## [Structural directive syntax reference](https://angular.dev/guide/directives/structural-directives\\#structural-directive-syntax-reference)\n\nWhen you write your own structural directives, use the following syntax:\n\n```\n      *:prefix=\"( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*\"\n\n```\n\ncheck\n\nThe following patterns describe each portion of the structural directive grammar:\n\n```\n      as = :export \"as\" :local \";\"?keyExp = :key \":\"? :expression (\"as\" :local)? \";\"?let = \"let\" :local \"=\" :export \";\"?\n\n```\n\ncheck\n\n| Keyword | Details |\n| :-- | :-- |\n| `prefix` | HTML attribute key |\n| `key` | HTML attribute key |\n| `local` | Local variable name used in the template |\n| `export` | Value exported by the directive under a given name |\n| `expression` | Standard Angular expression |\n\n### [How Angular translates shorthand](https://angular.dev/guide/directives/structural-directives\\#how-angular-translates-shorthand)\n\nAngular translates structural directive shorthand into the normal binding syntax as follows:\n\n| Shorthand | Translation |\n| :-- | :-- |\n| `prefix` and naked `expression` | `[prefix]=\"expression\"` |\n| `keyExp` | `[prefixKey]=\"expression\"` (The `prefix` is added to the `key`) |\n| `let local` | `let-local=\"export\"` |\n\n### [Shorthand examples](https://angular.dev/guide/directives/structural-directives\\#shorthand-examples)\n\nThe following table provides shorthand examples:\n\n| Shorthand | How Angular interprets the syntax |\n| :-- | :-- |\n| `*ngFor=\"let item of [1,2,3]\"` | `<ng-template ngFor let-item [ngForOf]=\"[1, 2, 3]\">` |\n| `*ngFor=\"let item of [1,2,3] as items; trackBy: myTrack; index as i\"` | `<ng-template ngFor let-item [ngForOf]=\"[1,2,3]\" let-items=\"ngForOf\" [ngForTrackBy]=\"myTrack\" let-i=\"index\">` |\n| `*ngIf=\"exp\"` | `<ng-template [ngIf]=\"exp\">` |\n| `*ngIf=\"exp as value\"` | `<ng-template [ngIf]=\"exp\" let-value=\"ngIf\">` |\n\n## [Improving template type checking for custom directives](https://angular.dev/guide/directives/structural-directives\\#improving-template-type-checking-for-custom-directives)\n\nYou can improve template type checking for custom directives by adding template guards to your directive definition.\nThese guards help the Angular template type checker find mistakes in the template at compile time, which can avoid runtime errors.\nTwo different types of guards are possible:\n\n- `ngTemplateGuard_(input)` lets you control how an input expression should be narrowed based on the type of a specific input.\n- `ngTemplateContextGuard` is used to determine the type of the context object for the template, based on the type of the directive itself.\n\nThis section provides examples of both kinds of guards.\nFor more information, see [Template type checking](https://angular.dev/guide/directives/tools/cli/template-typecheck \"Template\").\n\n### [Type narrowing with template guards](https://angular.dev/guide/directives/structural-directives\\#type-narrowing-with-template-guards)\n\nA structural directive in a template controls whether that template is rendered at run time. Some structural directives want to perform type narrowing based on the type of input expression.\n\nThere are two narrowings which are possible with input guards:\n\n- Narrowing the input expression based on a TypeScript type assertion function.\n- Narrowing the input expression based on its truthiness.\n\nTo narrow the input expression by defining a type assertion function:\n\n```\n      // This directive only renders its template if the actor is a user.// You want to assert that within the template, the type of the `actor`// expression is narrowed to `User`.@Directive(...)class ActorIsUser {  @Input() actor: User|Robot;  static ngTemplateGuard_actor(dir: ActorIsUser, expr: User|Robot): expr is User {    // The return statement is unnecessary in practice, but included to    // prevent TypeScript errors.    return true;  }}\n\n```\n\ncheck\n\nType-checking will behave within the template as if the `ngTemplateGuard_actor` has been asserted on the expression bound to the input.\n\nSome directives only render their templates when an input is truthy. It's not possible to capture the full semantics of truthiness in a type assertion function, so instead a literal type of `'binding'` can be used to signal to the template type-checker that the binding expression itself should be used as the guard:\n\n```\n      @Directive(...)class CustomIf {  @Input() condition!: any;  static ngTemplateGuard_condition: 'binding';}\n\n```\n\ncheck\n\nThe template type-checker will behave as if the expression bound to `condition` was asserted to be truthy within the template.\n\n### [Typing the directive's context](https://angular.dev/guide/directives/structural-directives\\#typing-the-directives-context)\n\nIf your structural directive provides a context to the instantiated template, you can properly type it inside the template by providing a static `ngTemplateContextGuard` type assertion function. This function can use the type of the directive to derive the type of the context, which is useful when the type of the directive is generic.\n\nFor the `SelectDirective` described above, you can implement an `ngTemplateContextGuard` to correctly specify the data type, even if the data source is generic.\n\n```\n      // Declare an interface for the template context:export interface SelectTemplateContext<T> {  $implicit: T;}@Directive(...)export class SelectDirective<T> {  // The directive's generic type `T` will be inferred from the `DataSource` type  // passed to the input.  @Input({required: true}) selectFrom!: DataSource<T>;  // Narrow the type of the context using the generic type of the directive.  static ngTemplateContextGuard<T>(dir: SelectDirective<T>, ctx: any): ctx is SelectTemplateContext<T> {    // As before the guard body is not used at runtime, and included only to avoid    // TypeScript errors.    return true;  }}\n\n```\n\ncheck",
  "title": "Structural directives \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "angular",
    "directives",
    "directive",
    "template",
    "structural",
    "https",
    "dev",
    "type",
    "data",
    "guide"
  ],
  "sourceURL": "https://angular.dev/guide/directives/structural-directives"
}