{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backComponents\n  - [Anatomy of components](https://angular.dev/guide/components)\n  - [Selectors](https://angular.dev/guide/components/selectors)\n  - [Styling](https://angular.dev/guide/components/styling)\n  - [Accepting data with input properties](https://angular.dev/guide/components/inputs)\n  - [Custom events with outputs](https://angular.dev/guide/components/outputs)\n  - [Content projection with ng-content](https://angular.dev/guide/components/content-projection)\n  - [Host elements](https://angular.dev/guide/components/host-elements)\n  - [Lifecycle](https://angular.dev/guide/components/lifecycle)\n  - [Referencing component children with queries](https://angular.dev/guide/components/queries)\n  - [Using DOM APIs](https://angular.dev/guide/components/dom-apis)\n  - [Inheritance](https://angular.dev/guide/components/inheritance)\n  - [Programmatically rendering components](https://angular.dev/guide/components/programmatic-rendering)\n  - [Advanced configuration](https://angular.dev/guide/components/advanced-configuration)\n  - [Custom Elements](https://angular.dev/guide/elements)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\n**TIP:** This guide assumes you've already read the [Essentials Guide](https://angular.dev/guide/components/essentials). Read that first if you're new to Angular.\n\nA component can define **queries** that find child elements and read values from their injectors.\n\nDevelopers most commonly use queries to retrieve references to child components, directives, DOM elements, and more.\n\nAll query functions return signals that reflect the most up-to-date results. You can read the\nresult by calling the signal function, including in reactive contexts like `computed` and `effect`.\n\nThere are two categories of query: **view queries** and **content queries.**\n\n## [View queries](https://angular.dev/guide/components/queries\\#view-queries)\n\nView queries retrieve results from the elements in the component's _view_ \u2014 the elements defined in the component's own template. You can query for a single result with the `viewChild` function.\n\n```\n      @Component({  selector: 'custom-card-header',  /*...*/})export class CustomCardHeader {  text: string;}@Component({  selector: 'custom-card',  template: '<custom-card-header>Visit sunny California!</custom-card-header>',})export class CustomCard {  header = viewChild(CustomCardHeader);  headerText = computed(() => this.header()?.text);}\n\n```\n\ncheck\n\nIn this example, the `CustomCard` component queries for a child `CustomCardHeader` and uses the result in a `computed`.\n\nIf the query does not find a result, its value is `undefined`. This may occur if the target element is hidden by `@if`. Angular keeps the result of `viewChild` up to date as your application state changes.\n\nYou can also query for multiple results with the `viewChildren` function.\n\n```\n      @Component({  selector: 'custom-card-action',  /*...*/})export class CustomCardAction {  text: string;}@Component({  selector: 'custom-card',  template: `    <custom-card-action>Save</custom-card-action>    <custom-card-action>Cancel</custom-card-action>  `,})export class CustomCard {  actions = viewChildren(CustomCardAction);  actionsTexts = computed(() => this.actions().map(action => action.text);}\n\n```\n\ncheck\n\n`viewChildren` creates a signal with an `Array` of the query results.\n\n**Queries never pierce through component boundaries.** View queries can only retrieve results from the component's template.\n\n## [Content queries](https://angular.dev/guide/components/queries\\#content-queries)\n\nContent queries retrieve results from the elements in the component's _content_\u2014 the elements nested inside the component in the template where it's used. You can query for a single result with the `contentChild` function.\n\n```\n      @Component({  selector: 'custom-toggle',  /*...*/})export class CustomToggle {  text: string;}@Component({  selector: 'custom-expando',  /*...*/})export class CustomExpando {  toggle = contentChild(CustomToggle);  toggleText = computed(() => this.toggle()?.text);}@Component({  /* ... */  // CustomToggle is used inside CustomExpando as content.  template: `    <custom-expando>      <custom-toggle>Show</custom-toggle>    </custom-expando>  `})export class UserProfile { }\n\n```\n\ncheck\n\nIn this example, the `CustomExpando` component queries for a child `CustomToggle` and accesses the result in a `computed`.\n\nIf the query does not find a result, its value is `undefined`. This may occur if the target element is absent or hidden by `@if`. Angular keeps the result of `contentChild` up to date as your application state changes.\n\nBy default, content queries find only _direct_ children of the component and do not traverse into descendants.\n\nYou can also query for multiple results with the `contentChildren` function.\n\n```\n      @Component({  selector: 'custom-menu-item',  /*...*/})export class CustomMenuItem {  text: string;}@Component({  selector: 'custom-menu',  /*...*/})export class CustomMenu {  items = contentChildren(CustomMenuItem);  itemTexts = computed(() => this.items().map(item => item.text));}@Component({  selector: 'user-profile',  template: `    <custom-menu>      <custom-menu-item>Cheese</custom-menu-item>      <custom-menu-item>Tomato</custom-menu-item>    </custom-menu>  `})export class UserProfile { }\n\n```\n\ncheck\n\n`contentChildren` creates a signal with an `Array` of the query results.\n\n**Queries never pierce through component boundaries.** Content queries can only retrieve results from the same template as the component itself.\n\n## [Required queries](https://angular.dev/guide/components/queries\\#required-queries)\n\nIf a child query ( `viewChild` or `contentChild`) does not find a result, its value is `undefined`. This may occur if the target element is hidden by a control flow statement like `@if` or `@for`. Because of this, the child queries return a signal that include `undefined` in their value type.\n\nIn some cases, especially with `viewChild`, you know with certainty that a specific child is always available. In other cases, you may want to strictly enforce that a specific child is present. For these cases, you can use a _required query_.\n\n```\n      @Component({/* ... */})export class CustomCard {  header = viewChild.required(CustomCardHeader);  body = contentChild.required(CustomCardBody);}\n\n```\n\ncheck\n\nIf a required query does not find a matching result, Angular reports an error. Because this guarantees that a result is available, required queries do not automatically include `undefined` in the signal's value type.\n\n## [Query locators](https://angular.dev/guide/components/queries\\#query-locators)\n\nThis first parameter for each query decorator is its **locator**.\n\nMost of the time, you want to use a component or directive as your locator.\n\nYou can alternatively specify a string locator corresponding to\na [template reference variable](https://angular.dev/guide/components/guide/templates/variables#template-reference-variables).\n\n```\n      @Component({  /*...*/  template: `    <button #save>Save</button>    <button #cancel>Cancel</button>  `})export class ActionBar {  saveButton = viewChild<ElementRef<HTMLButtonElement>>('save');}\n\n```\n\ncheck\n\nIf more than one element defines the same template reference variable, the query retrieves the first matching element.\n\nAngular does not support CSS selectors as query locators.\n\n### [Queries and the injector tree](https://angular.dev/guide/components/queries\\#queries-and-the-injector-tree)\n\n**TIP:** See [Dependency Injection](https://angular.dev/guide/components/guide/di) for background on providers and Angular's injection tree.\n\nFor more advanced cases, you can use any `ProviderToken` as a locator. This lets you locate elements based on component and directive providers.\n\n```\n      const SUB_ITEM = new InjectionToken<string>('sub-item');@Component({  /*...*/  providers: [{provide: SUB_ITEM, useValue: 'special-item'}],})export class SpecialItem { }@Component({/*...*/})export class CustomList {  subItemType = contentChild(SUB_ITEM);}\n\n```\n\ncheck\n\nThe above example uses an `InjectionToken` as a locator, but you can use any `ProviderToken` to locate specific elements.\n\n## [Query options](https://angular.dev/guide/components/queries\\#query-options)\n\nAll query functions accept an options object as a second parameter. These options control how the query finds its results.\n\n### [Reading specific values from an element's injector](https://angular.dev/guide/components/queries\\#reading-specific-values-from-an-elements-injector)\n\nBy default, the query locator indicates both the element you're searching for and the value retrieved. You can alternatively specify the `read` option to retrieve a different value from the element matched by the locator.\n\n```\n      @Component({/*...*/})export class CustomExpando {  toggle = contentChild(ExpandoContent, {read: TemplateRef});}\n\n```\n\ncheck\n\nThe above example, locates an element with the directive `ExpandoContent` and retrieves\nthe `TemplateRef` associated with that element.\n\nDevelopers most commonly use `read` to retrieve `ElementRef` and `TemplateRef`.\n\n### [Content descendants](https://angular.dev/guide/components/queries\\#content-descendants)\n\nBy default, content queries find only _direct_ children of the component and do not traverse into descendants.\n\n```\n      @Component({  selector: 'custom-expando',  /*...*/})export class CustomExpando {  toggle = contentChild(CustomToggle);}@Component({  selector: 'user-profile',  template: `    <custom-expando>      <some-other-component>        <!-- custom-toggle will not be found! -->        <custom-toggle>Show</custom-toggle>      </some-other-component>    </custom-expando>  `})export class UserProfile { }\n\n```\n\ncheck\n\nIn the example above, `CustomExpando` cannot find `<custom-toggle>` because it is not a direct child of `<custom-expando>`. By setting `descendants: true`, you configure the query to traverse all descendants in the same template. Queries, however, _never_ pierce into components to traverse elements in other templates.\n\nView queries do not have this option because they _always_ traverse into descendants.\n\n## [Decorator-based queries](https://angular.dev/guide/components/queries\\#decorator-based-queries)\n\n**TIP:** While the Angular team recommends using the signal-based query function for new projects, the\noriginal decorator-based query APIs remain fully supported.\n\nYou can alternatively declare queries by adding the corresponding decorator to a property. Decorator-based queries behave the same way as signal-based queries except as described below.\n\n### [View queries](https://angular.dev/guide/components/queries\\#view-queries-1)\n\nYou can query for a single result with the `@ViewChild` decorator.\n\n```\n      @Component({  selector: 'custom-card-header',  /*...*/})export class CustomCardHeader {  text: string;}@Component({  selector: 'custom-card',  template: '<custom-card-header>Visit sunny California!</custom-card-header>',})export class CustomCard {  @ViewChild(CustomCardHeader) header: CustomCardHeader;  ngAfterViewInit() {    console.log(this.header.text);  }}\n\n```\n\ncheck\n\nIn this example, the `CustomCard` component queries for a child `CustomCardHeader` and accesses the result in `ngAfterViewInit`.\n\nAngular keeps the result of `@ViewChild` up to date as your application state changes.\n\n**View query results become available in the `ngAfterViewInit` lifecycle method**. Before this point, the value is `undefined`. See the [Lifecycle](https://angular.dev/guide/components/guide/components/lifecycle) section for details on the component lifecycle.\n\nYou can also query for multiple results with the `@ViewChildren` decorator.\n\n```\n      @Component({  selector: 'custom-card-action',  /*...*/})export class CustomCardAction {  text: string;}@Component({  selector: 'custom-card',  template: `    <custom-card-action>Save</custom-card-action>    <custom-card-action>Cancel</custom-card-action>  `,})export class CustomCard {  @ViewChildren(CustomCardAction) actions: QueryList<CustomCardAction>;  ngAfterViewInit() {    this.actions.forEach(action => {      console.log(action.text);    });  }}\n\n```\n\ncheck\n\n`@ViewChildren` creates a `QueryList` object that contains the query results. You can subscribe to changes to the query results over time via the `changes` property.\n\n### [Content queries](https://angular.dev/guide/components/queries\\#content-queries-1)\n\nYou can query for a single result with the `@ContentChild` decorator.\n\n```\n      @Component({  selector: 'custom-toggle',  /*...*/})export class CustomToggle {  text: string;}@Component({  selector: 'custom-expando',  /*...*/})export class CustomExpando {  @ContentChild(CustomToggle) toggle: CustomToggle;  ngAfterContentInit() {    console.log(this.toggle.text);  }}@Component({  selector: 'user-profile',  template: `    <custom-expando>      <custom-toggle>Show</custom-toggle>    </custom-expando>  `})export class UserProfile { }\n\n```\n\ncheck\n\nIn this example, the `CustomExpando` component queries for a child `CustomToggle` and accesses the result in `ngAfterContentInit`.\n\nAngular keeps the result of `@ContentChild` up to date as your application state changes.\n\n**Content query results become available in the `ngAfterContentInit` lifecycle method**. Before this point, the value is `undefined`. See the [Lifecycle](https://angular.dev/guide/components/guide/components/lifecycle) section for details on the component lifecycle.\n\nYou can also query for multiple results with the `@ContentChildren` decorator.\n\n```\n      @Component({  selector: 'custom-menu-item',  /*...*/})export class CustomMenuItem {  text: string;}@Component({  selector: 'custom-menu',  /*...*/})export class CustomMenu {  @ContentChildren(CustomMenuItem) items: QueryList<CustomMenuItem>;  ngAfterContentInit() {    this.items.forEach(item => {      console.log(item.text);    });  }}@Component({  selector: 'user-profile',  template: `    <custom-menu>      <custom-menu-item>Cheese</custom-menu-item>      <custom-menu-item>Tomato</custom-menu-item>    </custom-menu>  `})export class UserProfile { }\n\n```\n\ncheck\n\n`@ContentChildren` creates a `QueryList` object that contains the query results. You can subscribe to changes to the query results over time via the `changes` property.\n\n### [Decorator-based query options](https://angular.dev/guide/components/queries\\#decorator-based-query-options)\n\nAll query decorators accept an options object as a second parameter. These options work the same way as signal-based queries except where described below.\n\n### [Static queries](https://angular.dev/guide/components/queries\\#static-queries)\n\n`@ViewChild` and `@ContentChild` decorators accept the `static` option.\n\n```\n      @Component({  selector: 'custom-card',  template: '<custom-card-header>Visit sunny California!</custom-card-header>',})export class CustomCard {  @ViewChild(CustomCardHeader, {static: true}) header: CustomCardHeader;  ngOnInit() {    console.log(this.header.text);  }}\n\n```\n\ncheck\n\nBy setting `static: true`, you guarantee to Angular that the target of this query is _always_ present and is not conditionally rendered. This makes the result available earlier, in the `ngOnInit` lifecycle method.\n\nStatic query results do not update after initialization.\n\nThe `static` option is not available for `@ViewChildren` and `@ContentChildren` queries.\n\n### [Using QueryList](https://angular.dev/guide/components/queries\\#using-querylist)\n\n`@ViewChildren` and `@ContentChildren` both provide a `QueryList` object that contains a list of results.\n\n`QueryList` offers a number of convenience APIs for working with results in an array-like manner, such as `map`, `reduce`, and `forEach`. You can get an array of the current results by calling `toArray`.\n\nYou can subscribe to the `changes` property to do something any time the results change.\n\n## [Common query pitfalls](https://angular.dev/guide/components/queries\\#common-query-pitfalls)\n\nWhen using queries, common pitfalls can make your code harder to understand and maintain.\n\nAlways maintain a single source of truth for state shared between multiple components. This avoids scenarios where repeated state in different components becomes out of sync.\n\nAvoid directly writing state to child components. This pattern can lead to brittle code that is hard to understand and is prone to [ExpressionChangedAfterItHasBeenChecked](https://angular.dev/guide/components/errors/NG0100) errors.\n\nNever directly write state to parent or ancestor components. This pattern can lead to brittle code that is hard to understand and is prone to [ExpressionChangedAfterItHasBeenChecked](https://angular.dev/guide/components/errors/NG0100) errors.",
  "title": "Referencing component children with queries \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "angular",
    "custom",
    "queries",
    "https",
    "component",
    "components",
    "dev",
    "guide",
    "query",
    "class"
  ],
  "sourceURL": "https://angular.dev/guide/components/queries"
}