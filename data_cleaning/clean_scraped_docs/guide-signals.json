{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backSignals\n  - [Overview](https://angular.dev/guide/signals)\n  - [Dependent state with linkedSignal](https://angular.dev/guide/signals/linked-signal)\n  - [Async reactivity with resources](https://angular.dev/guide/signals/resource)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nIn-depth Guides\n\nSignals\n\n# Angular Signals\n\n[edit](https://github.com/angular/angular/edit/main/adev/src/content/guide/signals/overview.md \"Edit this page\")\n\nAngular Signals is a system that granularly tracks how and where your state is used throughout an application, allowing the framework to optimize rendering updates.\n\n**TIP:** Check out Angular's [Essentials](https://angular.dev/guide/essentials/signals) before diving into this comprehensive guide.\n\n## [What are signals?](https://angular.dev/guide/signals\\#what-are-signals)\n\nA **signal** is a wrapper around a value that notifies interested consumers when that value changes. Signals can contain any value, from primitives to complex data structures.\n\nYou read a signal's value by calling its getter function, which allows Angular to track where the signal is used.\n\nSignals may be either _writable_ or _read-only_.\n\n### [Writable signals](https://angular.dev/guide/signals\\#writable-signals)\n\nWritable signals provide an API for updating their values directly. You create writable signals by calling the `signal` function with the signal's initial value:\n\n```\n      const count = signal(0);// Signals are getter functions - calling them reads their value.console.log('The count is: ' + count());\n\n```\n\ncheck\n\nTo change the value of a writable signal, either `.set()` it directly:\n\n```\n      count.set(3);\n\n```\n\ncheck\n\nor use the `.update()` operation to compute a new value from the previous one:\n\n```\n      // Increment the count by 1.count.update(value => value + 1);\n\n```\n\ncheck\n\nWritable signals have the type `WritableSignal`.\n\n### [Computed signals](https://angular.dev/guide/signals\\#computed-signals)\n\n**Computed signal** are read-only signals that derive their value from other signals. You define computed signals using the `computed` function and specifying a derivation:\n\n```\n      const count: WritableSignal<number> = signal(0);const doubleCount: Signal<number> = computed(() => count() * 2);\n\n```\n\ncheck\n\nThe `doubleCount` signal depends on the `count` signal. Whenever `count` updates, Angular knows that `doubleCount` needs to update as well.\n\n#### [Computed signals are both lazily evaluated and memoized](https://angular.dev/guide/signals\\#computed-signals-are-both-lazily-evaluated-and-memoized)\n\n`doubleCount`'s derivation function does not run to calculate its value until the first time you read `doubleCount`. The calculated value is then cached, and if you read `doubleCount` again, it will return the cached value without recalculating.\n\nIf you then change `count`, Angular knows that `doubleCount`'s cached value is no longer valid, and the next time you read `doubleCount` its new value will be calculated.\n\nAs a result, you can safely perform computationally expensive derivations in computed signals, such as filtering arrays.\n\n#### [Computed signals are not writable signals](https://angular.dev/guide/signals\\#computed-signals-are-not-writable-signals)\n\nYou cannot directly assign values to a computed signal. That is,\n\n```\n      doubleCount.set(3);\n\n```\n\ncheck\n\nproduces a compilation error, because `doubleCount` is not a `WritableSignal`.\n\n#### [Computed signal dependencies are dynamic](https://angular.dev/guide/signals\\#computed-signal-dependencies-are-dynamic)\n\nOnly the signals actually read during the derivation are tracked. For example, in this `computed` the `count` signal is only read if the `showCount` signal is true:\n\n```\n      const showCount = signal(false);const count = signal(0);const conditionalCount = computed(() => {  if (showCount()) {    return `The count is ${count()}.`;  } else {    return 'Nothing to see here!';  }});\n\n```\n\ncheck\n\nWhen you read `conditionalCount`, if `showCount` is `false` the \"Nothing to see here!\" message is returned _without_ reading the `count` signal. This means that if you later update `count` it will _not_ result in a recomputation of `conditionalCount`.\n\nIf you set `showCount` to `true` and then read `conditionalCount` again, the derivation will re-execute and take the branch where `showCount` is `true`, returning the message which shows the value of `count`. Changing `count` will then invalidate `conditionalCount`'s cached value.\n\nNote that dependencies can be removed during a derivation as well as added. If you later set `showCount` back to `false`, then `count` will no longer be considered a dependency of `conditionalCount`.\n\n## [Reading signals in `OnPush` components](https://angular.dev/guide/signals\\#reading-signals-in-onpush-components)\n\nWhen you read a signal within an `OnPush` component's template, Angular tracks the signal as a dependency of that component. When the value of that signal changes, Angular automatically [marks](https://angular.dev/guide/api/core/ChangeDetectorRef#markforcheck) the component to ensure it gets updated the next time change detection runs. Refer to the [Skipping component subtrees](https://angular.dev/guide/best-practices/skipping-subtrees) guide for more information about `OnPush` components.\n\n## [Effects](https://angular.dev/guide/signals\\#effects)\n\nSignals are useful because they notify interested consumers when they change. An **effect** is an operation that runs whenever one or more signal values change. You can create an effect with the `effect` function:\n\n```\n      effect(() => {  console.log(`The current count is: ${count()}`);});\n\n```\n\ncheck\n\nEffects always run **at least once.** When an effect runs, it tracks any signal value reads. Whenever any of these signal values change, the effect runs again. Similar to computed signals, effects keep track of their dependencies dynamically, and only track signals which were read in the most recent execution.\n\nEffects always execute **asynchronously**, during the change detection process.\n\n### [Use cases for effects](https://angular.dev/guide/signals\\#use-cases-for-effects)\n\nEffects are rarely needed in most application code, but may be useful in specific circumstances. Here are some examples of situations where an `effect` might be a good solution:\n\n- Logging data being displayed and when it changes, either for analytics or as a debugging tool.\n- Keeping data in sync with `window.localStorage`.\n- Adding custom DOM behavior that can't be expressed with template syntax.\n- Performing custom rendering to a `<canvas>`, charting library, or other third party UI library.\n\n### When not to use effects\n\nAvoid using effects for propagation of state changes. This can result in `ExpressionChangedAfterItHasBeenChecked` errors, infinite circular updates, or unnecessary change detection cycles.\n\nInstead, use `computed` signals to model state that depends on other state.\n\n### [Injection context](https://angular.dev/guide/signals\\#injection-context)\n\nBy default, you can only create an `effect()` within an [injection context](https://angular.dev/guide/guide/di/dependency-injection-context) (where you have access to the `inject` function). The easiest way to satisfy this requirement is to call `effect` within a component, directive, or service `constructor`:\n\n```\n      @Component({...})export class EffectiveCounterComponent {  readonly count = signal(0);  constructor() {    // Register a new effect.    effect(() => {      console.log(`The count is: ${this.count()}`);    });  }}\n\n```\n\ncheck\n\nAlternatively, you can assign the effect to a field (which also gives it a descriptive name).\n\n```\n      @Component({...})export class EffectiveCounterComponent {  readonly count = signal(0);  private loggingEffect = effect(() => {    console.log(`The count is: ${this.count()}`);  });}\n\n```\n\ncheck\n\nTo create an effect outside the constructor, you can pass an `Injector` to `effect` via its options:\n\n```\n      @Component({...})export class EffectiveCounterComponent {  readonly count = signal(0);  private injector = inject(Injector);  initializeLogging(): void {    effect(() => {      console.log(`The count is: ${this.count()}`);    }, {injector: this.injector});  }}\n\n```\n\ncheck\n\n### [Destroying effects](https://angular.dev/guide/signals\\#destroying-effects)\n\nWhen you create an effect, it is automatically destroyed when its enclosing context is destroyed. This means that effects created within components are destroyed when the component is destroyed. The same goes for effects within directives, services, etc.\n\nEffects return an `EffectRef` that you can use to destroy them manually, by calling the `.destroy()` method. You can combine this with the `manualCleanup` option to create an effect that lasts until it is manually destroyed. Be careful to actually clean up such effects when they're no longer required.\n\n## [Advanced topics](https://angular.dev/guide/signals\\#advanced-topics)\n\n### [Signal equality functions](https://angular.dev/guide/signals\\#signal-equality-functions)\n\nWhen creating a signal, you can optionally provide an equality function, which will be used to check whether the new value is actually different than the previous one.\n\n```\n      import _ from 'lodash';const data = signal(['test'], {equal: _.isEqual});// Even though this is a different array instance, the deep equality// function will consider the values to be equal, and the signal won't// trigger any updates.data.set(['test']);\n\n```\n\ncheck\n\nEquality functions can be provided to both writable and computed signals.\n\n**HELPFUL:** By default, signals use referential equality ( [`Object.is()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison).\n\n### [Reading without tracking dependencies](https://angular.dev/guide/signals\\#reading-without-tracking-dependencies)\n\nRarely, you may want to execute code which may read signals within a reactive function such as `computed` or `effect` _without_ creating a dependency.\n\nFor example, suppose that when `currentUser` changes, the value of a `counter` should be logged. you could create an `effect` which reads both signals:\n\n```\n      effect(() => {  console.log(`User set to ${currentUser()} and the counter is ${counter()}`);});\n\n```\n\ncheck\n\nThis example will log a message when _either_ `currentUser` or `counter` changes. However, if the effect should only run when `currentUser` changes, then the read of `counter` is only incidental and changes to `counter` shouldn't log a new message.\n\nYou can prevent a signal read from being tracked by calling its getter with `untracked`:\n\n```\n      effect(() => {  console.log(`User set to ${currentUser()} and the counter is ${untracked(counter)}`);});\n\n```\n\ncheck\n\n`untracked` is also useful when an effect needs to invoke some external code which shouldn't be treated as a dependency:\n\n```\n      effect(() => {  const user = currentUser();  untracked(() => {    // If the `loggingService` reads signals, they won't be counted as    // dependencies of this effect.    this.loggingService.log(`User set to ${user}`);  });});\n\n```\n\ncheck\n\n### [Effect cleanup functions](https://angular.dev/guide/signals\\#effect-cleanup-functions)\n\nEffects might start long-running operations, which you should cancel if the effect is destroyed or runs again before the first operation finished. When you create an effect, your function can optionally accept an `onCleanup` function as its first parameter. This `onCleanup` function lets you register a callback that is invoked before the next run of the effect begins, or when the effect is destroyed.\n\n```\n      effect((onCleanup) => {  const user = currentUser();  const timer = setTimeout(() => {    console.log(`1 second ago, the user became ${user}`);  }, 1000);  onCleanup(() => {    clearTimeout(timer);  });});\n\n```\n\ncheck\n\n## [Using signals with RxJS](https://angular.dev/guide/signals\\#using-signals-with-rxjs)\n\nSee [RxJS interop with Angular signals](https://angular.dev/guide/ecosystem/rxjs-interop) for details on interoperability between signals and RxJS.",
  "title": "Signals \u2022 Overview \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "signals",
    "angular",
    "https",
    "dev",
    "signal",
    "effect",
    "count",
    "guide",
    "value",
    "computed"
  ],
  "sourceURL": "https://angular.dev/guide/signals"
}