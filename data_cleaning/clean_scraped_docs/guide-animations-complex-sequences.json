{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backAnimations\n  - [Overview](https://angular.dev/guide/animations)\n  - [Transition and Triggers](https://angular.dev/guide/animations/transition-and-triggers)\n  - [Complex Sequences](https://angular.dev/guide/animations/complex-sequences)\n  - [Reusable Animations](https://angular.dev/guide/animations/reusable-animations)\n  - [Route transition animations](https://angular.dev/guide/animations/route-animations)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nSo far, we've learned simple animations of single HTML elements.\nAngular also lets you animate coordinated sequences, such as an entire grid or list of elements as they enter and leave a page.\nYou can choose to run multiple animations in parallel, or run discrete animations sequentially, one following another.\n\nThe functions that control complex animation sequences are:\n\n| Functions | Details |\n| :-- | :-- |\n| `query()` | Finds one or more inner HTML elements. |\n| `stagger()` | Applies a cascading delay to animations for multiple elements. |\n| [`group()`](https://angular.dev/guide/animations/api/animations/group) | Runs multiple animation steps in parallel. |\n| `sequence()` | Runs animation steps one after another. |\n\n## [The query() function](https://angular.dev/guide/animations/complex-sequences\\#the-query-function)\n\nMost complex animations rely on the `query()` function to find child elements and apply animations to them, basic examples of such are:\n\n| Examples | Details |\n| :-- | :-- |\n| `query()` followed by `animate()` | Used to query simple HTML elements and directly apply animations to them. |\n| `query()` followed by `animateChild()` | Used to query child elements, which themselves have animations metadata applied to them and trigger such animation (which would be otherwise be blocked by the current/parent element's animation). |\n\nThe first argument of `query()` is a [css selector](https://developer.mozilla.org/docs/Web/CSS/CSS_Selectors) string which can also contain the following Angular-specific tokens:\n\n| Tokens | Details |\n| :-- | :-- |\n| `:enter`<br>`:leave` | For entering/leaving elements. |\n| `:animating` | For elements currently animating. |\n| `@*`<br>`@triggerName` | For elements with any\u2014or a specific\u2014trigger. |\n| `:self` | The animating element itself. |\n\n### Entering and Leaving Elements\n\nNot all child elements are actually considered as entering/leaving; this can, at times, be counterintuitive and confusing. Please see the [query api docs](https://angular.dev/guide/animations/api/animations/query#entering-and-leaving-elements) for more information.\n\nYou can also see an illustration of this in the animations example (introduced in the animations [introduction section](https://angular.dev/guide/animations/guide/animations#about-this-guide)) under the Querying tab.\n\n## [Animate multiple elements using query() and stagger() functions](https://angular.dev/guide/animations/complex-sequences\\#animate-multiple-elements-using-query-and-stagger-functions)\n\nAfter having queried child elements via `query()`, the `stagger()` function lets you define a timing gap between each queried item that is animated and thus animates elements with a delay between them.\n\nThe following example demonstrates how to use the `query()` and `stagger()` functions to animate a list (of heroes) adding each in sequence, with a slight delay, from top to bottom.\n\n- Use `query()` to look for an element entering the page that meets certain criteria\n\n- For each of these elements, use `style()` to set the same initial style for the element.\nMake it transparent and use `transform` to move it out of position so that it can slide into place.\n\n- Use `stagger()` to delay each animation by 30 milliseconds\n\n- Animate each element on screen for 0.5 seconds using a custom-defined easing curve, simultaneously fading it in and un-transforming it\n\n\ncheck\n\n```\n      import {Component, HostBinding, OnInit} from '@angular/core';import {trigger, transition, animate, style, query, stagger} from '@angular/animations';import {HEROES} from './mock-heroes';import {Hero} from './hero';@Component({  selector: 'app-hero-list-page',  templateUrl: 'hero-list-page.component.html',  styleUrls: ['hero-list-page.component.css'],  animations: [    trigger('pageAnimations', [      transition(':enter', [        query('.hero', [          style({opacity: 0, transform: 'translateY(-100px)'}),          stagger(30, [            animate('500ms cubic-bezier(0.35, 0, 0.25, 1)', style({opacity: 1, transform: 'none'})),          ]),        ]),      ]),    ]),    trigger('filterAnimation', [      transition(':enter, * => 0, * => -1', []),      transition(':increment', [        query(          ':enter',          [            style({opacity: 0, width: 0}),            stagger(50, [animate('300ms ease-out', style({opacity: 1, width: '*'}))]),          ],          {optional: true},        ),      ]),      transition(':decrement', [        query(':leave', [stagger(50, [animate('300ms ease-out', style({opacity: 0, width: 0}))])]),      ]),    ]),  ],})export class HeroListPageComponent implements OnInit {  @HostBinding('@pageAnimations')  public animatePage = true;  heroesTotal = -1;  get heroes() {    return this._heroes;  }  private _heroes: Hero[] = [];  ngOnInit() {    this._heroes = HEROES;  }  updateCriteria(criteria: string) {    criteria = criteria ? criteria.trim() : '';    this._heroes = HEROES.filter((hero) =>      hero.name.toLowerCase().includes(criteria.toLowerCase()),    );    const newTotal = this.heroes.length;    if (this.heroesTotal !== newTotal) {      this.heroesTotal = newTotal;    } else if (!criteria) {      this.heroesTotal = -1;    }  }}\n\n```\n\n## [Parallel animation using group() function](https://angular.dev/guide/animations/complex-sequences\\#parallel-animation-using-group-function)\n\nYou've seen how to add a delay between each successive animation.\nBut you might also want to configure animations that happen in parallel.\nFor example, you might want to animate two CSS properties of the same element but use a different `easing` function for each one.\nFor this, you can use the animation [`group()`](https://angular.dev/guide/animations/api/animations/group) function.\n\n**HELPFUL:** The [`group()`](https://angular.dev/guide/animations/api/animations/group) function is used to group animation _steps_, rather than animated elements.\n\nThe following example uses [`group()`](https://angular.dev/guide/animations/api/animations/group) s on both `:enter` and `:leave` for two different timing configurations, thus applying two independent animations to the same element in parallel.\n\ncheck\n\n```\n      import {Component, Input, Output, EventEmitter} from '@angular/core';import {trigger, state, style, animate, transition, group} from '@angular/animations';import {Hero} from './hero';@Component({  selector: 'app-hero-list-groups',  template: `    <ul class=\"heroes\">      @for (hero of heroes; track hero) {        <li [@flyInOut]=\"'in'\">          <button class=\"inner\" type=\"button\" (click)=\"removeHero(hero.id)\">            <span class=\"badge\">{{ hero.id }}</span>            <span class=\"name\">{{ hero.name }}</span>          </button>        </li>      }    </ul>  `,  styleUrls: ['./hero-list-page.component.css'],  animations: [    trigger('flyInOut', [      state(        'in',        style({          width: '*',          transform: 'translateX(0)',          opacity: 1,        }),      ),      transition(':enter', [        style({width: 10, transform: 'translateX(50px)', opacity: 0}),        group([          animate(            '0.3s 0.1s ease',            style({              transform: 'translateX(0)',              width: '*',            }),          ),          animate(            '0.3s ease',            style({              opacity: 1,            }),          ),        ]),      ]),      transition(':leave', [        group([          animate(            '0.3s ease',            style({              transform: 'translateX(50px)',              width: 10,            }),          ),          animate(            '0.3s 0.2s ease',            style({              opacity: 0,            }),          ),        ]),      ]),    ]),  ],})export class HeroListGroupsComponent {  @Input() heroes: Hero[] = [];  @Output() remove = new EventEmitter<number>();  removeHero(id: number) {    this.remove.emit(id);  }}\n\n```\n\n## [Sequential vs. parallel animations](https://angular.dev/guide/animations/complex-sequences\\#sequential-vs-parallel-animations)\n\nComplex animations can have many things happening at once.\nBut what if you want to create an animation involving several animations happening one after the other? Earlier you used [`group()`](https://angular.dev/guide/animations/api/animations/group) to run multiple animations all at the same time, in parallel.\n\nA second function called `sequence()` lets you run those same animations one after the other.\nWithin `sequence()`, the animation steps consist of either `style()` or `animate()` function calls.\n\n- Use `style()` to apply the provided styling data immediately.\n- Use `animate()` to apply styling data over a given time interval.\n\n## [Filter animation example](https://angular.dev/guide/animations/complex-sequences\\#filter-animation-example)\n\nTake a look at another animation on the example page.\nUnder the Filter/Stagger tab, enter some text into the **Search Heroes** text box, such as `Magnet` or `tornado`.\n\nThe filter works in real time as you type.\nElements leave the page as you type each new letter and the filter gets progressively stricter.\nThe heroes list gradually re-enters the page as you delete each letter in the filter box.\n\nThe HTML template contains a trigger called `filterAnimation`.\n\ncheck\n\n```\n      <h2>Filter/Stagger</h2><label for=\"search\">Search heroes: </label><input type=\"text\" id=\"search\" #criteria       (input)=\"updateCriteria(criteria.value)\"       placeholder=\"Search heroes\"><ul class=\"heroes\" [@filterAnimation]=\"heroesTotal\">  @for (hero of heroes; track hero) {    <li class=\"hero\">      <div class=\"inner\">        <span class=\"badge\">{{ hero.id }}</span>        <span class=\"name\">{{ hero.name }}</span>      </div>    </li>  }</ul>\n\n```\n\nThe `filterAnimation` in the component's decorator contains three transitions.\n\ncheck\n\n```\n      import {Component, HostBinding, OnInit} from '@angular/core';import {trigger, transition, animate, style, query, stagger} from '@angular/animations';import {HEROES} from './mock-heroes';import {Hero} from './hero';@Component({  selector: 'app-hero-list-page',  templateUrl: 'hero-list-page.component.html',  styleUrls: ['hero-list-page.component.css'],\n...  animations: [    trigger('pageAnimations', [      transition(':enter', [        query('.hero', [          style({opacity: 0, transform: 'translateY(-100px)'}),          stagger(30, [            animate('500ms cubic-bezier(0.35, 0, 0.25, 1)', style({opacity: 1, transform: 'none'})),          ]),        ]),      ]),    ]),\\\n...    trigger('filterAnimation', [      transition(':enter, * => 0, * => -1', []),      transition(':increment', [        query(          ':enter',          [            style({opacity: 0, width: 0}),            stagger(50, [animate('300ms ease-out', style({opacity: 1, width: '*'}))]),          ],          {optional: true},        ),      ]),      transition(':decrement', [        query(':leave', [stagger(50, [animate('300ms ease-out', style({opacity: 0, width: 0}))])]),      ]),    ]),  ],})export class HeroListPageComponent implements OnInit {  @HostBinding('@pageAnimations')  public animatePage = true;\n...  heroesTotal = -1;  get heroes() {    return this._heroes;  }  private _heroes: Hero[] = [];  ngOnInit() {    this._heroes = HEROES;  }  updateCriteria(criteria: string) {    criteria = criteria ? criteria.trim() : '';    this._heroes = HEROES.filter((hero) =>      hero.name.toLowerCase().includes(criteria.toLowerCase()),    );    const newTotal = this.heroes.length;    if (this.heroesTotal !== newTotal) {      this.heroesTotal = newTotal;    } else if (!criteria) {      this.heroesTotal = -1;    }  }}\n\n```\n\nThe code in this example performs the following tasks:\n\n- Skips animations when the user first opens or navigates to this page (the filter animation narrows what is already there, so it only works on elements that already exist in the DOM)\n- Filters heroes based on the search input's value\n\nFor each change:\n\n- Hides an element leaving the DOM by setting its opacity and width to 0\n\n- Animates an element entering the DOM over 300 milliseconds.\nDuring the animation, the element assumes its default width and opacity.\n\n- If there are multiple elements entering or leaving the DOM, staggers each animation starting at the top of the page, with a 50-millisecond delay between each element\n\n\n## [Animating the items of a reordering list](https://angular.dev/guide/animations/complex-sequences\\#animating-the-items-of-a-reordering-list)\n\nAlthough Angular animates correctly `*ngFor` list items out of the box, it will not be able to do so if their ordering changes.\nThis is because it will lose track of which element is which, resulting in broken animations.\nThe only way to help Angular keep track of such elements is by assigning a `TrackByFunction` to the `NgForOf` directive.\nThis makes sure that Angular always knows which element is which, thus allowing it to apply the correct animations to the correct elements all the time.\n\n**IMPORTANT:** If you need to animate the items of an `*ngFor` list and there is a possibility that the order of such items will change during runtime, always use a `TrackByFunction`.\n\n## [Animations and Component View Encapsulation](https://angular.dev/guide/animations/complex-sequences\\#animations-and-component-view-encapsulation)\n\nAngular animations are based on the components DOM structure and do not directly take [View Encapsulation](https://angular.dev/guide/animations/guide/components/styling#style-scoping) into account, this means that components using `ViewEncapsulation.Emulated` behave exactly as if they were using `ViewEncapsulation.None` ( `ViewEncapsulation.ShadowDom` behaves differently as we'll discuss shortly).\n\nFor example if the `query()` function (which you'll see more of in the rest of the Animations guide) were to be applied at the top of a tree of components using the emulated view encapsulation, such query would be able to identify (and thus animate) DOM elements on any depth of the tree.\n\nOn the other hand the `ViewEncapsulation.ShadowDom` changes the component's DOM structure by \"hiding\" DOM elements inside [`ShadowRoot`](https://developer.mozilla.org/docs/Web/API/ShadowRoot) elements. Such DOM manipulations do prevent some of the animations implementation to work properly since it relies on simple DOM structures and doesn't take `ShadowRoot` elements into account. Therefore it is advised to avoid applying animations to views incorporating components using the ShadowDom view encapsulation.\n\n## [Animation sequence summary](https://angular.dev/guide/animations/complex-sequences\\#animation-sequence-summary)\n\nAngular functions for animating multiple elements start with `query()` to find inner elements; for example, gathering all images within a `<div>`.\nThe remaining functions, `stagger()`, [`group()`](https://angular.dev/guide/animations/api/animations/group), and `sequence()`, apply cascades or let you control how multiple animation steps are applied.\n\n## [More on Angular animations](https://angular.dev/guide/animations/complex-sequences\\#more-on-angular-animations)\n\nYou might also be interested in the following:",
  "title": "Complex Sequences \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "animations",
    "angular",
    "https",
    "dev",
    "hero",
    "elements",
    "guide",
    "query",
    "style",
    "animate"
  ],
  "sourceURL": "https://angular.dev/guide/animations/complex-sequences"
}