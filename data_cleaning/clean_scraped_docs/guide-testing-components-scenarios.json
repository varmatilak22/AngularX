{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backTesting\n  - [Overview](https://angular.dev/guide/testing)\n  - [Code coverage](https://angular.dev/guide/testing/code-coverage)\n  - [Testing services](https://angular.dev/guide/testing/services)\n  - [Basics of testing components](https://angular.dev/guide/testing/components-basics)\n  - [Component testing scenarios](https://angular.dev/guide/testing/components-scenarios)\n  - [Testing attribute directives](https://angular.dev/guide/testing/attribute-directives)\n  - [Testing pipes](https://angular.dev/guide/testing/pipes)\n  - [Debugging tests](https://angular.dev/guide/testing/debugging)\n  - [Testing utility APIs](https://angular.dev/guide/testing/utility-apis)\n  - [Component harnesses overview](https://angular.dev/guide/testing/component-harnesses-overview)\n  - [Using component harnesses in tests](https://angular.dev/guide/testing/using-component-harnesses)\n  - [Creating harnesses for your components](https://angular.dev/guide/testing/creating-component-harnesses)\n  - [Adding harness support for additional testing environments](https://angular.dev/guide/testing/component-harnesses-testing-environments)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nThis guide explores common component testing use cases.\n\n## [Component binding](https://angular.dev/guide/testing/components-scenarios\\#component-binding)\n\nIn the example application, the `BannerComponent` presents static title text in the HTML template.\n\nAfter a few changes, the `BannerComponent` presents a dynamic title by binding to the component's `title` property like this.\n\ncheck\n\n```\n      import {Component, signal} from '@angular/core';@Component({  selector: 'app-banner',  template: '<h1>{{title()}}</h1>',  styles: ['h1 { color: green; font-size: 350%}'],})export class BannerComponent {  title = signal('Test Tour of Heroes');}\n\n```\n\nAs minimal as this is, you decide to add a test to confirm that component actually displays the right content where you think it should.\n\n### [Query for the `<h1>`](https://angular.dev/guide/testing/components-scenarios\\#query-for-the-h1)\n\nYou'll write a sequence of tests that inspect the value of the `<h1>` element that wraps the _title_ property interpolation binding.\n\nYou update the `beforeEach` to find that element with a standard HTML `querySelector` and assign it to the `h1` variable.\n\ncheck\n\n```\n      import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (inline template)', () => {  let component: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      imports: [BannerComponent],    });    fixture = TestBed.createComponent(BannerComponent);    component = fixture.componentInstance; // BannerComponent test instance    h1 = fixture.nativeElement.querySelector('h1');  });  it('no title in the DOM after createComponent()', () => {    expect(h1.textContent).toEqual('');  });  it('should display original title', () => {    fixture.detectChanges();    expect(h1.textContent).toContain(component.title);  });  it('should display original title after detectChanges()', () => {    fixture.detectChanges();    expect(h1.textContent).toContain(component.title);  });  it('should display a different test title', () => {    component.title = 'Test Title';    fixture.detectChanges();    expect(h1.textContent).toContain('Test Title');  });});\n\n```\n\n### [`createComponent()` does not bind data](https://angular.dev/guide/testing/components-scenarios\\#createcomponent-does-not-bind-data)\n\nFor your first test you'd like to see that the screen displays the default `title`.\nYour instinct is to write a test that immediately inspects the `<h1>` like this:\n\ncheck\n\n```\n      import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (inline template)', () => {  let component: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      imports: [BannerComponent],    });    fixture = TestBed.createComponent(BannerComponent);    component = fixture.componentInstance; // BannerComponent test instance    h1 = fixture.nativeElement.querySelector('h1');  });  it('no title in the DOM after createComponent()', () => {    expect(h1.textContent).toEqual('');  });  it('should display original title', () => {    fixture.detectChanges();\n...    expect(h1.textContent).toContain(component.title);  });  it('should display original title after detectChanges()', () => {    fixture.detectChanges();    expect(h1.textContent).toContain(component.title);  });  it('should display a different test title', () => {    component.title = 'Test Title';    fixture.detectChanges();    expect(h1.textContent).toContain('Test Title');  });});\n\n```\n\n_That test fails_ with the message:\n\n```\n      expected '' to contain 'Test Tour of Heroes'.\n\n```\n\ncheck\n\nBinding happens when Angular performs **change detection**.\n\nIn production, change detection kicks in automatically when Angular creates a component or the user enters a keystroke, for example.\n\nThe `TestBed.createComponent` does not trigger change detection by default; a fact confirmed in the revised test:\n\ncheck\n\n```\n      import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (inline template)', () => {  let component: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      imports: [BannerComponent],    });    fixture = TestBed.createComponent(BannerComponent);    component = fixture.componentInstance; // BannerComponent test instance    h1 = fixture.nativeElement.querySelector('h1');  });  it('no title in the DOM after createComponent()', () => {    expect(h1.textContent).toEqual('');  });  it('should display original title', () => {    fixture.detectChanges();    expect(h1.textContent).toContain(component.title);  });  it('should display original title after detectChanges()', () => {    fixture.detectChanges();    expect(h1.textContent).toContain(component.title);  });  it('should display a different test title', () => {    component.title = 'Test Title';    fixture.detectChanges();    expect(h1.textContent).toContain('Test Title');  });});\n\n```\n\n### [`detectChanges()`](https://angular.dev/guide/testing/components-scenarios\\#detectchanges)\n\nYou can tell the `TestBed` to perform data binding by calling `fixture.detectChanges()`.\nOnly then does the `<h1>` have the expected title.\n\ncheck\n\n```\n      import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (inline template)', () => {  let component: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      imports: [BannerComponent],    });    fixture = TestBed.createComponent(BannerComponent);    component = fixture.componentInstance; // BannerComponent test instance    h1 = fixture.nativeElement.querySelector('h1');  });  it('no title in the DOM after createComponent()', () => {    expect(h1.textContent).toEqual('');  });  it('should display original title', () => {    fixture.detectChanges();    expect(h1.textContent).toContain(component.title);  });  it('should display original title after detectChanges()', () => {    fixture.detectChanges();    expect(h1.textContent).toContain(component.title);  });  it('should display a different test title', () => {    component.title = 'Test Title';    fixture.detectChanges();    expect(h1.textContent).toContain('Test Title');  });});\n\n```\n\nDelayed change detection is intentional and useful.\nIt gives the tester an opportunity to inspect and change the state of the component _before Angular initiates data binding and calls [lifecycle hooks](https://angular.dev/guide/testing/guide/components/lifecycle)_.\n\nHere's another test that changes the component's `title` property _before_ calling `fixture.detectChanges()`.\n\ncheck\n\n```\n      import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (inline template)', () => {  let component: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      imports: [BannerComponent],    });    fixture = TestBed.createComponent(BannerComponent);    component = fixture.componentInstance; // BannerComponent test instance    h1 = fixture.nativeElement.querySelector('h1');  });  it('no title in the DOM after createComponent()', () => {    expect(h1.textContent).toEqual('');  });  it('should display original title', () => {    fixture.detectChanges();    expect(h1.textContent).toContain(component.title);  });  it('should display original title after detectChanges()', () => {    fixture.detectChanges();    expect(h1.textContent).toContain(component.title);  });  it('should display a different test title', () => {    component.title = 'Test Title';    fixture.detectChanges();    expect(h1.textContent).toContain('Test Title');  });});\n\n```\n\n### [Automatic change detection](https://angular.dev/guide/testing/components-scenarios\\#automatic-change-detection)\n\nThe `BannerComponent` tests frequently call `detectChanges`.\nMany testers prefer that the Angular test environment run change detection automatically like it does in production.\n\nThat's possible by configuring the `TestBed` with the `ComponentFixtureAutoDetect` provider.\nFirst import it from the testing utility library:\n\ncheck\n\n```\n      import {ComponentFixtureAutoDetect} from '@angular/core/testing';import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (AutoChangeDetect)', () => {  let comp: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],    });    fixture = TestBed.createComponent(BannerComponent);    comp = fixture.componentInstance;    h1 = fixture.nativeElement.querySelector('h1');  });  it('should display original title', () => {    // Hooray! No `fixture.detectChanges()` needed    expect(h1.textContent).toContain(comp.title);  });  it('should still see original title after comp.title change', async () => {    const oldTitle = comp.title;    const newTitle = 'Test Title';    comp.title.set(newTitle);    // Displayed title is old because Angular didn't yet run change detection    expect(h1.textContent).toContain(oldTitle);    await fixture.whenStable();    expect(h1.textContent).toContain(newTitle);  });  it('should display updated title after detectChanges', () => {    comp.title.set('Test Title');    fixture.detectChanges(); // detect changes explicitly    expect(h1.textContent).toContain(comp.title);  });});\n\n```\n\nThen add it to the `providers` array of the testing module configuration:\n\ncheck\n\n```\n      import {ComponentFixtureAutoDetect} from '@angular/core/testing';import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (AutoChangeDetect)', () => {  let comp: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],    });    fixture = TestBed.createComponent(BannerComponent);    comp = fixture.componentInstance;    h1 = fixture.nativeElement.querySelector('h1');  });  it('should display original title', () => {    // Hooray! No `fixture.detectChanges()` needed    expect(h1.textContent).toContain(comp.title);  });  it('should still see original title after comp.title change', async () => {    const oldTitle = comp.title;    const newTitle = 'Test Title';    comp.title.set(newTitle);    // Displayed title is old because Angular didn't yet run change detection    expect(h1.textContent).toContain(oldTitle);    await fixture.whenStable();    expect(h1.textContent).toContain(newTitle);  });  it('should display updated title after detectChanges', () => {    comp.title.set('Test Title');    fixture.detectChanges(); // detect changes explicitly    expect(h1.textContent).toContain(comp.title);  });});\n\n```\n\n**HELPFUL:** You can also use the `fixture.autoDetectChanges()` function instead if you only want to enable automatic change detection\nafter making updates to the state of the fixture's component. In addition, automatic change detection is on by default\nwhen using `provideExperimentalZonelessChangeDetection` and turning it off is not recommended.\n\nHere are three tests that illustrate how automatic change detection works.\n\ncheck\n\n```\n      import {ComponentFixtureAutoDetect} from '@angular/core/testing';import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (AutoChangeDetect)', () => {  let comp: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],    });    fixture = TestBed.createComponent(BannerComponent);    comp = fixture.componentInstance;    h1 = fixture.nativeElement.querySelector('h1');  });  it('should display original title', () => {    // Hooray! No `fixture.detectChanges()` needed    expect(h1.textContent).toContain(comp.title);  });  it('should still see original title after comp.title change', async () => {    const oldTitle = comp.title;    const newTitle = 'Test Title';    comp.title.set(newTitle);    // Displayed title is old because Angular didn't yet run change detection    expect(h1.textContent).toContain(oldTitle);    await fixture.whenStable();    expect(h1.textContent).toContain(newTitle);  });  it('should display updated title after detectChanges', () => {    comp.title.set('Test Title');    fixture.detectChanges(); // detect changes explicitly    expect(h1.textContent).toContain(comp.title);  });});\n\n```\n\nThe first test shows the benefit of automatic change detection.\n\nThe second and third test reveal an important limitation.\nThe Angular testing environment does not run change detection synchronously when updates happen inside the test case that changed the component's `title`.\nThe test must call `await fixture.whenStable` to wait for another round of change detection.\n\n**HELPFUL:** Angular does not know about direct updates to values that are not signals. The easiest way to ensure that\nchange detection will be scheduled is to use signals for values read in the template.\n\n### [Change an input value with `dispatchEvent()`](https://angular.dev/guide/testing/components-scenarios\\#change-an-input-value-with-dispatchevent)\n\nTo simulate user input, find the input element and set its `value` property.\n\nBut there is an essential, intermediate step.\n\nAngular doesn't know that you set the input element's `value` property.\nIt won't read that property until you raise the element's `input` event by calling `dispatchEvent()`.\n\nThe following example demonstrates the proper sequence.\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\n## [Component with external files](https://angular.dev/guide/testing/components-scenarios\\#component-with-external-files)\n\nThe preceding `BannerComponent` is defined with an _inline template_ and _inline css_, specified in the `@Component.template` and `@Component.styles` properties respectively.\n\nMany components specify _external templates_ and _external css_ with the `@Component.templateUrl` and `@Component.styleUrls` properties respectively, as the following variant of `BannerComponent` does.\n\ncheck\n\n```\n      import {Component} from '@angular/core';@Component({  selector: 'app-banner',  templateUrl: './banner-external.component.html',  styleUrls: ['./banner-external.component.css'],})export class BannerComponent {  title = 'Test Tour of Heroes';}\n\n```\n\nThis syntax tells the Angular compiler to read the external files during component compilation.\n\nThat's not a problem when you run the CLI `ng test` command because it _compiles the application before running the tests_.\n\nHowever, if you run the tests in a **non-CLI environment**, tests of this component might fail.\nFor example, if you run the `BannerComponent` tests in a web coding environment such as [plunker](https://plnkr.co/), you'll see a message like this one:\n\n```\n      Error: This test module uses the component BannerComponentwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.Please call \"TestBed.compileComponents\" before your test.\n\n```\n\ncheck\n\nYou get this test failure message when the runtime environment compiles the source code _during the tests themselves_.\n\nTo correct the problem, call `compileComponents()` as explained in the following [Calling compileComponents](https://angular.dev/guide/testing/components-scenarios#calling-compilecomponents) section.\n\n## [Component with a dependency](https://angular.dev/guide/testing/components-scenarios\\#component-with-a-dependency)\n\nComponents often have service dependencies.\n\nThe `WelcomeComponent` displays a welcome message to the logged-in user.\nIt knows who the user is based on a property of the injected `UserService`:\n\n### app/welcome/welcome.component.ts\n\n```\n      import {Component, inject, OnInit, signal} from '@angular/core';import {UserService} from '../model/user.service';@Component({  selector: 'app-welcome',  template: '<h3 class=\"welcome\"><i>{{welcome()}}</i></h3>',})export class WelcomeComponent {  welcome = signal('');  private userService = inject(UserService);  constructor() {    this.welcome.set(      this.userService.isLoggedIn() ? 'Welcome, ' + this.userService.user().name : 'Please log in.',    );  }}\n\n```\n\ncheck\n\nThe `WelcomeComponent` has decision logic that interacts with the service, logic that makes this component worth testing.\n\n### [Provide service test doubles](https://angular.dev/guide/testing/components-scenarios\\#provide-service-test-doubles)\n\nA _component-under-test_ doesn't have to be provided with real services.\n\nInjecting the real `UserService` could be difficult.\nThe real service might ask the user for login credentials and attempt to reach an authentication server.\nThese behaviors can be hard to intercept. Be aware that using test doubles makes the test behave differently from production so use them sparingly.\n\n### [Get injected services](https://angular.dev/guide/testing/components-scenarios\\#get-injected-services)\n\nThe tests need access to the `UserService` injected into the `WelcomeComponent`.\n\nAngular has a hierarchical injection system.\nThere can be injectors at multiple levels, from the root injector created by the `TestBed` down through the component tree.\n\nThe safest way to get the injected service, the way that _**always works**_,\nis to **get it from the injector of the _component-under-test_**.\nThe component injector is a property of the fixture's `DebugElement`.\n\ncheck\n\n```\n      import {ComponentFixture, inject, TestBed} from '@angular/core/testing';import {UserService} from '../model/user.service';import {WelcomeComponent} from './welcome.component';class MockUserService {  isLoggedIn = true;  user = {name: 'Test User'};}describe('WelcomeComponent', () => {  let comp: WelcomeComponent;  let fixture: ComponentFixture<WelcomeComponent>;  let componentUserService: UserService; // the actually injected service  let userService: UserService; // the TestBed injected service  let el: HTMLElement; // the DOM element with the welcome message  beforeEach(() => {    fixture = TestBed.createComponent(WelcomeComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // UserService actually injected into the component    userService = fixture.debugElement.injector.get(UserService);    componentUserService = userService;    // UserService from the root injector    userService = TestBed.inject(UserService);    //  get the \"welcome\" element by CSS selector (e.g., by class name)    el = fixture.nativeElement.querySelector('.welcome');  });  it('should welcome the user', async () => {    await fixture.whenStable();    const content = el.textContent;    expect(content).withContext('\"Welcome ...\"').toContain('Welcome');    expect(content).withContext('expected name').toContain('Test User');  });  it('should welcome \"Bubba\"', async () => {    userService.user.set({name: 'Bubba'}); // welcome message hasn't been shown yet    await fixture.whenStable();    expect(el.textContent).toContain('Bubba');  });  it('should request login if not logged in', async () => {    userService.isLoggedIn.set(false); // welcome message hasn't been shown yet    await fixture.whenStable();    const content = el.textContent;    expect(content).withContext('not welcomed').not.toContain('Welcome');    expect(content)      .withContext('\"log in\"')      .toMatch(/log in/i);  });  it(\"should inject the component's UserService instance\", inject(    [UserService],    (service: UserService) => {      expect(service).toBe(componentUserService);    },  ));  it('TestBed and Component UserService should be the same', () => {    expect(userService).toBe(componentUserService);  });});\n\n```\n\n**HELPFUL:** This is _usually_ not necessary. Services are often provided in the root or the TestBed overrides and can be retrieved more easily with `TestBed.inject()` (see below).\n\n### [`TestBed.inject()`](https://angular.dev/guide/testing/components-scenarios\\#testbedinject)\n\nThis is easier to remember and less verbose than retrieving a service using the fixture's `DebugElement`.\n\nIn this test suite, the _only_ provider of `UserService` is the root testing module, so it is safe to call `TestBed.inject()` as follows:\n\ncheck\n\n```\n      import {ComponentFixture, inject, TestBed} from '@angular/core/testing';import {UserService} from '../model/user.service';import {WelcomeComponent} from './welcome.component';class MockUserService {  isLoggedIn = true;  user = {name: 'Test User'};}describe('WelcomeComponent', () => {  let comp: WelcomeComponent;  let fixture: ComponentFixture<WelcomeComponent>;  let componentUserService: UserService; // the actually injected service  let userService: UserService; // the TestBed injected service  let el: HTMLElement; // the DOM element with the welcome message  beforeEach(() => {    fixture = TestBed.createComponent(WelcomeComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // UserService actually injected into the component    userService = fixture.debugElement.injector.get(UserService);    componentUserService = userService;    // UserService from the root injector    userService = TestBed.inject(UserService);    //  get the \"welcome\" element by CSS selector (e.g., by class name)    el = fixture.nativeElement.querySelector('.welcome');  });  it('should welcome the user', async () => {    await fixture.whenStable();    const content = el.textContent;    expect(content).withContext('\"Welcome ...\"').toContain('Welcome');    expect(content).withContext('expected name').toContain('Test User');  });  it('should welcome \"Bubba\"', async () => {    userService.user.set({name: 'Bubba'}); // welcome message hasn't been shown yet    await fixture.whenStable();    expect(el.textContent).toContain('Bubba');  });  it('should request login if not logged in', async () => {    userService.isLoggedIn.set(false); // welcome message hasn't been shown yet    await fixture.whenStable();    const content = el.textContent;    expect(content).withContext('not welcomed').not.toContain('Welcome');    expect(content)      .withContext('\"log in\"')      .toMatch(/log in/i);  });  it(\"should inject the component's UserService instance\", inject(    [UserService],    (service: UserService) => {      expect(service).toBe(componentUserService);    },  ));  it('TestBed and Component UserService should be the same', () => {    expect(userService).toBe(componentUserService);  });});\n\n```\n\n**HELPFUL:** For a use case in which `TestBed.inject()` does not work, see the [_Override component providers_](https://angular.dev/guide/testing/components-scenarios#override-component-providers) section that explains when and why you must get the service from the component's injector instead.\n\n### [Final setup and tests](https://angular.dev/guide/testing/components-scenarios\\#final-setup-and-tests)\n\nHere's the complete `beforeEach()`, using `TestBed.inject()`:\n\ncheck\n\n```\n      import {ComponentFixture, inject, TestBed} from '@angular/core/testing';import {UserService} from '../model/user.service';import {WelcomeComponent} from './welcome.component';class MockUserService {  isLoggedIn = true;  user = {name: 'Test User'};}describe('WelcomeComponent', () => {  let comp: WelcomeComponent;  let fixture: ComponentFixture<WelcomeComponent>;  let componentUserService: UserService; // the actually injected service  let userService: UserService; // the TestBed injected service  let el: HTMLElement; // the DOM element with the welcome message  beforeEach(() => {    fixture = TestBed.createComponent(WelcomeComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // UserService actually injected into the component    userService = fixture.debugElement.injector.get(UserService);    componentUserService = userService;    // UserService from the root injector    userService = TestBed.inject(UserService);    //  get the \"welcome\" element by CSS selector (e.g., by class name)    el = fixture.nativeElement.querySelector('.welcome');  });  it('should welcome the user', async () => {    await fixture.whenStable();    const content = el.textContent;    expect(content).withContext('\"Welcome ...\"').toContain('Welcome');    expect(content).withContext('expected name').toContain('Test User');  });  it('should welcome \"Bubba\"', async () => {    userService.user.set({name: 'Bubba'}); // welcome message hasn't been shown yet    await fixture.whenStable();    expect(el.textContent).toContain('Bubba');  });  it('should request login if not logged in', async () => {    userService.isLoggedIn.set(false); // welcome message hasn't been shown yet    await fixture.whenStable();    const content = el.textContent;    expect(content).withContext('not welcomed').not.toContain('Welcome');    expect(content)      .withContext('\"log in\"')      .toMatch(/log in/i);  });  it(\"should inject the component's UserService instance\", inject(    [UserService],    (service: UserService) => {      expect(service).toBe(componentUserService);    },  ));  it('TestBed and Component UserService should be the same', () => {    expect(userService).toBe(componentUserService);  });});\n\n```\n\nAnd here are some tests:\n\ncheck\n\n```\n      import {ComponentFixture, inject, TestBed} from '@angular/core/testing';import {UserService} from '../model/user.service';import {WelcomeComponent} from './welcome.component';class MockUserService {  isLoggedIn = true;  user = {name: 'Test User'};}describe('WelcomeComponent', () => {  let comp: WelcomeComponent;  let fixture: ComponentFixture<WelcomeComponent>;  let componentUserService: UserService; // the actually injected service  let userService: UserService; // the TestBed injected service  let el: HTMLElement; // the DOM element with the welcome message  beforeEach(() => {    fixture = TestBed.createComponent(WelcomeComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // UserService actually injected into the component    userService = fixture.debugElement.injector.get(UserService);    componentUserService = userService;    // UserService from the root injector    userService = TestBed.inject(UserService);    //  get the \"welcome\" element by CSS selector (e.g., by class name)    el = fixture.nativeElement.querySelector('.welcome');  });  it('should welcome the user', async () => {    await fixture.whenStable();    const content = el.textContent;    expect(content).withContext('\"Welcome ...\"').toContain('Welcome');    expect(content).withContext('expected name').toContain('Test User');  });  it('should welcome \"Bubba\"', async () => {    userService.user.set({name: 'Bubba'}); // welcome message hasn't been shown yet    await fixture.whenStable();    expect(el.textContent).toContain('Bubba');  });  it('should request login if not logged in', async () => {    userService.isLoggedIn.set(false); // welcome message hasn't been shown yet    await fixture.whenStable();    const content = el.textContent;    expect(content).withContext('not welcomed').not.toContain('Welcome');    expect(content)      .withContext('\"log in\"')      .toMatch(/log in/i);  });  it(\"should inject the component's UserService instance\", inject(    [UserService],    (service: UserService) => {      expect(service).toBe(componentUserService);    },  ));  it('TestBed and Component UserService should be the same', () => {    expect(userService).toBe(componentUserService);  });});\n\n```\n\nThe first is a sanity test; it confirms that the `UserService` is called and working.\n\n**HELPFUL:** The withContext function (for example, `'expected name'`) is an optional failure label.\nIf the expectation fails, Jasmine appends this label to the expectation failure message.\nIn a spec with multiple expectations, it can help clarify what went wrong and which expectation failed.\n\nThe remaining tests confirm the logic of the component when the service returns different values.\nThe second test validates the effect of changing the user name.\nThe third test checks that the component displays the proper message when there is no logged-in user.\n\n## [Component with async service](https://angular.dev/guide/testing/components-scenarios\\#component-with-async-service)\n\nIn this sample, the `AboutComponent` template hosts a `TwainComponent`.\nThe `TwainComponent` displays Mark Twain quotes.\n\ncheck\n\n```\n      import {Component, inject, OnInit, signal} from '@angular/core';import {AsyncPipe} from '@angular/common';import {sharedImports} from '../shared/shared';import {Observable, of} from 'rxjs';import {catchError, startWith} from 'rxjs/operators';import {TwainService} from './twain.service';@Component({  selector: 'twain-quote',  template: ` <p class=\"twain\">      <i>{{ quote | async }}</i>    </p>    <button type=\"button\" (click)=\"getQuote()\">Next quote</button>    @if (errorMessage()) {      <p class=\"error\">{{ errorMessage() }}</p>    }`,  styles: ['.twain { font-style: italic; } .error { color: red; }'],  imports: [AsyncPipe, sharedImports],})export class TwainComponent {  errorMessage = signal('');  quote?: Observable<string>;  private twainService = inject(TwainService);  constructor() {    this.getQuote();  }  getQuote() {    this.errorMessage.set('');    this.quote = this.twainService.getQuote().pipe(      startWith('...'),      catchError((err: any) => {        this.errorMessage.set(err.message || err.toString());        return of('...'); // reset message to placeholder      }),    );  }}\n\n```\n\n**HELPFUL:** The value of the component's `quote` property passes through an `AsyncPipe`.\nThat means the property returns either a `Promise` or an `Observable`.\n\nIn this example, the `TwainComponent.getQuote()` method tells you that the `quote` property returns an `Observable`.\n\ncheck\n\n```\n      import {Component, inject, OnInit, signal} from '@angular/core';import {AsyncPipe} from '@angular/common';import {sharedImports} from '../shared/shared';import {Observable, of} from 'rxjs';import {catchError, startWith} from 'rxjs/operators';import {TwainService} from './twain.service';@Component({  selector: 'twain-quote',  template: ` <p class=\"twain\">      <i>{{ quote | async }}</i>    </p>    <button type=\"button\" (click)=\"getQuote()\">Next quote</button>    @if (errorMessage()) {      <p class=\"error\">{{ errorMessage() }}</p>    }`,  styles: ['.twain { font-style: italic; } .error { color: red; }'],  imports: [AsyncPipe, sharedImports],})export class TwainComponent {  errorMessage = signal('');  quote?: Observable<string>;  private twainService = inject(TwainService);  constructor() {    this.getQuote();  }  getQuote() {    this.errorMessage.set('');    this.quote = this.twainService.getQuote().pipe(      startWith('...'),      catchError((err: any) => {        this.errorMessage.set(err.message || err.toString());        return of('...'); // reset message to placeholder      }),    );  }}\n\n```\n\nThe `TwainComponent` gets quotes from an injected `TwainService`.\nThe component starts the returned `Observable` with a placeholder value ( `'...'`), before the service can return its first quote.\n\nThe `catchError` intercepts service errors, prepares an error message, and returns the placeholder value on the success channel.\n\nThese are all features you'll want to test.\n\n### [Testing with a spy](https://angular.dev/guide/testing/components-scenarios\\#testing-with-a-spy)\n\nWhen testing a component, only the service's public API should matter.\nIn general, tests themselves should not make calls to remote servers.\nThey should emulate such calls.\nThe setup in this `app/twain/twain.component.spec.ts` shows one way to do that:\n\ncheck\n\n```\n      import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => {  let component: TwainComponent;  let fixture: ComponentFixture<TwainComponent>;  let getQuoteSpy: jasmine.Spy;  let quoteEl: HTMLElement;  let testQuote: string;  // Helper function to get the error message element value  // An *ngIf keeps it out of the DOM until there is an error  const errorMessage = () => {    const el = fixture.nativeElement.querySelector('.error');    return el ? el.textContent : null;  };  beforeEach(() => {    TestBed.configureTestingModule({      imports: [TwainComponent],      providers: [TwainService],    });    testQuote = 'Test Quote';    // Create a fake TwainService object with a `getQuote()` spy    const twainService = TestBed.inject(TwainService);    // Make the spy return a synchronous Observable with the test data    getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote));    fixture = TestBed.createComponent(TwainComponent);    fixture.autoDetectChanges();    component = fixture.componentInstance;    quoteEl = fixture.nativeElement.querySelector('.twain');  });  describe('when test with synchronous observable', () => {    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    // The quote would not be immediately available if the service were truly async.    it('should show quote after component initialized', async () => {      await fixture.whenStable(); // onInit()      // sync spy result shows testQuote immediately after init      expect(quoteEl.textContent).toBe(testQuote);      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    // The error would not be immediately available if the service were truly async.    // Use `fakeAsync` because the component error calls `setTimeout`    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an error observable after a timeout      getQuoteSpy.and.returnValue(        defer(() => {          return new Promise((resolve, reject) => {            setTimeout(() => {              reject('TwainService test failure');            });          });        }),      );      fixture.detectChanges(); // onInit()      // sync spy errors immediately after init      tick(); // flush the setTimeout()      fixture.detectChanges(); // update errorMessage within setTimeout()      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });  describe('when test with asynchronous observable', () => {    beforeEach(() => {      // Simulate delayed observable values with the `asyncData()` helper      getQuoteSpy.and.returnValue(asyncData(testQuote));    });    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    it('should still not show quote after component initialized', () => {      fixture.detectChanges();      // getQuote service is async => still has not returned with quote      // so should show the start value, '...'      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      expect(errorMessage()).withContext('should not show error').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    it('should show quote after getQuote (fakeAsync)', fakeAsync(() => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      tick(); // flush the observable to get the quote      fixture.detectChanges(); // update view      expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    }));    it('should show quote after getQuote (async)', async () => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      await fixture.whenStable();      // wait for async getQuote      fixture.detectChanges(); // update view with quote      expect(quoteEl.textContent).toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    });    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an async error observable      getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure'));      fixture.detectChanges();      tick(); // component shows error after a setTimeout()      fixture.detectChanges(); // update error message      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });});\n\n```\n\nFocus on the spy.\n\ncheck\n\n```\n      import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => {  let component: TwainComponent;  let fixture: ComponentFixture<TwainComponent>;  let getQuoteSpy: jasmine.Spy;  let quoteEl: HTMLElement;  let testQuote: string;  // Helper function to get the error message element value  // An *ngIf keeps it out of the DOM until there is an error  const errorMessage = () => {    const el = fixture.nativeElement.querySelector('.error');    return el ? el.textContent : null;  };  beforeEach(() => {    TestBed.configureTestingModule({      imports: [TwainComponent],      providers: [TwainService],    });    testQuote = 'Test Quote';    // Create a fake TwainService object with a `getQuote()` spy    const twainService = TestBed.inject(TwainService);    // Make the spy return a synchronous Observable with the test data    getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote));    fixture = TestBed.createComponent(TwainComponent);    fixture.autoDetectChanges();    component = fixture.componentInstance;    quoteEl = fixture.nativeElement.querySelector('.twain');  });  describe('when test with synchronous observable', () => {    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    // The quote would not be immediately available if the service were truly async.    it('should show quote after component initialized', async () => {      await fixture.whenStable(); // onInit()      // sync spy result shows testQuote immediately after init      expect(quoteEl.textContent).toBe(testQuote);      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    // The error would not be immediately available if the service were truly async.    // Use `fakeAsync` because the component error calls `setTimeout`    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an error observable after a timeout      getQuoteSpy.and.returnValue(        defer(() => {          return new Promise((resolve, reject) => {            setTimeout(() => {              reject('TwainService test failure');            });          });        }),      );      fixture.detectChanges(); // onInit()      // sync spy errors immediately after init      tick(); // flush the setTimeout()      fixture.detectChanges(); // update errorMessage within setTimeout()      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });  describe('when test with asynchronous observable', () => {    beforeEach(() => {      // Simulate delayed observable values with the `asyncData()` helper      getQuoteSpy.and.returnValue(asyncData(testQuote));    });    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    it('should still not show quote after component initialized', () => {      fixture.detectChanges();      // getQuote service is async => still has not returned with quote      // so should show the start value, '...'      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      expect(errorMessage()).withContext('should not show error').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    it('should show quote after getQuote (fakeAsync)', fakeAsync(() => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      tick(); // flush the observable to get the quote      fixture.detectChanges(); // update view      expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    }));    it('should show quote after getQuote (async)', async () => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      await fixture.whenStable();      // wait for async getQuote      fixture.detectChanges(); // update view with quote      expect(quoteEl.textContent).toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    });    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an async error observable      getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure'));      fixture.detectChanges();      tick(); // component shows error after a setTimeout()      fixture.detectChanges(); // update error message      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });});\n\n```\n\nThe spy is designed such that any call to `getQuote` receives an observable with a test quote.\nUnlike the real `getQuote()` method, this spy bypasses the server and returns a synchronous observable whose value is available immediately.\n\nYou can write many useful tests with this spy, even though its `Observable` is synchronous.\n\n**HELPFUL:** It is best to limit the usage of spies to only what is necessary for the test. Creating mocks or spies for more than what's necessary can be brittle. As the component and injectable evolves, the unrelated tests can fail because they no longer mock enough behaviors that would otherwise not affect the test.\n\n### [Async test with `fakeAsync()`](https://angular.dev/guide/testing/components-scenarios\\#async-test-with-fakeasync)\n\nTo use `fakeAsync()` functionality, you must import `zone.js/testing` in your test setup file.\nIf you created your project with the Angular CLI, `zone-testing` is already imported in `src/test.ts`.\n\nThe following test confirms the expected behavior when the service returns an `ErrorObservable`.\n\ncheck\n\n```\n      import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => {  let component: TwainComponent;  let fixture: ComponentFixture<TwainComponent>;  let getQuoteSpy: jasmine.Spy;  let quoteEl: HTMLElement;  let testQuote: string;  // Helper function to get the error message element value  // An *ngIf keeps it out of the DOM until there is an error  const errorMessage = () => {    const el = fixture.nativeElement.querySelector('.error');    return el ? el.textContent : null;  };  beforeEach(() => {    TestBed.configureTestingModule({      imports: [TwainComponent],      providers: [TwainService],    });    testQuote = 'Test Quote';    // Create a fake TwainService object with a `getQuote()` spy    const twainService = TestBed.inject(TwainService);    // Make the spy return a synchronous Observable with the test data    getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote));    fixture = TestBed.createComponent(TwainComponent);    fixture.autoDetectChanges();    component = fixture.componentInstance;    quoteEl = fixture.nativeElement.querySelector('.twain');  });  describe('when test with synchronous observable', () => {    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    // The quote would not be immediately available if the service were truly async.    it('should show quote after component initialized', async () => {      await fixture.whenStable(); // onInit()      // sync spy result shows testQuote immediately after init      expect(quoteEl.textContent).toBe(testQuote);      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    // The error would not be immediately available if the service were truly async.    // Use `fakeAsync` because the component error calls `setTimeout`    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an error observable after a timeout      getQuoteSpy.and.returnValue(        defer(() => {          return new Promise((resolve, reject) => {            setTimeout(() => {              reject('TwainService test failure');            });          });        }),      );      fixture.detectChanges(); // onInit()      // sync spy errors immediately after init      tick(); // flush the setTimeout()      fixture.detectChanges(); // update errorMessage within setTimeout()      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });  describe('when test with asynchronous observable', () => {    beforeEach(() => {      // Simulate delayed observable values with the `asyncData()` helper      getQuoteSpy.and.returnValue(asyncData(testQuote));    });    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    it('should still not show quote after component initialized', () => {      fixture.detectChanges();      // getQuote service is async => still has not returned with quote      // so should show the start value, '...'      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      expect(errorMessage()).withContext('should not show error').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    it('should show quote after getQuote (fakeAsync)', fakeAsync(() => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      tick(); // flush the observable to get the quote      fixture.detectChanges(); // update view      expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    }));    it('should show quote after getQuote (async)', async () => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      await fixture.whenStable();      // wait for async getQuote      fixture.detectChanges(); // update view with quote      expect(quoteEl.textContent).toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    });    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an async error observable      getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure'));      fixture.detectChanges();      tick(); // component shows error after a setTimeout()      fixture.detectChanges(); // update error message      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });});\n\n```\n\n**HELPFUL:** The `it()` function receives an argument of the following form.\n\n```\n      fakeAsync(() => { /*test body*/ })\n\n```\n\ncheck\n\nThe `fakeAsync()` function enables a linear coding style by running the test body in a special `fakeAsync test zone`.\nThe test body appears to be synchronous.\nThere is no nested syntax (like a `Promise.then()`) to disrupt the flow of control.\n\n**HELPFUL:** Limitation: The `fakeAsync()` function won't work if the test body makes an `XMLHttpRequest` (XHR) call.\nXHR calls within a test are rare, but if you need to call XHR, see the [`waitForAsync()`](https://angular.dev/guide/testing/components-scenarios#waitForAsync) section.\n\n**IMPORTANT:** Be aware that asynchronous tasks that happen inside the `fakeAsync` zone need to be manually executed with `flush` or `tick`. If you attempt to\nwait for them to complete (i.e. using `fixture.whenStable`) without using the\n`fakeAsync` test helpers to advance time, your test will likely fail. See below for more information.\n\n### [The `tick()` function](https://angular.dev/guide/testing/components-scenarios\\#the-tick-function)\n\nYou do have to call [tick()](https://angular.dev/guide/testing/api/core/testing/tick) to advance the virtual clock.\n\nCalling [tick()](https://angular.dev/guide/testing/api/core/testing/tick) simulates the passage of time until all pending asynchronous activities finish.\nIn this case, it waits for the observable's `setTimeout()`.\n\nThe [tick()](https://angular.dev/guide/testing/api/core/testing/tick) function accepts `millis` and `tickOptions` as parameters. The `millis` parameter specifies how much the virtual clock advances and defaults to `0` if not provided.\nFor example, if you have a `setTimeout(fn, 100)` in a `fakeAsync()` test, you need to use `tick(100)` to trigger the fn callback.\nThe optional `tickOptions` parameter has a property named `processNewMacroTasksSynchronously`. The `processNewMacroTasksSynchronously` property represents whether to invoke new generated macro tasks when ticking and defaults to `true`.\n\ncheck\n\n```\n      import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => {  describe('async', () => {    let actuallyDone = false;    beforeEach(() => {      actuallyDone = false;    });    afterEach(() => {      expect(actuallyDone).withContext('actuallyDone should be true').toBe(true);    });    it('should run normal test', () => {      actuallyDone = true;    });    it('should run normal async test', (done: DoneFn) => {      setTimeout(() => {        actuallyDone = true;        done();      }, 0);    });    it('should run async test with task', waitForAsync(() => {      setTimeout(() => {        actuallyDone = true;      }, 0);    }));    it('should run async test with task', waitForAsync(() => {      const id = setInterval(() => {        actuallyDone = true;        clearInterval(id);      }, 100);    }));    it('should run async test with successful promise', waitForAsync(() => {      const p = new Promise((resolve) => {        setTimeout(resolve, 10);      });      p.then(() => {        actuallyDone = true;      });    }));    it('should run async test with failed promise', waitForAsync(() => {      const p = new Promise((resolve, reject) => {        setTimeout(reject, 10);      });      p.catch(() => {        actuallyDone = true;      });    }));    // Use done. Can also use async or fakeAsync.    it('should run async test with successful delayed Observable', (done: DoneFn) => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),        complete: done,      });    });    it('should run async test with successful delayed Observable', waitForAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });    }));    it('should run async test with successful delayed Observable', fakeAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });      tick(10);    }));  });  describe('fakeAsync', () => {    it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {      let called = false;      setTimeout(() => {        called = true;      }, 100);      tick(100);      expect(called).toBe(true);    }));    it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0);      // the nested timeout will also be triggered      expect(callback).toHaveBeenCalled();    }));    it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0, {processNewMacroTasksSynchronously: false});      // the nested timeout will not be triggered      expect(callback).not.toHaveBeenCalled();      tick(0);      expect(callback).toHaveBeenCalled();    }));    it('should get Date diff correctly in fakeAsync', fakeAsync(() => {      const start = Date.now();      tick(100);      const end = Date.now();      expect(end - start).toBe(100);    }));    it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {      // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'      // to patch rxjs scheduler      let result = '';      of('hello')        .pipe(delay(1000))        .subscribe((v) => {          result = v;        });      expect(result).toBe('');      tick(1000);      expect(result).toBe('hello');      const start = new Date().getTime();      let dateDiff = 0;      interval(1000)        .pipe(take(2))        .subscribe(() => (dateDiff = new Date().getTime() - start));      tick(1000);      expect(dateDiff).toBe(1000);      tick(1000);      expect(dateDiff).toBe(2000);    }));  });  describe('use jasmine.clock()', () => {    // need to config __zone_symbol__fakeAsyncPatchLock flag    // before loading zone.js/testing    beforeEach(() => {      jasmine.clock().install();    });    afterEach(() => {      jasmine.clock().uninstall();    });    it('should auto enter fakeAsync', () => {      // is in fakeAsync now, don't need to call fakeAsync(testFn)      let called = false;      setTimeout(() => {        called = true;      }, 100);      jasmine.clock().tick(100);      expect(called).toBe(true);    });  });  describe('test jsonp', () => {    function jsonp(url: string, callback: () => void) {      // do a jsonp call which is not zone aware    }    // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag    // before loading zone.js/testing    it('should wait until promise.then is called', waitForAsync(() => {      let finished = false;      new Promise<void>((res) => {        jsonp('localhost:8080/jsonp', () => {          // success callback and resolve the promise          finished = true;          res();        });      }).then(() => {        // async will wait until promise.then is called        // if __zone_symbol__supportWaitUnResolvedChainedPromise is set        expect(finished).toBe(true);      });    }));  });});\n\n```\n\nThe [tick()](https://angular.dev/guide/testing/api/core/testing/tick) function is one of the Angular testing utilities that you import with `TestBed`.\nIt's a companion to `fakeAsync()` and you can only call it within a `fakeAsync()` body.\n\n### [tickOptions](https://angular.dev/guide/testing/components-scenarios\\#tickoptions)\n\nIn this example, you have a new macro task, the nested `setTimeout` function. By default, when the `tick` is setTimeout, `outside` and `nested` will both be triggered.\n\ncheck\n\n```\n      import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => {  describe('async', () => {    let actuallyDone = false;    beforeEach(() => {      actuallyDone = false;    });    afterEach(() => {      expect(actuallyDone).withContext('actuallyDone should be true').toBe(true);    });    it('should run normal test', () => {      actuallyDone = true;    });    it('should run normal async test', (done: DoneFn) => {      setTimeout(() => {        actuallyDone = true;        done();      }, 0);    });    it('should run async test with task', waitForAsync(() => {      setTimeout(() => {        actuallyDone = true;      }, 0);    }));    it('should run async test with task', waitForAsync(() => {      const id = setInterval(() => {        actuallyDone = true;        clearInterval(id);      }, 100);    }));    it('should run async test with successful promise', waitForAsync(() => {      const p = new Promise((resolve) => {        setTimeout(resolve, 10);      });      p.then(() => {        actuallyDone = true;      });    }));    it('should run async test with failed promise', waitForAsync(() => {      const p = new Promise((resolve, reject) => {        setTimeout(reject, 10);      });      p.catch(() => {        actuallyDone = true;      });    }));    // Use done. Can also use async or fakeAsync.    it('should run async test with successful delayed Observable', (done: DoneFn) => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),        complete: done,      });    });    it('should run async test with successful delayed Observable', waitForAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });    }));    it('should run async test with successful delayed Observable', fakeAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });      tick(10);    }));  });  describe('fakeAsync', () => {    it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {      let called = false;      setTimeout(() => {        called = true;      }, 100);      tick(100);      expect(called).toBe(true);    }));    it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0);      // the nested timeout will also be triggered      expect(callback).toHaveBeenCalled();    }));    it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0, {processNewMacroTasksSynchronously: false});      // the nested timeout will not be triggered      expect(callback).not.toHaveBeenCalled();      tick(0);      expect(callback).toHaveBeenCalled();    }));    it('should get Date diff correctly in fakeAsync', fakeAsync(() => {      const start = Date.now();      tick(100);      const end = Date.now();      expect(end - start).toBe(100);    }));    it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {      // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'      // to patch rxjs scheduler      let result = '';      of('hello')        .pipe(delay(1000))        .subscribe((v) => {          result = v;        });      expect(result).toBe('');      tick(1000);      expect(result).toBe('hello');      const start = new Date().getTime();      let dateDiff = 0;      interval(1000)        .pipe(take(2))        .subscribe(() => (dateDiff = new Date().getTime() - start));      tick(1000);      expect(dateDiff).toBe(1000);      tick(1000);      expect(dateDiff).toBe(2000);    }));  });  describe('use jasmine.clock()', () => {    // need to config __zone_symbol__fakeAsyncPatchLock flag    // before loading zone.js/testing    beforeEach(() => {      jasmine.clock().install();    });    afterEach(() => {      jasmine.clock().uninstall();    });    it('should auto enter fakeAsync', () => {      // is in fakeAsync now, don't need to call fakeAsync(testFn)      let called = false;      setTimeout(() => {        called = true;      }, 100);      jasmine.clock().tick(100);      expect(called).toBe(true);    });  });  describe('test jsonp', () => {    function jsonp(url: string, callback: () => void) {      // do a jsonp call which is not zone aware    }    // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag    // before loading zone.js/testing    it('should wait until promise.then is called', waitForAsync(() => {      let finished = false;      new Promise<void>((res) => {        jsonp('localhost:8080/jsonp', () => {          // success callback and resolve the promise          finished = true;          res();        });      }).then(() => {        // async will wait until promise.then is called        // if __zone_symbol__supportWaitUnResolvedChainedPromise is set        expect(finished).toBe(true);      });    }));  });});\n\n```\n\nIn some case, you don't want to trigger the new macro task when ticking. You can use `tick(millis, {processNewMacroTasksSynchronously: false})` to not invoke a new macro task.\n\ncheck\n\n```\n      import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => {  describe('async', () => {    let actuallyDone = false;    beforeEach(() => {      actuallyDone = false;    });    afterEach(() => {      expect(actuallyDone).withContext('actuallyDone should be true').toBe(true);    });    it('should run normal test', () => {      actuallyDone = true;    });    it('should run normal async test', (done: DoneFn) => {      setTimeout(() => {        actuallyDone = true;        done();      }, 0);    });    it('should run async test with task', waitForAsync(() => {      setTimeout(() => {        actuallyDone = true;      }, 0);    }));    it('should run async test with task', waitForAsync(() => {      const id = setInterval(() => {        actuallyDone = true;        clearInterval(id);      }, 100);    }));    it('should run async test with successful promise', waitForAsync(() => {      const p = new Promise((resolve) => {        setTimeout(resolve, 10);      });      p.then(() => {        actuallyDone = true;      });    }));    it('should run async test with failed promise', waitForAsync(() => {      const p = new Promise((resolve, reject) => {        setTimeout(reject, 10);      });      p.catch(() => {        actuallyDone = true;      });    }));    // Use done. Can also use async or fakeAsync.    it('should run async test with successful delayed Observable', (done: DoneFn) => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),        complete: done,      });    });    it('should run async test with successful delayed Observable', waitForAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });    }));    it('should run async test with successful delayed Observable', fakeAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });      tick(10);    }));  });  describe('fakeAsync', () => {    it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {      let called = false;      setTimeout(() => {        called = true;      }, 100);      tick(100);      expect(called).toBe(true);    }));    it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0);      // the nested timeout will also be triggered      expect(callback).toHaveBeenCalled();    }));    it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0, {processNewMacroTasksSynchronously: false});      // the nested timeout will not be triggered      expect(callback).not.toHaveBeenCalled();      tick(0);      expect(callback).toHaveBeenCalled();    }));    it('should get Date diff correctly in fakeAsync', fakeAsync(() => {      const start = Date.now();      tick(100);      const end = Date.now();      expect(end - start).toBe(100);    }));    it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {      // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'      // to patch rxjs scheduler      let result = '';      of('hello')        .pipe(delay(1000))        .subscribe((v) => {          result = v;        });      expect(result).toBe('');      tick(1000);      expect(result).toBe('hello');      const start = new Date().getTime();      let dateDiff = 0;      interval(1000)        .pipe(take(2))        .subscribe(() => (dateDiff = new Date().getTime() - start));      tick(1000);      expect(dateDiff).toBe(1000);      tick(1000);      expect(dateDiff).toBe(2000);    }));  });  describe('use jasmine.clock()', () => {    // need to config __zone_symbol__fakeAsyncPatchLock flag    // before loading zone.js/testing    beforeEach(() => {      jasmine.clock().install();    });    afterEach(() => {      jasmine.clock().uninstall();    });    it('should auto enter fakeAsync', () => {      // is in fakeAsync now, don't need to call fakeAsync(testFn)      let called = false;      setTimeout(() => {        called = true;      }, 100);      jasmine.clock().tick(100);      expect(called).toBe(true);    });  });  describe('test jsonp', () => {    function jsonp(url: string, callback: () => void) {      // do a jsonp call which is not zone aware    }    // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag    // before loading zone.js/testing    it('should wait until promise.then is called', waitForAsync(() => {      let finished = false;      new Promise<void>((res) => {        jsonp('localhost:8080/jsonp', () => {          // success callback and resolve the promise          finished = true;          res();        });      }).then(() => {        // async will wait until promise.then is called        // if __zone_symbol__supportWaitUnResolvedChainedPromise is set        expect(finished).toBe(true);      });    }));  });});\n\n```\n\n### [Comparing dates inside fakeAsync()](https://angular.dev/guide/testing/components-scenarios\\#comparing-dates-inside-fakeasync)\n\n`fakeAsync()` simulates passage of time, which lets you calculate the difference between dates inside `fakeAsync()`.\n\ncheck\n\n```\n      import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => {  describe('async', () => {    let actuallyDone = false;    beforeEach(() => {      actuallyDone = false;    });    afterEach(() => {      expect(actuallyDone).withContext('actuallyDone should be true').toBe(true);    });    it('should run normal test', () => {      actuallyDone = true;    });    it('should run normal async test', (done: DoneFn) => {      setTimeout(() => {        actuallyDone = true;        done();      }, 0);    });    it('should run async test with task', waitForAsync(() => {      setTimeout(() => {        actuallyDone = true;      }, 0);    }));    it('should run async test with task', waitForAsync(() => {      const id = setInterval(() => {        actuallyDone = true;        clearInterval(id);      }, 100);    }));    it('should run async test with successful promise', waitForAsync(() => {      const p = new Promise((resolve) => {        setTimeout(resolve, 10);      });      p.then(() => {        actuallyDone = true;      });    }));    it('should run async test with failed promise', waitForAsync(() => {      const p = new Promise((resolve, reject) => {        setTimeout(reject, 10);      });      p.catch(() => {        actuallyDone = true;      });    }));    // Use done. Can also use async or fakeAsync.    it('should run async test with successful delayed Observable', (done: DoneFn) => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),        complete: done,      });    });    it('should run async test with successful delayed Observable', waitForAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });    }));    it('should run async test with successful delayed Observable', fakeAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });      tick(10);    }));  });  describe('fakeAsync', () => {    it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {      let called = false;      setTimeout(() => {        called = true;      }, 100);      tick(100);      expect(called).toBe(true);    }));    it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0);      // the nested timeout will also be triggered      expect(callback).toHaveBeenCalled();    }));    it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0, {processNewMacroTasksSynchronously: false});      // the nested timeout will not be triggered      expect(callback).not.toHaveBeenCalled();      tick(0);      expect(callback).toHaveBeenCalled();    }));    it('should get Date diff correctly in fakeAsync', fakeAsync(() => {      const start = Date.now();      tick(100);      const end = Date.now();      expect(end - start).toBe(100);    }));    it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {      // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'      // to patch rxjs scheduler      let result = '';      of('hello')        .pipe(delay(1000))        .subscribe((v) => {          result = v;        });      expect(result).toBe('');      tick(1000);      expect(result).toBe('hello');      const start = new Date().getTime();      let dateDiff = 0;      interval(1000)        .pipe(take(2))        .subscribe(() => (dateDiff = new Date().getTime() - start));      tick(1000);      expect(dateDiff).toBe(1000);      tick(1000);      expect(dateDiff).toBe(2000);    }));  });  describe('use jasmine.clock()', () => {    // need to config __zone_symbol__fakeAsyncPatchLock flag    // before loading zone.js/testing    beforeEach(() => {      jasmine.clock().install();    });    afterEach(() => {      jasmine.clock().uninstall();    });    it('should auto enter fakeAsync', () => {      // is in fakeAsync now, don't need to call fakeAsync(testFn)      let called = false;      setTimeout(() => {        called = true;      }, 100);      jasmine.clock().tick(100);      expect(called).toBe(true);    });  });  describe('test jsonp', () => {    function jsonp(url: string, callback: () => void) {      // do a jsonp call which is not zone aware    }    // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag    // before loading zone.js/testing    it('should wait until promise.then is called', waitForAsync(() => {      let finished = false;      new Promise<void>((res) => {        jsonp('localhost:8080/jsonp', () => {          // success callback and resolve the promise          finished = true;          res();        });      }).then(() => {        // async will wait until promise.then is called        // if __zone_symbol__supportWaitUnResolvedChainedPromise is set        expect(finished).toBe(true);      });    }));  });});\n\n```\n\n### [jasmine.clock with fakeAsync()](https://angular.dev/guide/testing/components-scenarios\\#jasmineclock-with-fakeasync)\n\nJasmine also provides a `clock` feature to mock dates.\nAngular automatically runs tests that are run after `jasmine.clock().install()` is called inside a `fakeAsync()` method until `jasmine.clock().uninstall()` is called.\n`fakeAsync()` is not needed and throws an error if nested.\n\nBy default, this feature is disabled.\nTo enable it, set a global flag before importing `zone-testing`.\n\nIf you use the Angular CLI, configure this flag in `src/test.ts`.\n\n```\n      [window as any]('__zone_symbol__fakeAsyncPatchLock') = true;import 'zone.js/testing';\n\n```\n\ncheck\n\ncheck\n\n```\n      import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => {  describe('async', () => {    let actuallyDone = false;    beforeEach(() => {      actuallyDone = false;    });    afterEach(() => {      expect(actuallyDone).withContext('actuallyDone should be true').toBe(true);    });    it('should run normal test', () => {      actuallyDone = true;    });    it('should run normal async test', (done: DoneFn) => {      setTimeout(() => {        actuallyDone = true;        done();      }, 0);    });    it('should run async test with task', waitForAsync(() => {      setTimeout(() => {        actuallyDone = true;      }, 0);    }));    it('should run async test with task', waitForAsync(() => {      const id = setInterval(() => {        actuallyDone = true;        clearInterval(id);      }, 100);    }));    it('should run async test with successful promise', waitForAsync(() => {      const p = new Promise((resolve) => {        setTimeout(resolve, 10);      });      p.then(() => {        actuallyDone = true;      });    }));    it('should run async test with failed promise', waitForAsync(() => {      const p = new Promise((resolve, reject) => {        setTimeout(reject, 10);      });      p.catch(() => {        actuallyDone = true;      });    }));    // Use done. Can also use async or fakeAsync.    it('should run async test with successful delayed Observable', (done: DoneFn) => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),        complete: done,      });    });    it('should run async test with successful delayed Observable', waitForAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });    }));    it('should run async test with successful delayed Observable', fakeAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });      tick(10);    }));  });  describe('fakeAsync', () => {    it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {      let called = false;      setTimeout(() => {        called = true;      }, 100);      tick(100);      expect(called).toBe(true);    }));    it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0);      // the nested timeout will also be triggered      expect(callback).toHaveBeenCalled();    }));    it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0, {processNewMacroTasksSynchronously: false});      // the nested timeout will not be triggered      expect(callback).not.toHaveBeenCalled();      tick(0);      expect(callback).toHaveBeenCalled();    }));    it('should get Date diff correctly in fakeAsync', fakeAsync(() => {      const start = Date.now();      tick(100);      const end = Date.now();      expect(end - start).toBe(100);    }));    it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {      // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'      // to patch rxjs scheduler      let result = '';      of('hello')        .pipe(delay(1000))        .subscribe((v) => {          result = v;        });      expect(result).toBe('');      tick(1000);      expect(result).toBe('hello');      const start = new Date().getTime();      let dateDiff = 0;      interval(1000)        .pipe(take(2))        .subscribe(() => (dateDiff = new Date().getTime() - start));      tick(1000);      expect(dateDiff).toBe(1000);      tick(1000);      expect(dateDiff).toBe(2000);    }));  });  describe('use jasmine.clock()', () => {    // need to config __zone_symbol__fakeAsyncPatchLock flag    // before loading zone.js/testing    beforeEach(() => {      jasmine.clock().install();    });    afterEach(() => {      jasmine.clock().uninstall();    });    it('should auto enter fakeAsync', () => {      // is in fakeAsync now, don't need to call fakeAsync(testFn)      let called = false;      setTimeout(() => {        called = true;      }, 100);      jasmine.clock().tick(100);      expect(called).toBe(true);    });  });  describe('test jsonp', () => {    function jsonp(url: string, callback: () => void) {      // do a jsonp call which is not zone aware    }    // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag    // before loading zone.js/testing    it('should wait until promise.then is called', waitForAsync(() => {      let finished = false;      new Promise<void>((res) => {        jsonp('localhost:8080/jsonp', () => {          // success callback and resolve the promise          finished = true;          res();        });      }).then(() => {        // async will wait until promise.then is called        // if __zone_symbol__supportWaitUnResolvedChainedPromise is set        expect(finished).toBe(true);      });    }));  });});\n\n```\n\n### [Using the RxJS scheduler inside fakeAsync()](https://angular.dev/guide/testing/components-scenarios\\#using-the-rxjs-scheduler-inside-fakeasync)\n\nYou can also use RxJS scheduler in `fakeAsync()` just like using `setTimeout()` or `setInterval()`, but you need to import `zone.js/plugins/zone-patch-rxjs-fake-async` to patch RxJS scheduler.\n\ncheck\n\n```\n      import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => {  describe('async', () => {    let actuallyDone = false;    beforeEach(() => {      actuallyDone = false;    });    afterEach(() => {      expect(actuallyDone).withContext('actuallyDone should be true').toBe(true);    });    it('should run normal test', () => {      actuallyDone = true;    });    it('should run normal async test', (done: DoneFn) => {      setTimeout(() => {        actuallyDone = true;        done();      }, 0);    });    it('should run async test with task', waitForAsync(() => {      setTimeout(() => {        actuallyDone = true;      }, 0);    }));    it('should run async test with task', waitForAsync(() => {      const id = setInterval(() => {        actuallyDone = true;        clearInterval(id);      }, 100);    }));    it('should run async test with successful promise', waitForAsync(() => {      const p = new Promise((resolve) => {        setTimeout(resolve, 10);      });      p.then(() => {        actuallyDone = true;      });    }));    it('should run async test with failed promise', waitForAsync(() => {      const p = new Promise((resolve, reject) => {        setTimeout(reject, 10);      });      p.catch(() => {        actuallyDone = true;      });    }));    // Use done. Can also use async or fakeAsync.    it('should run async test with successful delayed Observable', (done: DoneFn) => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),        complete: done,      });    });    it('should run async test with successful delayed Observable', waitForAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });    }));    it('should run async test with successful delayed Observable', fakeAsync(() => {      const source = of(true).pipe(delay(10));      source.subscribe({        next: (val) => (actuallyDone = true),        error: (err) => fail(err),      });      tick(10);    }));  });  describe('fakeAsync', () => {    it('should run timeout callback with delay after call tick with millis', fakeAsync(() => {      let called = false;      setTimeout(() => {        called = true;      }, 100);      tick(100);      expect(called).toBe(true);    }));    it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0);      // the nested timeout will also be triggered      expect(callback).toHaveBeenCalled();    }));    it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => {      function nestedTimer(cb: () => any): void {        setTimeout(() => setTimeout(() => cb()));      }      const callback = jasmine.createSpy('callback');      nestedTimer(callback);      expect(callback).not.toHaveBeenCalled();      tick(0, {processNewMacroTasksSynchronously: false});      // the nested timeout will not be triggered      expect(callback).not.toHaveBeenCalled();      tick(0);      expect(callback).toHaveBeenCalled();    }));    it('should get Date diff correctly in fakeAsync', fakeAsync(() => {      const start = Date.now();      tick(100);      const end = Date.now();      expect(end - start).toBe(100);    }));    it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => {      // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'      // to patch rxjs scheduler      let result = '';      of('hello')        .pipe(delay(1000))        .subscribe((v) => {          result = v;        });      expect(result).toBe('');      tick(1000);      expect(result).toBe('hello');      const start = new Date().getTime();      let dateDiff = 0;      interval(1000)        .pipe(take(2))        .subscribe(() => (dateDiff = new Date().getTime() - start));      tick(1000);      expect(dateDiff).toBe(1000);      tick(1000);      expect(dateDiff).toBe(2000);    }));  });  describe('use jasmine.clock()', () => {    // need to config __zone_symbol__fakeAsyncPatchLock flag    // before loading zone.js/testing    beforeEach(() => {      jasmine.clock().install();    });    afterEach(() => {      jasmine.clock().uninstall();    });    it('should auto enter fakeAsync', () => {      // is in fakeAsync now, don't need to call fakeAsync(testFn)      let called = false;      setTimeout(() => {        called = true;      }, 100);      jasmine.clock().tick(100);      expect(called).toBe(true);    });  });  describe('test jsonp', () => {    function jsonp(url: string, callback: () => void) {      // do a jsonp call which is not zone aware    }    // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag    // before loading zone.js/testing    it('should wait until promise.then is called', waitForAsync(() => {      let finished = false;      new Promise<void>((res) => {        jsonp('localhost:8080/jsonp', () => {          // success callback and resolve the promise          finished = true;          res();        });      }).then(() => {        // async will wait until promise.then is called        // if __zone_symbol__supportWaitUnResolvedChainedPromise is set        expect(finished).toBe(true);      });    }));  });});\n\n```\n\n### [Support more macroTasks](https://angular.dev/guide/testing/components-scenarios\\#support-more-macrotasks)\n\nBy default, `fakeAsync()` supports the following macro tasks.\n\n- `setTimeout`\n- `setInterval`\n- `requestAnimationFrame`\n- `webkitRequestAnimationFrame`\n- `mozRequestAnimationFrame`\n\nIf you run other macro tasks such as `HTMLCanvasElement.toBlob()`, an _\"Unknown macroTask scheduled in fake async test\"_ error is thrown.\n\ncheck\n\n### src/app/shared/canvas.component.spec.ts (failing)\n\n```\n      import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {CanvasComponent} from './canvas.component';describe('CanvasComponent', () => {  beforeEach(() => {    (window as any).__zone_symbol__FakeAsyncTestMacroTask = [      {        source: 'HTMLCanvasElement.toBlob',        callbackArgs: [{size: 200}],      },    ];  });\n...  beforeEach(async () => {    await TestBed.configureTestingModule({      imports: [CanvasComponent],    }).compileComponents();  });  it('should be able to generate blob data from canvas', fakeAsync(() => {    const fixture = TestBed.createComponent(CanvasComponent);    const canvasComp = fixture.componentInstance;    fixture.detectChanges();    expect(canvasComp.blobSize).toBe(0);    tick();    expect(canvasComp.blobSize).toBeGreaterThan(0);  }));});\n\n```\n\nIf you want to support such a case, you need to define the macro task you want to support in `beforeEach()`.\nFor example:\n\ncheck\n\n```\n      import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {CanvasComponent} from './canvas.component';describe('CanvasComponent', () => {  beforeEach(() => {    (window as any).__zone_symbol__FakeAsyncTestMacroTask = [      {        source: 'HTMLCanvasElement.toBlob',        callbackArgs: [{size: 200}],      },    ];  });  beforeEach(async () => {    await TestBed.configureTestingModule({      imports: [CanvasComponent],    }).compileComponents();  });  it('should be able to generate blob data from canvas', fakeAsync(() => {    const fixture = TestBed.createComponent(CanvasComponent);    const canvasComp = fixture.componentInstance;    fixture.detectChanges();    expect(canvasComp.blobSize).toBe(0);    tick();    expect(canvasComp.blobSize).toBeGreaterThan(0);  }));});\n\n```\n\n**HELPFUL:** In order to make the `<canvas>` element Zone.js-aware in your app, you need to import the `zone-patch-canvas` patch (either in `polyfills.ts` or in the specific file that uses `<canvas>`):\n\ncheck\n\n```\n      // Import patch to make async `HTMLCanvasElement` methods (such as `.toBlob()`) Zone.js-aware.// Either import in `polyfills.ts` (if used in more than one places in the app) or in the component// file using `HTMLCanvasElement` (if it is only used in a single file).import 'zone.js/plugins/zone-patch-canvas';import {Component, AfterViewInit, ViewChild, ElementRef} from '@angular/core';@Component({  selector: 'sample-canvas',  template: '<canvas #sampleCanvas width=\"200\" height=\"200\"></canvas>',})export class CanvasComponent implements AfterViewInit {  blobSize = 0;  @ViewChild('sampleCanvas') sampleCanvas!: ElementRef;  ngAfterViewInit() {    const canvas: HTMLCanvasElement = this.sampleCanvas.nativeElement;    const context = canvas.getContext('2d')!;    context.clearRect(0, 0, 200, 200);    context.fillStyle = '#FF1122';    context.fillRect(0, 0, 200, 200);    canvas.toBlob((blob) => {      this.blobSize = blob?.size ?? 0;    });  }}\n\n```\n\n### [Async observables](https://angular.dev/guide/testing/components-scenarios\\#async-observables)\n\nYou might be satisfied with the test coverage of these tests.\n\nHowever, you might be troubled by the fact that the real service doesn't quite behave this way.\nThe real service sends requests to a remote server.\nA server takes time to respond and the response certainly won't be available immediately as in the previous two tests.\n\nYour tests will reflect the real world more faithfully if you return an _asynchronous_ observable from the `getQuote()` spy like this.\n\ncheck\n\n```\n      import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => {  let component: TwainComponent;  let fixture: ComponentFixture<TwainComponent>;  let getQuoteSpy: jasmine.Spy;  let quoteEl: HTMLElement;  let testQuote: string;  // Helper function to get the error message element value  // An *ngIf keeps it out of the DOM until there is an error  const errorMessage = () => {    const el = fixture.nativeElement.querySelector('.error');    return el ? el.textContent : null;  };  beforeEach(() => {    TestBed.configureTestingModule({      imports: [TwainComponent],      providers: [TwainService],    });    testQuote = 'Test Quote';    // Create a fake TwainService object with a `getQuote()` spy    const twainService = TestBed.inject(TwainService);    // Make the spy return a synchronous Observable with the test data    getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote));    fixture = TestBed.createComponent(TwainComponent);    fixture.autoDetectChanges();    component = fixture.componentInstance;    quoteEl = fixture.nativeElement.querySelector('.twain');  });  describe('when test with synchronous observable', () => {    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    // The quote would not be immediately available if the service were truly async.    it('should show quote after component initialized', async () => {      await fixture.whenStable(); // onInit()      // sync spy result shows testQuote immediately after init      expect(quoteEl.textContent).toBe(testQuote);      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    // The error would not be immediately available if the service were truly async.    // Use `fakeAsync` because the component error calls `setTimeout`    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an error observable after a timeout      getQuoteSpy.and.returnValue(        defer(() => {          return new Promise((resolve, reject) => {            setTimeout(() => {              reject('TwainService test failure');            });          });        }),      );      fixture.detectChanges(); // onInit()      // sync spy errors immediately after init      tick(); // flush the setTimeout()      fixture.detectChanges(); // update errorMessage within setTimeout()      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });  describe('when test with asynchronous observable', () => {    beforeEach(() => {      // Simulate delayed observable values with the `asyncData()` helper      getQuoteSpy.and.returnValue(asyncData(testQuote));    });    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    it('should still not show quote after component initialized', () => {      fixture.detectChanges();      // getQuote service is async => still has not returned with quote      // so should show the start value, '...'      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      expect(errorMessage()).withContext('should not show error').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    it('should show quote after getQuote (fakeAsync)', fakeAsync(() => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      tick(); // flush the observable to get the quote      fixture.detectChanges(); // update view      expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    }));    it('should show quote after getQuote (async)', async () => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      await fixture.whenStable();      // wait for async getQuote      fixture.detectChanges(); // update view with quote      expect(quoteEl.textContent).toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    });    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an async error observable      getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure'));      fixture.detectChanges();      tick(); // component shows error after a setTimeout()      fixture.detectChanges(); // update error message      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });});\n\n```\n\n### [Async observable helpers](https://angular.dev/guide/testing/components-scenarios\\#async-observable-helpers)\n\nThe async observable was produced by an `asyncData` helper.\nThe `asyncData` helper is a utility function that you'll have to write yourself, or copy this one from the sample code.\n\ncheck\n\n```\n      /* * Mock async observables that return asynchronously. * The observable either emits once and completes or errors. * * Must call `tick()` when test with `fakeAsync()`. * * THE FOLLOWING DON'T WORK * Using `of().delay()` triggers TestBed errors; * see https://github.com/angular/angular/issues/10127 . * * Using `asap` scheduler - as in `of(value, asap)` - doesn't work either. */import {defer} from 'rxjs';/** * Create async observable that emits-once and completes * after a JS engine turn */export function asyncData<T>(data: T) {  return defer(() => Promise.resolve(data));}/** * Create async observable error that errors * after a JS engine turn */export function asyncError<T>(errorObject: any) {  return defer(() => Promise.reject(errorObject));}\n\n```\n\nThis helper's observable emits the `data` value in the next turn of the JavaScript engine.\n\nThe [RxJS `defer()` operator](http://reactivex.io/documentation/operators/defer.html) returns an observable.\nIt takes a factory function that returns either a promise or an observable.\nWhen something subscribes to _defer_'s observable, it adds the subscriber to a new observable created with that factory.\n\nThe `defer()` operator transforms the `Promise.resolve()` into a new observable that, like `HttpClient`, emits once and completes.\nSubscribers are unsubscribed after they receive the data value.\n\nThere's a similar helper for producing an async error.\n\ncheck\n\n```\n      /* * Mock async observables that return asynchronously. * The observable either emits once and completes or errors. * * Must call `tick()` when test with `fakeAsync()`. * * THE FOLLOWING DON'T WORK * Using `of().delay()` triggers TestBed errors; * see https://github.com/angular/angular/issues/10127 . * * Using `asap` scheduler - as in `of(value, asap)` - doesn't work either. */import {defer} from 'rxjs';/** * Create async observable that emits-once and completes * after a JS engine turn */export function asyncData<T>(data: T) {  return defer(() => Promise.resolve(data));}/** * Create async observable error that errors * after a JS engine turn */export function asyncError<T>(errorObject: any) {  return defer(() => Promise.reject(errorObject));}\n\n```\n\n### [More async tests](https://angular.dev/guide/testing/components-scenarios\\#more-async-tests)\n\nNow that the `getQuote()` spy is returning async observables, most of your tests will have to be async as well.\n\nHere's a `fakeAsync()` test that demonstrates the data flow you'd expect in the real world.\n\ncheck\n\n```\n      import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => {  let component: TwainComponent;  let fixture: ComponentFixture<TwainComponent>;  let getQuoteSpy: jasmine.Spy;  let quoteEl: HTMLElement;  let testQuote: string;  // Helper function to get the error message element value  // An *ngIf keeps it out of the DOM until there is an error  const errorMessage = () => {    const el = fixture.nativeElement.querySelector('.error');    return el ? el.textContent : null;  };  beforeEach(() => {    TestBed.configureTestingModule({      imports: [TwainComponent],      providers: [TwainService],    });    testQuote = 'Test Quote';    // Create a fake TwainService object with a `getQuote()` spy    const twainService = TestBed.inject(TwainService);    // Make the spy return a synchronous Observable with the test data    getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote));    fixture = TestBed.createComponent(TwainComponent);    fixture.autoDetectChanges();    component = fixture.componentInstance;    quoteEl = fixture.nativeElement.querySelector('.twain');  });  describe('when test with synchronous observable', () => {    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    // The quote would not be immediately available if the service were truly async.    it('should show quote after component initialized', async () => {      await fixture.whenStable(); // onInit()      // sync spy result shows testQuote immediately after init      expect(quoteEl.textContent).toBe(testQuote);      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    // The error would not be immediately available if the service were truly async.    // Use `fakeAsync` because the component error calls `setTimeout`    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an error observable after a timeout      getQuoteSpy.and.returnValue(        defer(() => {          return new Promise((resolve, reject) => {            setTimeout(() => {              reject('TwainService test failure');            });          });        }),      );      fixture.detectChanges(); // onInit()      // sync spy errors immediately after init      tick(); // flush the setTimeout()      fixture.detectChanges(); // update errorMessage within setTimeout()      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });  describe('when test with asynchronous observable', () => {    beforeEach(() => {      // Simulate delayed observable values with the `asyncData()` helper      getQuoteSpy.and.returnValue(asyncData(testQuote));    });    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    it('should still not show quote after component initialized', () => {      fixture.detectChanges();      // getQuote service is async => still has not returned with quote      // so should show the start value, '...'      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      expect(errorMessage()).withContext('should not show error').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    it('should show quote after getQuote (fakeAsync)', fakeAsync(() => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      tick(); // flush the observable to get the quote      fixture.detectChanges(); // update view      expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    }));    it('should show quote after getQuote (async)', async () => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      await fixture.whenStable();      // wait for async getQuote      fixture.detectChanges(); // update view with quote      expect(quoteEl.textContent).toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    });    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an async error observable      getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure'));      fixture.detectChanges();      tick(); // component shows error after a setTimeout()      fixture.detectChanges(); // update error message      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });});\n\n```\n\nNotice that the quote element displays the placeholder value ( `'...'`) after `ngOnInit()`.\nThe first quote hasn't arrived yet.\n\nTo flush the first quote from the observable, you call [tick()](https://angular.dev/guide/testing/api/core/testing/tick).\nThen call `detectChanges()` to tell Angular to update the screen.\n\nThen you can assert that the quote element displays the expected text.\n\n### [Async test without `fakeAsync()`](https://angular.dev/guide/testing/components-scenarios\\#async-test-without-fakeasync)\n\nHere's the previous `fakeAsync()` test, re-written with the `async`.\n\ncheck\n\n```\n      import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => {  let component: TwainComponent;  let fixture: ComponentFixture<TwainComponent>;  let getQuoteSpy: jasmine.Spy;  let quoteEl: HTMLElement;  let testQuote: string;  // Helper function to get the error message element value  // An *ngIf keeps it out of the DOM until there is an error  const errorMessage = () => {    const el = fixture.nativeElement.querySelector('.error');    return el ? el.textContent : null;  };  beforeEach(() => {    TestBed.configureTestingModule({      imports: [TwainComponent],      providers: [TwainService],    });    testQuote = 'Test Quote';    // Create a fake TwainService object with a `getQuote()` spy    const twainService = TestBed.inject(TwainService);    // Make the spy return a synchronous Observable with the test data    getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote));    fixture = TestBed.createComponent(TwainComponent);    fixture.autoDetectChanges();    component = fixture.componentInstance;    quoteEl = fixture.nativeElement.querySelector('.twain');  });  describe('when test with synchronous observable', () => {    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    // The quote would not be immediately available if the service were truly async.    it('should show quote after component initialized', async () => {      await fixture.whenStable(); // onInit()      // sync spy result shows testQuote immediately after init      expect(quoteEl.textContent).toBe(testQuote);      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    // The error would not be immediately available if the service were truly async.    // Use `fakeAsync` because the component error calls `setTimeout`    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an error observable after a timeout      getQuoteSpy.and.returnValue(        defer(() => {          return new Promise((resolve, reject) => {            setTimeout(() => {              reject('TwainService test failure');            });          });        }),      );      fixture.detectChanges(); // onInit()      // sync spy errors immediately after init      tick(); // flush the setTimeout()      fixture.detectChanges(); // update errorMessage within setTimeout()      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });  describe('when test with asynchronous observable', () => {    beforeEach(() => {      // Simulate delayed observable values with the `asyncData()` helper      getQuoteSpy.and.returnValue(asyncData(testQuote));    });    it('should not show quote before OnInit', () => {      expect(quoteEl.textContent).withContext('nothing displayed').toBe('');      expect(errorMessage()).withContext('should not show error element').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false);    });    it('should still not show quote after component initialized', () => {      fixture.detectChanges();      // getQuote service is async => still has not returned with quote      // so should show the start value, '...'      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      expect(errorMessage()).withContext('should not show error').toBeNull();      expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);    });    it('should show quote after getQuote (fakeAsync)', fakeAsync(() => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      tick(); // flush the observable to get the quote      fixture.detectChanges(); // update view      expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    }));    it('should show quote after getQuote (async)', async () => {      fixture.detectChanges(); // ngOnInit()      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');      await fixture.whenStable();      // wait for async getQuote      fixture.detectChanges(); // update view with quote      expect(quoteEl.textContent).toBe(testQuote);      expect(errorMessage()).withContext('should not show error').toBeNull();    });    it('should display error when TwainService fails', fakeAsync(() => {      // tell spy to return an async error observable      getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure'));      fixture.detectChanges();      tick(); // component shows error after a setTimeout()      fixture.detectChanges(); // update error message      expect(errorMessage())        .withContext('should display error')        .toMatch(/test failure/);      expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');    }));  });});\n\n```\n\n### [`whenStable`](https://angular.dev/guide/testing/components-scenarios\\#whenstable)\n\nThe test must wait for the `getQuote()` observable to emit the next quote.\nInstead of calling [tick()](https://angular.dev/guide/testing/api/core/testing/tick), it calls `fixture.whenStable()`.\n\nThe `fixture.whenStable()` returns a promise that resolves when the JavaScript engine's task queue becomes empty.\nIn this example, the task queue becomes empty when the observable emits the first quote.\n\n## [Component with inputs and outputs](https://angular.dev/guide/testing/components-scenarios\\#component-with-inputs-and-outputs)\n\nA component with inputs and outputs typically appears inside the view template of a host component.\nThe host uses a property binding to set the input property and an event binding to listen to events raised by the output property.\n\nThe testing goal is to verify that such bindings work as expected.\nThe tests should set input values and listen for output events.\n\nThe `DashboardHeroComponent` is a tiny example of a component in this role.\nIt displays an individual hero provided by the `DashboardComponent`.\nClicking that hero tells the `DashboardComponent` that the user has selected the hero.\n\nThe `DashboardHeroComponent` is embedded in the `DashboardComponent` template like this:\n\ncheck\n\n```\n      <h2 highlight>{{ title }}</h2><div class=\"grid grid-pad\">  @for (hero of heroes; track hero) {    <dashboard-hero      class=\"col-1-4\"      [hero]=\"hero\"      (selected)=\"gotoDetail($event)\"    >    </dashboard-hero>  }</div>\n\n```\n\nThe `DashboardHeroComponent` appears in an `*ngFor` repeater, which sets each component's `hero` input property to the looping value and listens for the component's `selected` event.\n\nHere's the component's full definition:\n\ncheck\n\n```\n      import {Component, input, output} from '@angular/core';import {UpperCasePipe} from '@angular/common';import {Hero} from '../model/hero';@Component({  selector: 'dashboard-hero',  template: `    <button type=\"button\" (click)=\"click()\" class=\"hero\">      {{ hero().name | uppercase }}    </button>  `,  styleUrls: ['./dashboard-hero.component.css'],  imports: [UpperCasePipe],})export class DashboardHeroComponent {  hero = input.required<Hero>();  selected = output<Hero>();  click() {    this.selected.emit(this.hero());  }}\n\n```\n\nWhile testing a component this simple has little intrinsic value, it's worth knowing how.\nUse one of these approaches:\n\n- Test it as used by `DashboardComponent`\n- Test it as a standalone component\n- Test it as used by a substitute for `DashboardComponent`\n\nThe immediate goal is to test the `DashboardHeroComponent`, not the `DashboardComponent`, so, try the second and third options.\n\n### [Test `DashboardHeroComponent` standalone](https://angular.dev/guide/testing/components-scenarios\\#test-dashboardherocomponent-standalone)\n\nHere's the meat of the spec file setup.\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {\n...    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\nNotice how the setup code assigns a test hero ( `expectedHero`) to the component's `hero` property, emulating the way the `DashboardComponent` would set it using the property binding in its repeater.\n\nThe following test verifies that the hero name is propagated to the template using a binding.\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\nBecause the [template](https://angular.dev/guide/testing/components-scenarios#dashboard-hero-component) passes the hero name through the Angular `UpperCasePipe`, the test must match the element value with the upper-cased name.\n\n### [Clicking](https://angular.dev/guide/testing/components-scenarios\\#clicking)\n\nClicking the hero should raise a `selected` event that the host component ( `DashboardComponent` presumably) can hear:\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\nThe component's `selected` property returns an `EventEmitter`, which looks like an RxJS synchronous `Observable` to consumers.\nThe test subscribes to it _explicitly_ just as the host component does _implicitly_.\n\nIf the component behaves as expected, clicking the hero's element should tell the component's `selected` property to emit the `hero` object.\n\nThe test detects that event through its subscription to `selected`.\n\n### [`triggerEventHandler`](https://angular.dev/guide/testing/components-scenarios\\#triggereventhandler)\n\nThe `heroDe` in the previous test is a `DebugElement` that represents the hero `<div>`.\n\nIt has Angular properties and methods that abstract interaction with the native element.\nThis test calls the `DebugElement.triggerEventHandler` with the \"click\" event name.\nThe \"click\" event binding responds by calling `DashboardHeroComponent.click()`.\n\nThe Angular `DebugElement.triggerEventHandler` can raise _any data-bound event_ by its _event name_.\nThe second parameter is the event object passed to the handler.\n\nThe test triggered a \"click\" event.\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\nIn this case, the test correctly assumes that the runtime event handler, the component's `click()` method, doesn't care about the event object.\n\n**HELPFUL:** Other handlers are less forgiving.\nFor example, the `RouterLink` directive expects an object with a `button` property that identifies which mouse button, if any, was pressed during the click.\nThe `RouterLink` directive throws an error if the event object is missing.\n\n### [Click the element](https://angular.dev/guide/testing/components-scenarios\\#click-the-element)\n\nThe following test alternative calls the native element's own `click()` method, which is perfectly fine for _this component_.\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\n### [`click()` helper](https://angular.dev/guide/testing/components-scenarios\\#click-helper)\n\nClicking a button, an anchor, or an arbitrary HTML element is a common test task.\n\nMake that consistent and straightforward by encapsulating the _click-triggering_ process in a helper such as the following `click()` function:\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, tick} from '@angular/core/testing';export * from './async-observable-helpers';export * from './jasmine-matchers';///// Short utilities //////** Wait a tick, then detect changes */export function advance(f: ComponentFixture<any>): void {  tick();  f.detectChanges();}// See https://developer.mozilla.org/docs/Web/API/MouseEvent/button/** Button events to pass to `DebugElement.triggerEventHandler` for RouterLink event handler */export const ButtonClickEvents = {  left: {button: 0},  right: {button: 2},};/** Simulate element click. Defaults to mouse left-button click event. */export function click(  el: DebugElement | HTMLElement,  eventObj: any = ButtonClickEvents.left,): void {  if (el instanceof HTMLElement) {    el.click();  } else {    el.triggerEventHandler('click', eventObj);  }}\n\n```\n\nThe first parameter is the _element-to-click_.\nIf you want, pass a custom event object as the second parameter.\nThe default is a partial [left-button mouse event object](https://developer.mozilla.org/docs/Web/API/MouseEvent/button) accepted by many handlers including the `RouterLink` directive.\n\n**IMPORTANT:** The `click()` helper function is **not** one of the Angular testing utilities.\nIt's a function defined in _this guide's sample code_.\nAll of the sample tests use it.\nIf you like it, add it to your own collection of helpers.\n\nHere's the previous test, rewritten using the click helper.\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\n## [Component inside a test host](https://angular.dev/guide/testing/components-scenarios\\#component-inside-a-test-host)\n\nThe previous tests played the role of the host `DashboardComponent` themselves.\nBut does the `DashboardHeroComponent` work correctly when properly data-bound to a host component?\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\nThe test host sets the component's `hero` input property with its test hero.\nIt binds the component's `selected` event with its `onSelected` handler, which records the emitted hero in its `selectedHero` property.\n\nLater, the tests will be able to check `selectedHero` to verify that the `DashboardHeroComponent.selected` event emitted the expected hero.\n\nThe setup for the `test-host` tests is similar to the setup for the stand-alone tests:\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {\n...    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\nThis testing module configuration shows three important differences:\n\n- It _imports_ both the `DashboardHeroComponent` and the `TestHostComponent`\n- It _creates_ the `TestHostComponent` instead of the `DashboardHeroComponent`\n- The `TestHostComponent` sets the `DashboardHeroComponent.hero` with a binding\n\nThe `createComponent` returns a `fixture` that holds an instance of `TestHostComponent` instead of an instance of `DashboardHeroComponent`.\n\nCreating the `TestHostComponent` has the side effect of creating a `DashboardHeroComponent` because the latter appears within the template of the former.\nThe query for the hero element ( `heroEl`) still finds it in the test DOM, albeit at greater depth in the element tree than before.\n\nThe tests themselves are almost identical to the stand-alone version:\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\nOnly the selected event test differs.\nIt confirms that the selected `DashboardHeroComponent` hero really does find its way up through the event binding to the host component.\n\n## [Routing component](https://angular.dev/guide/testing/components-scenarios\\#routing-component)\n\nA _routing component_ is a component that tells the `Router` to navigate to another component.\nThe `DashboardComponent` is a _routing component_ because the user can navigate to the `HeroDetailComponent` by clicking on one of the _hero buttons_ on the dashboard.\n\nAngular provides test helpers to reduce boilerplate and more effectively test code which depends on `HttpClient`. The `provideRouter` function can be used directly in the test module as well.\n\ncheck\n\n```\n      import {provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {NO_ERRORS_SCHEMA} from '@angular/core';import {TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {NavigationEnd, provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {firstValueFrom} from 'rxjs';import {filter} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {HeroService} from '../model/hero.service';import {getTestHeroes} from '../model/testing/test-heroes';import {DashboardComponent} from './dashboard.component';import {appConfig} from '../app.config';import {HeroDetailComponent} from '../hero/hero-detail.component';beforeEach(addMatchers);let comp: DashboardComponent;let harness: RouterTestingHarness;////////  Deep  ////////////////describe('DashboardComponent (deep)', () => {  compileAndCreate();  tests(clickForDeep);  function clickForDeep() {    // get first <div class=\"hero\">    const heroEl: HTMLElement = harness.routeNativeElement!.querySelector('.hero')!;    click(heroEl);    return firstValueFrom(      TestBed.inject(Router).events.pipe(filter((e) => e instanceof NavigationEnd)),    );  }});////////  Shallow ////////////////describe('DashboardComponent (shallow)', () => {  beforeEach(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [DashboardComponent, HeroDetailComponent],        providers: [provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}])],        schemas: [NO_ERRORS_SCHEMA],      }),    );  });  compileAndCreate();  tests(clickForShallow);  function clickForShallow() {    // get first <dashboard-hero> DebugElement    const heroDe = harness.routeDebugElement!.query(By.css('dashboard-hero'));    heroDe.triggerEventHandler('selected', comp.heroes[0]);    return Promise.resolve();  }});/** Add TestBed providers, compile, and create DashboardComponent */function compileAndCreate() {  beforeEach(async () => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [DashboardComponent],        providers: [          provideRouter([{path: '**', component: DashboardComponent}]),          provideHttpClient(),          provideHttpClientTesting(),          HeroService,        ],      }),    );    harness = await RouterTestingHarness.create();    comp = await harness.navigateByUrl('/', DashboardComponent);    TestBed.inject(HttpTestingController).expectOne('api/heroes').flush(getTestHeroes());  });}/** * The (almost) same tests for both. * Only change: the way that the first hero is clicked */function tests(heroClick: () => Promise<unknown>) {  describe('after get dashboard heroes', () => {    let router: Router;    // Trigger component so it gets heroes and binds to them    beforeEach(waitForAsync(() => {      router = TestBed.inject(Router);      harness.detectChanges(); // runs ngOnInit -> getHeroes    }));    it('should HAVE heroes', () => {      expect(comp.heroes.length)        .withContext('should have heroes after service promise resolves')        .toBeGreaterThan(0);    });    it('should DISPLAY heroes', () => {      // Find and examine the displayed heroes      // Look for them in the DOM by css class      const heroes = harness.routeNativeElement!.querySelectorAll('dashboard-hero');      expect(heroes.length).withContext('should display 4 heroes').toBe(4);    });    it('should tell navigate when hero clicked', async () => {      await heroClick(); // trigger click on first inner <div class=\"hero\">      // expecting to navigate to id of the component's first hero      const id = comp.heroes[0].id;      expect(TestBed.inject(Router).url)        .withContext('should nav to HeroDetail for first hero')        .toEqual(`/heroes/${id}`);    });  });}\n\n```\n\nThe following test clicks the displayed hero and confirms that we navigate to the expected URL.\n\ncheck\n\n```\n      import {provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {NO_ERRORS_SCHEMA} from '@angular/core';import {TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {NavigationEnd, provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {firstValueFrom} from 'rxjs';import {filter} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {HeroService} from '../model/hero.service';import {getTestHeroes} from '../model/testing/test-heroes';import {DashboardComponent} from './dashboard.component';import {appConfig} from '../app.config';import {HeroDetailComponent} from '../hero/hero-detail.component';beforeEach(addMatchers);let comp: DashboardComponent;let harness: RouterTestingHarness;////////  Deep  ////////////////describe('DashboardComponent (deep)', () => {  compileAndCreate();  tests(clickForDeep);  function clickForDeep() {    // get first <div class=\"hero\">    const heroEl: HTMLElement = harness.routeNativeElement!.querySelector('.hero')!;    click(heroEl);    return firstValueFrom(      TestBed.inject(Router).events.pipe(filter((e) => e instanceof NavigationEnd)),    );  }});////////  Shallow ////////////////describe('DashboardComponent (shallow)', () => {  beforeEach(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [DashboardComponent, HeroDetailComponent],        providers: [provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}])],        schemas: [NO_ERRORS_SCHEMA],      }),    );  });  compileAndCreate();  tests(clickForShallow);  function clickForShallow() {    // get first <dashboard-hero> DebugElement    const heroDe = harness.routeDebugElement!.query(By.css('dashboard-hero'));    heroDe.triggerEventHandler('selected', comp.heroes[0]);    return Promise.resolve();  }});/** Add TestBed providers, compile, and create DashboardComponent */function compileAndCreate() {  beforeEach(async () => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [DashboardComponent],        providers: [          provideRouter([{path: '**', component: DashboardComponent}]),          provideHttpClient(),          provideHttpClientTesting(),          HeroService,        ],      }),    );    harness = await RouterTestingHarness.create();    comp = await harness.navigateByUrl('/', DashboardComponent);    TestBed.inject(HttpTestingController).expectOne('api/heroes').flush(getTestHeroes());  });}/** * The (almost) same tests for both. * Only change: the way that the first hero is clicked */function tests(heroClick: () => Promise<unknown>) {  describe('after get dashboard heroes', () => {    let router: Router;    // Trigger component so it gets heroes and binds to them    beforeEach(waitForAsync(() => {      router = TestBed.inject(Router);      harness.detectChanges(); // runs ngOnInit -> getHeroes    }));    it('should HAVE heroes', () => {      expect(comp.heroes.length)        .withContext('should have heroes after service promise resolves')        .toBeGreaterThan(0);    });    it('should DISPLAY heroes', () => {      // Find and examine the displayed heroes      // Look for them in the DOM by css class      const heroes = harness.routeNativeElement!.querySelectorAll('dashboard-hero');      expect(heroes.length).withContext('should display 4 heroes').toBe(4);    });    it('should tell navigate when hero clicked', async () => {      await heroClick(); // trigger click on first inner <div class=\"hero\">      // expecting to navigate to id of the component's first hero      const id = comp.heroes[0].id;      expect(TestBed.inject(Router).url)        .withContext('should nav to HeroDetail for first hero')        .toEqual(`/heroes/${id}`);    });  });}\n\n```\n\n## [Routed components](https://angular.dev/guide/testing/components-scenarios\\#routed-components)\n\nA _routed component_ is the destination of a `Router` navigation.\nIt can be trickier to test, especially when the route to the component _includes parameters_.\nThe `HeroDetailComponent` is a _routed component_ that is the destination of such a route.\n\nWhen a user clicks a _Dashboard_ hero, the `DashboardComponent` tells the `Router` to navigate to `heroes/:id`.\nThe `:id` is a route parameter whose value is the `id` of the hero to edit.\n\nThe `Router` matches that URL to a route to the `HeroDetailComponent`.\nIt creates an `ActivatedRoute` object with the routing information and injects it into a new instance of the `HeroDetailComponent`.\n\nHere are the services injected into `HeroDetailComponent`:\n\ncheck\n\n```\n      import {Component, inject} from '@angular/core';import {ActivatedRoute, Router, RouterLink} from '@angular/router';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailService} from './hero-detail.service';@Component({  selector: 'app-hero-detail',  templateUrl: './hero-detail.component.html',  styleUrls: ['./hero-detail.component.css'],  providers: [HeroDetailService],  imports: [sharedImports, RouterLink],})export class HeroDetailComponent {  private heroDetailService = inject(HeroDetailService);  private route = inject(ActivatedRoute);  private router = inject(Router);  hero!: Hero;  constructor() {    // get hero when `id` param changes    this.route.paramMap.subscribe((pmap) => this.getHero(pmap.get('id')));  }  private getHero(id: string | null): void {    // when no id or id===0, create new blank hero    if (!id) {      this.hero = {id: 0, name: ''} as Hero;      return;    }    this.heroDetailService.getHero(id).subscribe((hero) => {      if (hero) {        this.hero = hero;      } else {        this.gotoList(); // id not found; navigate to list      }    });  }  save(): void {    this.heroDetailService.saveHero(this.hero).subscribe(() => this.gotoList());  }  cancel() {    this.gotoList();  }  gotoList() {    this.router.navigate(['../'], {relativeTo: this.route});  }}\n\n```\n\nThe `HeroDetail` component needs the `id` parameter so it can fetch the corresponding hero using the `HeroDetailService`.\nThe component has to get the `id` from the `ActivatedRoute.paramMap` property which is an `Observable`.\n\nIt can't just reference the `id` property of the `ActivatedRoute.paramMap`.\nThe component has to _subscribe_ to the `ActivatedRoute.paramMap` observable and be prepared for the `id` to change during its lifetime.\n\ncheck\n\n```\n      import {Component, inject} from '@angular/core';import {ActivatedRoute, Router, RouterLink} from '@angular/router';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailService} from './hero-detail.service';@Component({  selector: 'app-hero-detail',  templateUrl: './hero-detail.component.html',  styleUrls: ['./hero-detail.component.css'],  providers: [HeroDetailService],  imports: [sharedImports, RouterLink],})export class HeroDetailComponent {  private heroDetailService = inject(HeroDetailService);  private route = inject(ActivatedRoute);  private router = inject(Router);  hero!: Hero;  constructor() {    // get hero when `id` param changes    this.route.paramMap.subscribe((pmap) => this.getHero(pmap.get('id')));  }  private getHero(id: string | null): void {    // when no id or id===0, create new blank hero    if (!id) {      this.hero = {id: 0, name: ''} as Hero;      return;    }    this.heroDetailService.getHero(id).subscribe((hero) => {      if (hero) {        this.hero = hero;      } else {        this.gotoList(); // id not found; navigate to list      }    });  }  save(): void {    this.heroDetailService.saveHero(this.hero).subscribe(() => this.gotoList());  }  cancel() {    this.gotoList();  }  gotoList() {    this.router.navigate(['../'], {relativeTo: this.route});  }}\n\n```\n\nTests can explore how the `HeroDetailComponent` responds to different `id` parameter values by navigating to different routes.\n\n### [Testing with the `RouterTestingHarness`](https://angular.dev/guide/testing/components-scenarios\\#testing-with-the-routertestingharness)\n\nHere's a test demonstrating the component's behavior when the observed `id` refers to an existing hero:\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\n**HELPFUL:** In the following section, the `createComponent()` method and `page` object are discussed.\nRely on your intuition for now.\n\nWhen the `id` cannot be found, the component should re-route to the `HeroListComponent`.\n\nThe test suite setup provided the same router harness [described above](https://angular.dev/guide/testing/components-scenarios#routing-component).\n\nThis test expects the component to try to navigate to the `HeroListComponent`.\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\n## [Nested component tests](https://angular.dev/guide/testing/components-scenarios\\#nested-component-tests)\n\nComponent templates often have nested components, whose templates might contain more components.\n\nThe component tree can be very deep and sometimes the nested components play no role in testing the component at the top of the tree.\n\nThe `AppComponent`, for example, displays a navigation bar with anchors and their `RouterLink` directives.\n\n### app/app.component.html\n\n```\n      <app-banner></app-banner><app-welcome></app-welcome><nav>  <a routerLink=\"/dashboard\">Dashboard</a>  <a routerLink=\"/heroes\">Heroes</a>  <a routerLink=\"/about\">About</a></nav><router-outlet></router-outlet>\n\n```\n\ncheck\n\nTo validate the links but not the navigation, you don't need the `Router` to navigate and you don't need the `<router-outlet>` to mark where the `Router` inserts _routed components_.\n\nThe `BannerComponent` and `WelcomeComponent` (indicated by `<app-banner>` and `<app-welcome>`) are also irrelevant.\n\nYet any test that creates the `AppComponent` in the DOM also creates instances of these three components and, if you let that happen, you'll have to configure the `TestBed` to create them.\n\nIf you neglect to declare them, the Angular compiler won't recognize the `<app-banner>`, `<app-welcome>`, and `<router-outlet>` tags in the `AppComponent` template and will throw an error.\n\nIf you declare the real components, you'll also have to declare _their_ nested components and provide for _all_ services injected in _any_ component in the tree.\n\nThis section describes two techniques for minimizing the setup.\nUse them, alone or in combination, to stay focused on testing the primary component.\n\n### [Stubbing unneeded components](https://angular.dev/guide/testing/components-scenarios\\#stubbing-unneeded-components)\n\nIn the first technique, you create and declare stub versions of the components and directive that play little or no role in the tests.\n\ncheck\n\n```\n      import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app.config';import {UserService} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,          RouterOutletStubComponent,          WelcomeStubComponent,        ],        providers: [provideRouter([]), UserService],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,        ],        providers: [provideRouter([]), UserService],        schemas: [NO_ERRORS_SCHEMA],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});function tests() {  let routerLinks: RouterLink[];  let linkDes: DebugElement[];  beforeEach(() => {    fixture.detectChanges(); // trigger initial data binding    // find DebugElements with an attached RouterLinkStubDirective    linkDes = fixture.debugElement.queryAll(By.directive(RouterLink));    // get attached link directive instances    // using each DebugElement's injector    routerLinks = linkDes.map((de) => de.injector.get(RouterLink));  });  it('can instantiate the component', () => {    expect(comp).not.toBeNull();  });  it('can get RouterLinks from template', () => {    expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3);    expect(routerLinks[0].href).toBe('/dashboard');    expect(routerLinks[1].href).toBe('/heroes');    expect(routerLinks[2].href).toBe('/about');  });  it('can click Heroes link in template', fakeAsync(() => {    const heroesLinkDe = linkDes[1]; // heroes link DebugElement    TestBed.inject(Router).resetConfig([{path: '**', children: []}]);    heroesLinkDe.triggerEventHandler('click', {button: 0});    tick();    fixture.detectChanges();    expect(TestBed.inject(Router).url).toBe('/heroes');  }));}\n\n```\n\nThe stub selectors match the selectors for the corresponding real components.\nBut their templates and classes are empty.\n\nThen declare them in the `TestBed` configuration next to the components, directives, and pipes that need to be real.\n\ncheck\n\n```\n      import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app.config';import {UserService} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,          RouterOutletStubComponent,          WelcomeStubComponent,        ],        providers: [provideRouter([]), UserService],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,        ],        providers: [provideRouter([]), UserService],        schemas: [NO_ERRORS_SCHEMA],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});function tests() {  let routerLinks: RouterLink[];  let linkDes: DebugElement[];  beforeEach(() => {    fixture.detectChanges(); // trigger initial data binding    // find DebugElements with an attached RouterLinkStubDirective    linkDes = fixture.debugElement.queryAll(By.directive(RouterLink));    // get attached link directive instances    // using each DebugElement's injector    routerLinks = linkDes.map((de) => de.injector.get(RouterLink));  });  it('can instantiate the component', () => {    expect(comp).not.toBeNull();  });  it('can get RouterLinks from template', () => {    expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3);    expect(routerLinks[0].href).toBe('/dashboard');    expect(routerLinks[1].href).toBe('/heroes');    expect(routerLinks[2].href).toBe('/about');  });  it('can click Heroes link in template', fakeAsync(() => {    const heroesLinkDe = linkDes[1]; // heroes link DebugElement    TestBed.inject(Router).resetConfig([{path: '**', children: []}]);    heroesLinkDe.triggerEventHandler('click', {button: 0});    tick();    fixture.detectChanges();    expect(TestBed.inject(Router).url).toBe('/heroes');  }));}\n\n```\n\nThe `AppComponent` is the test subject, so of course you declare the real version.\n\nThe rest are stubs.\n\n### [`NO_ERRORS_SCHEMA`](https://angular.dev/guide/testing/components-scenarios\\#noerrorsschema)\n\nIn the second approach, add `NO_ERRORS_SCHEMA` to the `TestBed.schemas` metadata.\n\ncheck\n\n```\n      import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app.config';import {UserService} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,          RouterOutletStubComponent,          WelcomeStubComponent,        ],        providers: [provideRouter([]), UserService],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,\\\n...          RouterLink,        ],        providers: [provideRouter([]), UserService],        schemas: [NO_ERRORS_SCHEMA],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});function tests() {  let routerLinks: RouterLink[];  let linkDes: DebugElement[];  beforeEach(() => {    fixture.detectChanges(); // trigger initial data binding    // find DebugElements with an attached RouterLinkStubDirective    linkDes = fixture.debugElement.queryAll(By.directive(RouterLink));    // get attached link directive instances    // using each DebugElement's injector    routerLinks = linkDes.map((de) => de.injector.get(RouterLink));  });  it('can instantiate the component', () => {    expect(comp).not.toBeNull();  });  it('can get RouterLinks from template', () => {    expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3);    expect(routerLinks[0].href).toBe('/dashboard');    expect(routerLinks[1].href).toBe('/heroes');    expect(routerLinks[2].href).toBe('/about');  });  it('can click Heroes link in template', fakeAsync(() => {    const heroesLinkDe = linkDes[1]; // heroes link DebugElement    TestBed.inject(Router).resetConfig([{path: '**', children: []}]);    heroesLinkDe.triggerEventHandler('click', {button: 0});    tick();    fixture.detectChanges();    expect(TestBed.inject(Router).url).toBe('/heroes');  }));}\n\n```\n\nThe `NO_ERRORS_SCHEMA` tells the Angular compiler to ignore unrecognized elements and attributes.\n\nThe compiler recognizes the `<app-root>` element and the `routerLink` attribute because you declared a corresponding `AppComponent` and `RouterLink` in the `TestBed` configuration.\n\nBut the compiler won't throw an error when it encounters `<app-banner>`, `<app-welcome>`, or `<router-outlet>`.\nIt simply renders them as empty tags and the browser ignores them.\n\nYou no longer need the stub components.\n\n### [Use both techniques together](https://angular.dev/guide/testing/components-scenarios\\#use-both-techniques-together)\n\nThese are techniques for _Shallow Component Testing_, so-named because they reduce the visual surface of the component to just those elements in the component's template that matter for tests.\n\nThe `NO_ERRORS_SCHEMA` approach is the easier of the two but don't overuse it.\n\nThe `NO_ERRORS_SCHEMA` also prevents the compiler from telling you about the missing components and attributes that you omitted inadvertently or misspelled.\nYou could waste hours chasing phantom bugs that the compiler would have caught in an instant.\n\nThe _stub component_ approach has another advantage.\nWhile the stubs in _this_ example were empty, you could give them stripped-down templates and classes if your tests need to interact with them in some way.\n\nIn practice you will combine the two techniques in the same setup, as seen in this example.\n\ncheck\n\n```\n      import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app.config';import {UserService} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,          RouterOutletStubComponent,          WelcomeStubComponent,        ],        providers: [provideRouter([]), UserService],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,        ],        providers: [provideRouter([]), UserService],        schemas: [NO_ERRORS_SCHEMA],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});function tests() {  let routerLinks: RouterLink[];  let linkDes: DebugElement[];  beforeEach(() => {    fixture.detectChanges(); // trigger initial data binding    // find DebugElements with an attached RouterLinkStubDirective    linkDes = fixture.debugElement.queryAll(By.directive(RouterLink));    // get attached link directive instances    // using each DebugElement's injector    routerLinks = linkDes.map((de) => de.injector.get(RouterLink));  });  it('can instantiate the component', () => {    expect(comp).not.toBeNull();  });  it('can get RouterLinks from template', () => {    expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3);    expect(routerLinks[0].href).toBe('/dashboard');    expect(routerLinks[1].href).toBe('/heroes');    expect(routerLinks[2].href).toBe('/about');  });  it('can click Heroes link in template', fakeAsync(() => {    const heroesLinkDe = linkDes[1]; // heroes link DebugElement    TestBed.inject(Router).resetConfig([{path: '**', children: []}]);    heroesLinkDe.triggerEventHandler('click', {button: 0});    tick();    fixture.detectChanges();    expect(TestBed.inject(Router).url).toBe('/heroes');  }));}\n\n```\n\nThe Angular compiler creates the `BannerStubComponent` for the `<app-banner>` element and applies the `RouterLink` to the anchors with the `routerLink` attribute, but it ignores the `<app-welcome>` and `<router-outlet>` tags.\n\n### [`By.directive` and injected directives](https://angular.dev/guide/testing/components-scenarios\\#bydirective-and-injected-directives)\n\nA little more setup triggers the initial data binding and gets references to the navigation links:\n\ncheck\n\n```\n      import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app.config';import {UserService} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,          RouterOutletStubComponent,          WelcomeStubComponent,        ],        providers: [provideRouter([]), UserService],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,        ],        providers: [provideRouter([]), UserService],        schemas: [NO_ERRORS_SCHEMA],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});function tests() {  let routerLinks: RouterLink[];  let linkDes: DebugElement[];  beforeEach(() => {    fixture.detectChanges(); // trigger initial data binding    // find DebugElements with an attached RouterLinkStubDirective    linkDes = fixture.debugElement.queryAll(By.directive(RouterLink));    // get attached link directive instances    // using each DebugElement's injector    routerLinks = linkDes.map((de) => de.injector.get(RouterLink));  });  it('can instantiate the component', () => {    expect(comp).not.toBeNull();  });  it('can get RouterLinks from template', () => {    expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3);    expect(routerLinks[0].href).toBe('/dashboard');    expect(routerLinks[1].href).toBe('/heroes');    expect(routerLinks[2].href).toBe('/about');  });  it('can click Heroes link in template', fakeAsync(() => {    const heroesLinkDe = linkDes[1]; // heroes link DebugElement    TestBed.inject(Router).resetConfig([{path: '**', children: []}]);    heroesLinkDe.triggerEventHandler('click', {button: 0});    tick();    fixture.detectChanges();    expect(TestBed.inject(Router).url).toBe('/heroes');  }));}\n\n```\n\nThree points of special interest:\n\n- Locate the anchor elements with an attached directive using `By.directive`\n- The query returns `DebugElement` wrappers around the matching elements\n- Each `DebugElement` exposes a dependency injector with the specific instance of the directive attached to that element\n\nThe `AppComponent` links to validate are as follows:\n\ncheck\n\n```\n      <app-banner></app-banner><app-welcome></app-welcome><nav>  <a routerLink=\"/dashboard\">Dashboard</a>  <a routerLink=\"/heroes\">Heroes</a>  <a routerLink=\"/about\">About</a></nav><router-outlet></router-outlet>\n\n```\n\nHere are some tests that confirm those links are wired to the `routerLink` directives as expected:\n\ncheck\n\n```\n      import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app.config';import {UserService} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,          RouterOutletStubComponent,          WelcomeStubComponent,        ],        providers: [provideRouter([]), UserService],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => {  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [          AppComponent,          BannerStubComponent,          RouterLink,        ],        providers: [provideRouter([]), UserService],        schemas: [NO_ERRORS_SCHEMA],      }),    )      .compileComponents()      .then(() => {        fixture = TestBed.createComponent(AppComponent);        comp = fixture.componentInstance;      });  }));  tests();});function tests() {  let routerLinks: RouterLink[];  let linkDes: DebugElement[];  beforeEach(() => {    fixture.detectChanges(); // trigger initial data binding    // find DebugElements with an attached RouterLinkStubDirective    linkDes = fixture.debugElement.queryAll(By.directive(RouterLink));    // get attached link directive instances    // using each DebugElement's injector    routerLinks = linkDes.map((de) => de.injector.get(RouterLink));  });  it('can instantiate the component', () => {    expect(comp).not.toBeNull();  });  it('can get RouterLinks from template', () => {    expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3);    expect(routerLinks[0].href).toBe('/dashboard');    expect(routerLinks[1].href).toBe('/heroes');    expect(routerLinks[2].href).toBe('/about');  });  it('can click Heroes link in template', fakeAsync(() => {    const heroesLinkDe = linkDes[1]; // heroes link DebugElement    TestBed.inject(Router).resetConfig([{path: '**', children: []}]);    heroesLinkDe.triggerEventHandler('click', {button: 0});    tick();    fixture.detectChanges();    expect(TestBed.inject(Router).url).toBe('/heroes');  }));}\n\n```\n\n## [Use a `page` object](https://angular.dev/guide/testing/components-scenarios\\#use-a-page-object)\n\nThe `HeroDetailComponent` is a simple view with a title, two hero fields, and two buttons.\n\nBut there's plenty of template complexity even in this simple form.\n\n### app/hero/hero-detail.component.html\n\n```\n      @if (hero) {  <div>    <h2>      <span>{{ hero.name | titlecase }}</span> Details    </h2>    <div><span>id: </span>{{ hero.id }}</div>    <div>      <label for=\"name\">name: </label>      <input id=\"name\" [(ngModel)]=\"hero.name\" placeholder=\"name\" />    </div>    <button type=\"button\" (click)=\"save()\">Save</button>    <button type=\"button\" (click)=\"cancel()\">Cancel</button>  </div>}\n\n```\n\ncheck\n\nTests that exercise the component need \u2026\n\n- To wait until a hero arrives before elements appear in the DOM\n- A reference to the title text\n- A reference to the name input box to inspect and set it\n- References to the two buttons so they can click them\n\nEven a small form such as this one can produce a mess of tortured conditional setup and CSS element selection.\n\nTame the complexity with a `Page` class that handles access to component properties and encapsulates the logic that sets them.\n\nHere is such a `Page` class for the `hero-detail.component.spec.ts`\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\nNow the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of `Page`.\n\nA `createComponent` method creates a `page` object and fills in the blanks once the `hero` arrives.\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\nHere are a few more `HeroDetailComponent` tests to reinforce the point.\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\n## [Calling `compileComponents()`](https://angular.dev/guide/testing/components-scenarios\\#calling-compilecomponents)\n\n**HELPFUL:** Ignore this section if you _only_ run tests with the CLI `ng test` command because the CLI compiles the application before running the tests.\n\nIf you run tests in a **non-CLI environment**, the tests might fail with a message like this one:\n\n```\n      Error: This test module uses the component BannerComponentwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.Please call \"TestBed.compileComponents\" before your test.\n\n```\n\ncheck\n\nThe root of the problem is at least one of the components involved in the test specifies an external template or CSS file as the following version of the `BannerComponent` does.\n\n### app/banner/banner-external.component.ts (external template & css)\n\n```\n      import {Component} from '@angular/core';@Component({  selector: 'app-banner',  templateUrl: './banner-external.component.html',  styleUrls: ['./banner-external.component.css'],})export class BannerComponent {  title = 'Test Tour of Heroes';}\n\n```\n\ncheck\n\nThe test fails when the `TestBed` tries to create the component.\n\ncheck\n\n```\n      import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner-external.component';describe('BannerComponent (external files)', () => {  let component: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  describe('setup that may fail', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }); // missing call to compileComponents()      fixture = TestBed.createComponent(BannerComponent);    });    it('should create', () => {      expect(fixture.componentInstance).toBeDefined();    });  });  describe('Two beforeEach', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }).compileComponents(); // compile template and css    });    // synchronous beforeEach    beforeEach(() => {      fixture = TestBed.createComponent(BannerComponent);      component = fixture.componentInstance; // BannerComponent test instance      h1 = fixture.nativeElement.querySelector('h1');    });    tests();  });  describe('One beforeEach', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }).compileComponents();      fixture = TestBed.createComponent(BannerComponent);      component = fixture.componentInstance;      h1 = fixture.nativeElement.querySelector('h1');    });    tests();  });  function tests() {    it('no title in the DOM until manually call `detectChanges`', () => {      expect(h1.textContent).toEqual('');    });    it('should display original title', () => {      fixture.detectChanges();      expect(h1.textContent).toContain(component.title);    });    it('should display a different test title', () => {      component.title = 'Test Title';      fixture.detectChanges();      expect(h1.textContent).toContain('Test Title');    });  }});\n\n```\n\nRecall that the application hasn't been compiled.\nSo when you call `createComponent()`, the `TestBed` compiles implicitly.\n\nThat's not a problem when the source code is in memory.\nBut the `BannerComponent` requires external files that the compiler must read from the file system, an inherently _asynchronous_ operation.\n\nIf the `TestBed` were allowed to continue, the tests would run and fail mysteriously before the compiler could finish.\n\nThe preemptive error message tells you to compile explicitly with `compileComponents()`.\n\n### [`compileComponents()` is async](https://angular.dev/guide/testing/components-scenarios\\#compilecomponents-is-async)\n\nYou must call `compileComponents()` within an asynchronous test function.\n\n**CRITICAL:** If you neglect to make the test function async (for example, forget to use `waitForAsync()` as described), you'll see this error message\n\n```\n      Error: ViewDestroyedError: Attempt to use a destroyed view\n\n```\n\ncheck\n\nA typical approach is to divide the setup logic into two separate `beforeEach()` functions:\n\n| Functions | Details |\n| :-- | :-- |\n| Asynchronous `beforeEach()` | Compiles the components |\n| Synchronous `beforeEach()` | Performs the remaining setup |\n\n### [The async `beforeEach`](https://angular.dev/guide/testing/components-scenarios\\#the-async-beforeeach)\n\nWrite the first async `beforeEach` like this.\n\ncheck\n\n```\n      import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner-external.component';describe('BannerComponent (external files)', () => {  let component: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  describe('setup that may fail', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }); // missing call to compileComponents()      fixture = TestBed.createComponent(BannerComponent);    });    it('should create', () => {      expect(fixture.componentInstance).toBeDefined();    });  });  describe('Two beforeEach', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }).compileComponents(); // compile template and css    });    // synchronous beforeEach    beforeEach(() => {      fixture = TestBed.createComponent(BannerComponent);      component = fixture.componentInstance; // BannerComponent test instance      h1 = fixture.nativeElement.querySelector('h1');    });    tests();  });  describe('One beforeEach', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }).compileComponents();      fixture = TestBed.createComponent(BannerComponent);      component = fixture.componentInstance;      h1 = fixture.nativeElement.querySelector('h1');    });    tests();  });  function tests() {    it('no title in the DOM until manually call `detectChanges`', () => {      expect(h1.textContent).toEqual('');    });    it('should display original title', () => {      fixture.detectChanges();      expect(h1.textContent).toContain(component.title);    });    it('should display a different test title', () => {      component.title = 'Test Title';      fixture.detectChanges();      expect(h1.textContent).toContain('Test Title');    });  }});\n\n```\n\nThe `TestBed.configureTestingModule()` method returns the `TestBed` class so you can chain calls to other `TestBed` static methods such as `compileComponents()`.\n\nIn this example, the `BannerComponent` is the only component to compile.\nOther examples configure the testing module with multiple components and might import application modules that hold yet more components.\nAny of them could require external files.\n\nThe `TestBed.compileComponents` method asynchronously compiles all components configured in the testing module.\n\n**IMPORTANT:** Do not re-configure the `TestBed` after calling `compileComponents()`.\n\nCalling `compileComponents()` closes the current `TestBed` instance to further configuration.\nYou cannot call any more `TestBed` configuration methods, not `configureTestingModule()` nor any of the `override...` methods.\nThe `TestBed` throws an error if you try.\n\nMake `compileComponents()` the last step before calling `TestBed.createComponent()`.\n\n### [The synchronous `beforeEach`](https://angular.dev/guide/testing/components-scenarios\\#the-synchronous-beforeeach)\n\nThe second, synchronous `beforeEach()` contains the remaining setup steps, which include creating the component and querying for elements to inspect.\n\ncheck\n\n```\n      import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner-external.component';describe('BannerComponent (external files)', () => {  let component: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  describe('setup that may fail', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }); // missing call to compileComponents()      fixture = TestBed.createComponent(BannerComponent);    });    it('should create', () => {      expect(fixture.componentInstance).toBeDefined();    });  });  describe('Two beforeEach', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }).compileComponents(); // compile template and css    });    // synchronous beforeEach    beforeEach(() => {      fixture = TestBed.createComponent(BannerComponent);      component = fixture.componentInstance; // BannerComponent test instance      h1 = fixture.nativeElement.querySelector('h1');    });    tests();  });  describe('One beforeEach', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }).compileComponents();      fixture = TestBed.createComponent(BannerComponent);      component = fixture.componentInstance;      h1 = fixture.nativeElement.querySelector('h1');    });    tests();  });  function tests() {    it('no title in the DOM until manually call `detectChanges`', () => {      expect(h1.textContent).toEqual('');    });    it('should display original title', () => {      fixture.detectChanges();      expect(h1.textContent).toContain(component.title);    });    it('should display a different test title', () => {      component.title = 'Test Title';      fixture.detectChanges();      expect(h1.textContent).toContain('Test Title');    });  }});\n\n```\n\nCount on the test runner to wait for the first asynchronous `beforeEach` to finish before calling the second.\n\n### [Consolidated setup](https://angular.dev/guide/testing/components-scenarios\\#consolidated-setup)\n\nYou can consolidate the two `beforeEach()` functions into a single, async `beforeEach()`.\n\nThe `compileComponents()` method returns a promise so you can perform the synchronous setup tasks _after_ compilation by moving the synchronous code after the `await` keyword, where the promise has been resolved.\n\ncheck\n\n```\n      import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner-external.component';describe('BannerComponent (external files)', () => {  let component: BannerComponent;  let fixture: ComponentFixture<BannerComponent>;  let h1: HTMLElement;  describe('setup that may fail', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }); // missing call to compileComponents()      fixture = TestBed.createComponent(BannerComponent);    });    it('should create', () => {      expect(fixture.componentInstance).toBeDefined();    });  });  describe('Two beforeEach', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }).compileComponents(); // compile template and css    });    // synchronous beforeEach    beforeEach(() => {      fixture = TestBed.createComponent(BannerComponent);      component = fixture.componentInstance; // BannerComponent test instance      h1 = fixture.nativeElement.querySelector('h1');    });    tests();  });  describe('One beforeEach', () => {    beforeEach(async () => {      await TestBed.configureTestingModule({        imports: [BannerComponent],      }).compileComponents();      fixture = TestBed.createComponent(BannerComponent);      component = fixture.componentInstance;      h1 = fixture.nativeElement.querySelector('h1');    });    tests();  });  function tests() {    it('no title in the DOM until manually call `detectChanges`', () => {      expect(h1.textContent).toEqual('');    });    it('should display original title', () => {      fixture.detectChanges();      expect(h1.textContent).toContain(component.title);    });    it('should display a different test title', () => {      component.title = 'Test Title';      fixture.detectChanges();      expect(h1.textContent).toContain('Test Title');    });  }});\n\n```\n\n### [`compileComponents()` is harmless](https://angular.dev/guide/testing/components-scenarios\\#compilecomponents-is-harmless)\n\nThere's no harm in calling `compileComponents()` when it's not required.\n\nThe component test file generated by the CLI calls `compileComponents()` even though it is never required when running `ng test`.\n\nThe tests in this guide only call `compileComponents` when necessary.\n\n## [Setup with module imports](https://angular.dev/guide/testing/components-scenarios\\#setup-with-module-imports)\n\nEarlier component tests configured the testing module with a few `declarations` like this:\n\ncheck\n\n```\n      import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => {  let comp: DashboardHeroComponent;  let expectedHero: Hero;  let fixture: ComponentFixture<DashboardHeroComponent>;  let heroDe: DebugElement;  let heroEl: HTMLElement;  beforeEach(() => {    TestBed.configureTestingModule({      providers: appProviders,    });  });  beforeEach(async () => {    fixture = TestBed.createComponent(DashboardHeroComponent);    fixture.autoDetectChanges();    comp = fixture.componentInstance;    // find the hero's DebugElement and element    heroDe = fixture.debugElement.query(By.css('.hero'));    heroEl = heroDe.nativeElement;    // mock the hero supplied by the parent component    expectedHero = {id: 42, name: 'Test Name'};    // simulate the parent setting the input property with that hero    fixture.componentRef.setInput('hero', expectedHero);    // wait for initial data binding    await fixture.whenStable();  });  it('should display hero name in uppercase', () => {    const expectedPipedName = expectedHero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked (triggerEventHandler)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroDe.triggerEventHandler('click');    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (element.click)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    heroEl.click();    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with DebugElement)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroDe); // click helper with DebugElement    expect(selectedHero).toBe(expectedHero);  });  it('should raise selected event when clicked (click helper with native element)', () => {    let selectedHero: Hero | undefined;    comp.selected.subscribe((hero: Hero) => (selectedHero = hero));    click(heroEl); // click helper with native element    expect(selectedHero).toBe(expectedHero);  });});//////////////////describe('DashboardHeroComponent when inside a test host', () => {  let testHost: TestHostComponent;  let fixture: ComponentFixture<TestHostComponent>;  let heroEl: HTMLElement;  beforeEach(waitForAsync(() => {    TestBed.configureTestingModule({      providers: appProviders,      imports: [DashboardHeroComponent, TestHostComponent],    })      .compileComponents();  }));  beforeEach(() => {    // create TestHostComponent instead of DashboardHeroComponent    fixture = TestBed.createComponent(TestHostComponent);    testHost = fixture.componentInstance;    heroEl = fixture.nativeElement.querySelector('.hero');    fixture.detectChanges(); // trigger initial data binding  });  it('should display hero name', () => {    const expectedPipedName = testHost.hero.name.toUpperCase();    expect(heroEl.textContent).toContain(expectedPipedName);  });  it('should raise selected event when clicked', () => {    click(heroEl);    // selected hero should be the same data bound hero    expect(testHost.selectedHero).toBe(testHost.hero);  });});////// Test Host Component //////import {Component} from '@angular/core';@Component({  imports: [DashboardHeroComponent],  template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent {  hero: Hero = {id: 42, name: 'Test Name'};  selectedHero: Hero | undefined;  onSelected(hero: Hero) {    this.selectedHero = hero;  }}\n\n```\n\nThe `DashboardComponent` is simple.\nIt needs no help.\nBut more complex components often depend on other components, directives, pipes, and providers and these must be added to the testing module too.\n\nFortunately, the `TestBed.configureTestingModule` parameter parallels the metadata passed to the `@NgModule` decorator which means you can also specify `providers` and `imports`.\n\nThe `HeroDetailComponent` requires a lot of help despite its small size and simple construction.\nIn addition to the support it receives from the default testing module `CommonModule`, it needs:\n\n- `NgModel` and friends in the `FormsModule` to enable two-way data binding\n- The `TitleCasePipe` from the `shared` folder\n- The Router services\n- The Hero data access services\n\nOne approach is to configure the testing module from the individual pieces as in this example:\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\n**HELPFUL:** Notice that the `beforeEach()` is asynchronous and calls `TestBed.compileComponents` because the `HeroDetailComponent` has an external template and css file.\n\nAs explained in [Calling `compileComponents()`](https://angular.dev/guide/testing/components-scenarios#calling-compilecomponents), these tests could be run in a non-CLI environment where Angular would have to compile them in the browser.\n\n### [Import a shared module](https://angular.dev/guide/testing/components-scenarios\\#import-a-shared-module)\n\nBecause many application components need the `FormsModule` and the `TitleCasePipe`, the developer created a `SharedModule` to combine these and other frequently requested parts.\n\nThe test configuration can use the `SharedModule` too as seen in this alternative setup:\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\nIt's a bit tighter and smaller, with fewer import statements, which are not shown in this example.\n\n### [Import a feature module](https://angular.dev/guide/testing/components-scenarios\\#import-a-feature-module)\n\nThe `HeroDetailComponent` is part of the `HeroModule` [Feature Module](https://angular.dev/guide/testing/guide/ngmodules/feature-modules) that aggregates more of the interdependent pieces including the `SharedModule`.\nTry a test configuration that imports the `HeroModule` like this one:\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\nOnly the _test doubles_ in the `providers` remain.\nEven the `HeroDetailComponent` declaration is gone.\n\nIn fact, if you try to declare it, Angular will throw an error because `HeroDetailComponent` is declared in both the `HeroModule` and the `DynamicTestModule` created by the `TestBed`.\n\n**HELPFUL:** Importing the component's feature module can be the best way to configure tests when there are many mutual dependencies within the module and the module is small, as feature modules tend to be.\n\n## [Override component providers](https://angular.dev/guide/testing/components-scenarios\\#override-component-providers)\n\nThe `HeroDetailComponent` provides its own `HeroDetailService`.\n\ncheck\n\n```\n      import {Component, inject} from '@angular/core';import {ActivatedRoute, Router, RouterLink} from '@angular/router';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailService} from './hero-detail.service';@Component({  selector: 'app-hero-detail',  templateUrl: './hero-detail.component.html',  styleUrls: ['./hero-detail.component.css'],  providers: [HeroDetailService],  imports: [sharedImports, RouterLink],})export class HeroDetailComponent {  private heroDetailService = inject(HeroDetailService);  private route = inject(ActivatedRoute);  private router = inject(Router);  hero!: Hero;  constructor() {    // get hero when `id` param changes    this.route.paramMap.subscribe((pmap) => this.getHero(pmap.get('id')));  }  private getHero(id: string | null): void {    // when no id or id===0, create new blank hero    if (!id) {      this.hero = {id: 0, name: ''} as Hero;      return;    }    this.heroDetailService.getHero(id).subscribe((hero) => {      if (hero) {        this.hero = hero;      } else {        this.gotoList(); // id not found; navigate to list      }    });  }  save(): void {    this.heroDetailService.saveHero(this.hero).subscribe(() => this.gotoList());  }  cancel() {    this.gotoList();  }  gotoList() {    this.router.navigate(['../'], {relativeTo: this.route});  }\n...}\n\n```\n\nIt's not possible to stub the component's `HeroDetailService` in the `providers` of the `TestBed.configureTestingModule`.\nThose are providers for the _testing module_, not the component.\nThey prepare the dependency injector at the _fixture level_.\n\nAngular creates the component with its _own_ injector, which is a _child_ of the fixture injector.\nIt registers the component's providers (the `HeroDetailService` in this case) with the child injector.\n\nA test cannot get to child injector services from the fixture injector.\nAnd `TestBed.configureTestingModule` can't configure them either.\n\nAngular has created new instances of the real `HeroDetailService` all along!\n\n**HELPFUL:** These tests could fail or timeout if the `HeroDetailService` made its own XHR calls to a remote server.\nThere might not be a remote server to call.\n\nFortunately, the `HeroDetailService` delegates responsibility for remote data access to an injected `HeroService`.\n\ncheck\n\n```\n      import {inject, Injectable} from '@angular/core';import {Observable} from 'rxjs';import {map} from 'rxjs/operators';import {Hero} from '../model/hero';import {HeroService} from '../model/hero.service';@Injectable({providedIn: 'root'})export class HeroDetailService {  private heroService = inject(HeroService);  // Returns a clone which caller may modify safely  getHero(id: number | string): Observable<Hero | null> {    if (typeof id === 'string') {      id = parseInt(id, 10);    }    return this.heroService.getHero(id).pipe(      map((hero) => (hero ? Object.assign({}, hero) : null)), // clone or null    );  }  saveHero(hero: Hero) {    return this.heroService.updateHero(hero);  }\n...}\n\n```\n\nThe [previous test configuration](https://angular.dev/guide/testing/components-scenarios#import-a-feature-module) replaces the real `HeroService` with a `TestHeroService` that intercepts server requests and fakes their responses.\n\nWhat if you aren't so lucky.\nWhat if faking the `HeroService` is hard?\nWhat if `HeroDetailService` makes its own server requests?\n\nThe `TestBed.overrideComponent` method can replace the component's `providers` with easy-to-manage _test doubles_ as seen in the following setup variation:\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\nNotice that `TestBed.configureTestingModule` no longer provides a fake `HeroService` because it's [not needed](https://angular.dev/guide/testing/components-scenarios#spy-stub).\n\n### [The `overrideComponent` method](https://angular.dev/guide/testing/components-scenarios\\#the-overridecomponent-method)\n\nFocus on the `overrideComponent` method.\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\nIt takes two arguments: the component type to override ( `HeroDetailComponent`) and an override metadata object.\nThe [override metadata object](https://angular.dev/guide/testing/guide/testing/utility-apis#metadata-override-object) is a generic defined as follows:\n\n```\n      type MetadataOverride<T> = {  add?: Partial<T>;  remove?: Partial<T>;  set?: Partial<T>;};\n\n```\n\ncheck\n\nA metadata override object can either add-and-remove elements in metadata properties or completely reset those properties.\nThis example resets the component's `providers` metadata.\n\nThe type parameter, `T`, is the kind of metadata you'd pass to the `@Component` decorator:\n\n```\n      selector?: string;template?: string;templateUrl?: string;providers?: any[];\u2026\n\n```\n\ncheck\n\n### [Provide a _spy stub_ ( `HeroDetailServiceSpy`)](https://angular.dev/guide/testing/components-scenarios\\#provide-a-spy-stub-herodetailservicespy)\n\nThis example completely replaces the component's `providers` array with a new array containing a `HeroDetailServiceSpy`.\n\nThe `HeroDetailServiceSpy` is a stubbed version of the real `HeroDetailService` that fakes all necessary features of that service.\nIt neither injects nor delegates to the lower level `HeroService` so there's no need to provide a test double for that.\n\nThe related `HeroDetailComponent` tests will assert that methods of the `HeroDetailService` were called by spying on the service methods.\nAccordingly, the stub implements its methods as spies:\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\n### [The override tests](https://angular.dev/guide/testing/components-scenarios\\#the-override-tests)\n\nNow the tests can control the component's hero directly by manipulating the spy-stub's `testHero` and confirm that service methods were called.\n\ncheck\n\n```\n      import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => {  describe('with HeroModule setup', heroModuleSetup);  describe('when override its provided HeroDetailService', overrideSetup);  describe('with FormsModule setup', formsModuleSetup);  describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() {  class HeroDetailServiceSpy {    testHero: Hero = {...testHero};    /* emit cloned test hero */    getHero = jasmine      .createSpy('getHero')      .and.callFake(() => asyncData(Object.assign({}, this.testHero)));    /* emit clone of test hero, with changes merged in */    saveHero = jasmine      .createSpy('saveHero')      .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero)));  }  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes', component: HeroListComponent},            {path: 'heroes/:id', component: HeroDetailComponent},          ]),          HttpClient,          HttpHandler,          // HeroDetailService at this level is IRRELEVANT!          {provide: HeroDetailService, useValue: {}},        ],      }),    )      .overrideComponent(HeroDetailComponent, {        set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]},      })      .compileComponents();  });  let hdsSpy: HeroDetailServiceSpy;  beforeEach(async () => {    harness = await RouterTestingHarness.create();    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);    page = new Page();    // get the component's injected HeroDetailServiceSpy    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;    harness.detectChanges();  });  it('should have called `getHero`', () => {    expect(hdsSpy.getHero.calls.count())      .withContext('getHero called once')      .toBe(1, 'getHero called once');  });  it(\"should display stub hero's name\", () => {    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);  });  it('should save stub hero change', fakeAsync(() => {    const origName = hdsSpy.testHero.name;    const newName = 'New Name';    page.nameInput.value = newName;    page.nameInput.dispatchEvent(new Event('input')); // tell Angular    expect(component.hero.name).withContext('component hero has new name').toBe(newName);    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);    click(page.saveBtn);    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);    tick(); // wait for async save to complete    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);    expect(TestBed.inject(Router).url).toEqual('/heroes');  }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, HeroListComponent],        providers: [          provideRouter([            {path: 'heroes/:id', component: HeroDetailComponent},            {path: 'heroes', component: HeroListComponent},          ]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  describe('when navigate to existing hero', () => {    let expectedHero: Hero;    beforeEach(async () => {      expectedHero = firstHero;      await createComponent(expectedHero.id);    });    it(\"should display that hero's name\", () => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });    it('should navigate when click cancel', () => {      click(page.cancelBtn);      expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`);    });    it('should save when click save but not navigate immediately', () => {      click(page.saveBtn);      expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'}));      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    });    it('should navigate when click save and save resolves', fakeAsync(() => {      click(page.saveBtn);      tick(); // wait for async save to complete      expect(TestBed.inject(Router).url).toEqual('/heroes/41');    }));    it('should convert hero name to Title Case', async () => {      harness.fixture.autoDetectChanges();      // get the name's input and display elements from the DOM      const hostElement: HTMLElement = harness.routeNativeElement!;      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;      // simulate user entering a new name into the input box      nameInput.value = 'quick BROWN  fOx';      // Dispatch a DOM event so that Angular learns of input value change.      nameInput.dispatchEvent(new Event('input'));      // Wait for Angular to update the display binding through the title pipe      await harness.fixture.whenStable();      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');    });  });  describe('when navigate to non-existent hero id', () => {    beforeEach(async () => {      await createComponent(999);    });    it('should try to navigate back to hero list', () => {      expect(TestBed.inject(Router).url).toEqual('/heroes');    });  });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [FormsModule, HeroDetailComponent, TitleCasePipe],        providers: [          provideHttpClient(),          provideHttpClientTesting(),          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}///////////////////////function sharedModuleSetup() {  beforeEach(async () => {    await TestBed.configureTestingModule(      Object.assign({}, appConfig, {        imports: [HeroDetailComponent, sharedImports],        providers: [          provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]),          provideHttpClient(),          provideHttpClientTesting(),        ],      }),    ).compileComponents();  });  it(\"should display 1st hero's name\", async () => {    const expectedHero = firstHero;    await createComponent(expectedHero.id).then(() => {      expect(page.nameDisplay.textContent).toBe(expectedHero.name);    });  });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables  */async function createComponent(id: number) {  harness = await RouterTestingHarness.create();  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);  page = new Page();  const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`);  const hero = getTestHeroes().find((h) => h.id === Number(id));  request.flush(hero ? [hero] : []);  harness.detectChanges();}class Page {  // getter properties wait to query the DOM until called.  get buttons() {    return this.queryAll<HTMLButtonElement>('button');  }  get saveBtn() {    return this.buttons[0];  }  get cancelBtn() {    return this.buttons[1];  }  get nameDisplay() {    return this.query<HTMLElement>('span');  }  get nameInput() {    return this.query<HTMLInputElement>('input');  }  //// query helpers ////  private query<T>(selector: string): T {    return harness.routeNativeElement!.querySelector(selector)! as T;  }  private queryAll<T>(selector: string): T[] {    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];  }}\n\n```\n\n### [More overrides](https://angular.dev/guide/testing/components-scenarios\\#more-overrides)\n\nThe `TestBed.overrideComponent` method can be called multiple times for the same or different components.\nThe `TestBed` offers similar `overrideDirective`, `overrideModule`, and `overridePipe` methods for digging into and replacing parts of these other classes.\n\nExplore the options and combinations on your own.",
  "title": "Component testing scenarios \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "hero",
    "expect",
    "component",
    "import",
    "fixture",
    "testbed",
    "angular",
    "async",
    "tobe",
    "test"
  ],
  "sourceURL": "https://angular.dev/guide/testing/components-scenarios"
}