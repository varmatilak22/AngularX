{
  "content": "Skip to main content\n\nmenu\n\nmenuAPI\n\n- [Roadmap](https://angular.dev/roadmap)\n- [Get involved](https://github.com/angular/angular/blob/main/CONTRIBUTING.md)\n- API Reference\n- CLI Reference\n- Error Encyclopedia\n- Extended Diagnostics\n- [Versioning and releases](https://angular.dev/reference/releases)\n- [Version compatibility](https://angular.dev/reference/versions)\n- [Update guide](https://angular.dev/update-guide)\n- Configurations\n- Migrations\n\n- arrow\\_backMigrations\n  - [Overview](https://angular.dev/reference/migrations)\n  - [Standalone](https://angular.dev/reference/migrations/standalone)\n  - [Control Flow Syntax](https://angular.dev/reference/migrations/control-flow)\n  - [inject() Function](https://angular.dev/reference/migrations/inject-function)\n  - [Lazy-loaded routes](https://angular.dev/reference/migrations/route-lazy-loading)\n  - [Signal inputs](https://angular.dev/reference/migrations/signal-inputs)\n  - [Outputs](https://angular.dev/reference/migrations/outputs)\n  - [Signal queries](https://angular.dev/reference/migrations/signal-queries)\n  - [Clean up unused imports](https://angular.dev/reference/migrations/cleanup-unused-imports)\n  - [Self-closing tags](https://angular.dev/reference/migrations/self-closing-tags)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nAngular's `inject` function offers more accurate types and better compatibility with standard decorators, compared to constructor-based injection.\n\nThis schematic converts constructor-based injection in your classes to use the `inject` function instead.\n\nRun the schematic using the following command:\n\n```\n      ng generate @angular/core:inject\n\n```\n\ncheck\n\n#### [Before](https://angular.dev/reference/migrations/inject-function\\#before)\n\n```\n      import { Component, Inject, Optional } from '@angular/core';import { MyService } from './service';import { DI_TOKEN } from './token';@Component()export class MyComp {  constructor(    private service: MyService,    @Inject(DI_TOKEN) @Optional() readonly token: string) {}}\n\n```\n\ncheck\n\n#### [After](https://angular.dev/reference/migrations/inject-function\\#after)\n\n```\n      import { Component, inject } from '@angular/core';import { MyService } from './service';import { DI_TOKEN } from './token';@Component()export class MyComp {  private service = inject(MyService);  readonly token = inject(DI_TOKEN, { optional: true });}\n\n```\n\ncheck\n\n## [Migration options](https://angular.dev/reference/migrations/inject-function\\#migration-options)\n\nThe migration includes several options to customize its output.\n\n### [`path`](https://angular.dev/reference/migrations/inject-function\\#path)\n\nDetermines which sub-path in your project should be migrated. Pass in `.` or leave it blank to\nmigrate the entire directory.\n\n### [`migrateAbstractClasses`](https://angular.dev/reference/migrations/inject-function\\#migrateabstractclasses)\n\nAngular doesn't validate that parameters of abstract classes are injectable. This means that the\nmigration can't reliably migrate them to `inject` without risking breakages which is why they're\ndisabled by default. Enable this option if you want abstract classes to be migrated, but note\nthat you may have to **fix some breakages manually**.\n\n### [`backwardsCompatibleConstructors`](https://angular.dev/reference/migrations/inject-function\\#backwardscompatibleconstructors)\n\nBy default the migration tries to clean up the code as much as it can, which includes deleting\nparameters from the constructor, or even the entire constructor if it doesn't include any code.\nIn some cases this can lead to compilation errors when classes with Angular decorators inherit from\nother classes with Angular decorators. If you enable this option, the migration will generate an\nadditional constructor signature to keep it backwards compatible, at the expense of more code.\n\n#### [Before](https://angular.dev/reference/migrations/inject-function\\#before-1)\n\n```\n      import { Component } from '@angular/core';import { MyService } from './service';@Component()export class MyComp {  constructor(private service: MyService) {}}\n\n```\n\ncheck\n\n#### [After](https://angular.dev/reference/migrations/inject-function\\#after-1)\n\n```\n      import { Component } from '@angular/core';import { MyService } from './service';@Component()export class MyComp {  private service = inject(MyService);  /** Inserted by Angular inject() migration for backwards compatibility */  constructor(...args: unknown[]);  constructor() {}}\n\n```\n\ncheck\n\n### [`nonNullableOptional`](https://angular.dev/reference/migrations/inject-function\\#nonnullableoptional)\n\nIf injection fails for a parameter with the `@Optional` decorator, Angular returns `null` which\nmeans that the real type of any `@Optional` parameter will be `| null`. However, because decorators\ncannot influence their types, there is a lot of existing code whose type is incorrect. The type is\nfixed in `inject()` which can cause new compilation errors to show up. If you enable this option,\nthe migration will produce a non-null assertion after the `inject()` call to match the old type,\nat the expense of potentially hiding type errors.\n\n**NOTE:** non-null assertions won't be added to parameters that are already typed to be nullable,\nbecause the code that depends on them likely already accounts for their nullability.\n\n#### [Before](https://angular.dev/reference/migrations/inject-function\\#before-2)\n\n```\n      import { Component, Inject, Optional } from '@angular/core';import { TOKEN_ONE, TOKEN_TWO } from './token';@Component()export class MyComp {  constructor(    @Inject(TOKEN_ONE) @Optional() private tokenOne: number,    @Inject(TOKEN_TWO) @Optional() private tokenTwo: string | null) {}}\n\n```\n\ncheck\n\n#### [After](https://angular.dev/reference/migrations/inject-function\\#after-2)\n\n```\n      import { Component, inject } from '@angular/core';import { TOKEN_ONE, TOKEN_TWO } from './token';@Component()export class MyComp {  // Note the `!` at the end.  private tokenOne = inject(TOKEN_ONE, { optional: true })!;  // Does not have `!` at the end, because the type was already nullable.  private tokenTwo = inject(TOKEN_TWO, { optional: true });}\n\n```\n\ncheck",
  "title": "inject() Function \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "angular",
    "inject",
    "https",
    "dev",
    "reference",
    "migrations",
    "function",
    "import",
    "component",
    "constructor"
  ],
  "sourceURL": "https://angular.dev/reference/migrations/inject-function"
}