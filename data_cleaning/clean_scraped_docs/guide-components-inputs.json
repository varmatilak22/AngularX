{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backComponents\n  - [Anatomy of components](https://angular.dev/guide/components)\n  - [Selectors](https://angular.dev/guide/components/selectors)\n  - [Styling](https://angular.dev/guide/components/styling)\n  - [Accepting data with input properties](https://angular.dev/guide/components/inputs)\n  - [Custom events with outputs](https://angular.dev/guide/components/outputs)\n  - [Content projection with ng-content](https://angular.dev/guide/components/content-projection)\n  - [Host elements](https://angular.dev/guide/components/host-elements)\n  - [Lifecycle](https://angular.dev/guide/components/lifecycle)\n  - [Referencing component children with queries](https://angular.dev/guide/components/queries)\n  - [Using DOM APIs](https://angular.dev/guide/components/dom-apis)\n  - [Inheritance](https://angular.dev/guide/components/inheritance)\n  - [Programmatically rendering components](https://angular.dev/guide/components/programmatic-rendering)\n  - [Advanced configuration](https://angular.dev/guide/components/advanced-configuration)\n  - [Custom Elements](https://angular.dev/guide/elements)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\n**TIP:** This guide assumes you've already read the [Essentials Guide](https://angular.dev/guide/components/essentials). Read that first if you're new to Angular.\n\n**TIP:** If you're familiar with other web frameworks, input properties are similar to _props_.\n\nWhen you use a component, you commonly want to pass some data to it. A component specifies the data that it accepts by declaring\n**inputs**:\n\n```\n      import {Component, input} from '@angular/core';@Component({/*...*/})export class CustomSlider {  // Declare an input named 'value' with a default value of zero.  value = input(0);}\n\n```\n\ncheck\n\nThis lets you bind to the property in a template:\n\n```\n      <custom-slider [value]=\"50\" />\n\n```\n\ncheck\n\nIf an input has a default value, TypeScript infers the type from the default value:\n\n```\n      @Component({/*...*/})export class CustomSlider {  // TypeScript infers that this input is a number, returning InputSignal<number>.  value = input(0);}\n\n```\n\ncheck\n\nYou can explicitly declare a type for the input by specifying a generic parameter to the function.\n\nIf an input without a default value is not set, its value is `undefined`:\n\n```\n      @Component({/*...*/})export class CustomSlider {  // Produces an InputSignal<number | undefined> because `value` may not be set.  value = input<number>();}\n\n```\n\ncheck\n\n**Angular records inputs statically at compile-time**. Inputs cannot be added or removed at run-time.\n\nThe `input` function has special meaning to the Angular compiler. **You can exclusively call `input` in component and directive property initializers.**\n\nWhen extending a component class, **inputs are inherited by the child class.**\n\n**Input names are case-sensitive.**\n\n## [Reading inputs](https://angular.dev/guide/components/inputs\\#reading-inputs)\n\nThe `input` function returns an `InputSignal`. You can read the value by calling the signal:\n\n```\n      import {Component, input} from '@angular/core';@Component({/*...*/})export class CustomSlider {  // Declare an input named 'value' with a default value of zero.  value = input(0);  // Create a computed expression that reads the value input  label = computed(() => `The slider's value is ${this.value()}`);}\n\n```\n\ncheck\n\nSignals created by the `input` function are read-only.\n\n## [Required inputs](https://angular.dev/guide/components/inputs\\#required-inputs)\n\nYou can declare that an input is `required` by calling `input.required` instead of `input`:\n\n```\n      @Component({/*...*/})export class CustomSlider {  // Declare a required input named value. Returns an `InputSignal<number>`.  value = input.required<number>();}\n\n```\n\ncheck\n\nAngular enforces that required inputs _must_ be set when the component is used in a template. If you try to use a component without specifying all of its required inputs, Angular reports an error at build-time.\n\nRequired inputs do not automatically include `undefined` in the generic parameter of the returned `InputSignal`.\n\n## [Configuring inputs](https://angular.dev/guide/components/inputs\\#configuring-inputs)\n\nThe `input` function accepts a config object as a second parameter that lets you change the way that input works.\n\n### [Input transforms](https://angular.dev/guide/components/inputs\\#input-transforms)\n\nYou can specify a `transform` function to change the value of an input when it's set by Angular.\n\n```\n      @Component({  selector: 'custom-slider',  /*...*/})export class CustomSlider {  label = input('', {transform: trimString});}function trimString(value: string | undefined): string {  return value?.trim() ?? '';}\n\n```\n\ncheck\n\n```\n      <custom-slider [label]=\"systemVolume\" />\n\n```\n\ncheck\n\nIn the example above, whenever the value of `systemVolume` changes, Angular runs `trimString` and sets `label` to the result.\n\nThe most common use-case for input transforms is to accept a wider range of value types in templates, often including `null` and `undefined`.\n\n**Input transform function must be statically analyzable at build-time.** You cannot set transform functions conditionally or as the result of an expression evaluation.\n\n**Input transform functions should always be [pure functions](https://en.wikipedia.org/wiki/Pure_function).** Relying on state outside the transform function can lead to unpredictable behavior.\n\n#### [Type checking](https://angular.dev/guide/components/inputs\\#type-checking)\n\nWhen you specify an input transform, the type of the transform function's parameter determines the types of values that can be set to the input in a template.\n\n```\n      @Component({/*...*/})export class CustomSlider {  widthPx = input('', {transform: appendPx});}function appendPx(value: number): string {  return `${value}px`;}\n\n```\n\ncheck\n\nIn the example above, the `widthPx` input accepts a `number` while the `InputSignal` property returns a `string`.\n\n#### [Built-in transformations](https://angular.dev/guide/components/inputs\\#built-in-transformations)\n\nAngular includes two built-in transform functions for the two most common scenarios: coercing values to boolean and numbers.\n\n```\n      import {Component, input, booleanAttribute, numberAttribute} from '@angular/core';@Component({/*...*/})export class CustomSlider {  disabled = input(false, {transform: booleanAttribute});  value = input(0, {transform: numberAttribute});}\n\n```\n\ncheck\n\n`booleanAttribute` imitates the behavior of standard HTML [boolean attributes](https://developer.mozilla.org/docs/Glossary/Boolean/HTML), where the\n_presence_ of the attribute indicates a \"true\" value. However, Angular's `booleanAttribute` treats the literal string `\"false\"` as the boolean `false`.\n\n`numberAttribute` attempts to parse the given value to a number, producing `NaN` if parsing fails.\n\n### [Input aliases](https://angular.dev/guide/components/inputs\\#input-aliases)\n\nYou can specify the `alias` option to change the name of an input in templates.\n\n```\n      @Component({/*...*/})export class CustomSlider {  value = input(0, {alias: 'sliderValue'});}\n\n```\n\ncheck\n\n```\n      <custom-slider [sliderValue]=\"50\" />\n\n```\n\ncheck\n\nThis alias does not affect usage of the property in TypeScript code.\n\nWhile you should generally avoid aliasing inputs for components, this feature can be useful for renaming properties while preserving an alias for the original name or for avoiding collisions with the name of native DOM element properties.\n\n## [Model inputs](https://angular.dev/guide/components/inputs\\#model-inputs)\n\n**Model inputs** are a special type of input that enable a component to propagate new values back to its parent component.\n\nWhen creating a component, you can define a model input similarly to how you create a standard input.\n\nBoth types of input allow someone to bind a value into the property. However, **model inputs allow the component author to write values into the property**. If the property is bound with a two-way binding, the new value propagates to that binding.\n\n```\n      @Component({ /* ... */})export class CustomSlider {  // Define a model input named \"value\".  value = model(0);  increment() {    // Update the model input with a new value, propagating the value to any bindings.    this.value.update(oldValue => oldValue + 10);  }}@Component({  /* ... */  // Using the two-way binding syntax means that any changes to the slider's  // value automatically propagate back to the `volume` signal.  // Note that this binding uses the signal *instance*, not the signal value.  template: `<custom-slider [(value)]=\"volume\" />`,})export class MediaControls {  // Create a writable signal for the `volume` local state.  volume = signal(0);}\n\n```\n\ncheck\n\nIn the above example, the `CustomSlider` can write values into its `value` model input, which then propagates those values back to the `volume` signal in `MediaControls`. This binding keeps the values of `value` and `volume` in sync. Notice that the binding passes the `volume` signal instance, not the _value_ of the signal.\n\nIn other respects, model inputs work similarly to standard inputs. You can read the value by calling the signal function, including in reactive contexts like `computed` and `effect`.\n\nSee [Two-way binding](https://angular.dev/guide/components/guide/templates/two-way-binding) for more details on two-way binding in templates.\n\n### [Two-way binding with plain properties](https://angular.dev/guide/components/inputs\\#two-way-binding-with-plain-properties)\n\nYou can bind a plain JavaScript property to a model input.\n\n```\n      @Component({  /* ... */  // `value` is a model input.  // The parenthesis-inside-square-brackets syntax (aka \"banana-in-a-box\") creates a two-way binding  template: '<custom-slider [(value)]=\"volume\" />',})export class MediaControls {  protected volume = 0;}\n\n```\n\ncheck\n\nIn the example above, the `CustomSlider` can write values into its `value` model input, which then propagates those values back to the `volume` property in `MediaControls`. This binding keeps the values of `value` and `volume` in sync.\n\n### [Implicit `change` events](https://angular.dev/guide/components/inputs\\#implicit-change-events)\n\nWhen you declare a model input in a component or directive, Angular automatically creates a corresponding [output](https://angular.dev/guide/components/guide/components/outputs) for that model. The output's name is the model input's name suffixed with \"Change\".\n\n```\n      @Directive({ /* ... */ })export class CustomCheckbox {  // This automatically creates an output named \"checkedChange\".  // Can be subscribed to using `(checkedChange)=\"handler()\"` in the template.  checked = model(false);}\n\n```\n\ncheck\n\nAngular emits this change event whenever you write a new value into the model input by calling its `set` or `update` methods.\n\nSee [Custom events with outputs](https://angular.dev/guide/components/guide/components/outputs) for more details on outputs.\n\n### [Customizing model inputs](https://angular.dev/guide/components/inputs\\#customizing-model-inputs)\n\nYou can mark a model input as required or provide an alias in the same way as a [standard input](https://angular.dev/guide/components/guide/signals/inputs).\n\nModel inputs do not support input transforms.\n\n### [When to use model inputs](https://angular.dev/guide/components/inputs\\#when-to-use-model-inputs)\n\nUse model inputs when you want a component to support two-way binding. This is typically appropriate when a component exists to modify a value based on user interaction. Most commonly, custom form controls, such as a date picker or combobox, should use model inputs for their primary value.\n\n## [Choosing input names](https://angular.dev/guide/components/inputs\\#choosing-input-names)\n\nAvoid choosing input names that collide with properties on DOM elements like HTMLElement. Name collisions introduce confusion about whether the bound property belongs to the component or the DOM element.\n\nAvoid adding prefixes for component inputs like you would with component selectors. Since a given element can only host one component, any custom properties can be assumed to belong to the component.\n\n## [Declaring inputs with the `@Input` decorator](https://angular.dev/guide/components/inputs\\#declaring-inputs-with-the-input-decorator)\n\n**TIP:** While the Angular team recommends using the signal-based `input` function for new projects, the original decorator-based `@Input` API remains fully supported.\n\nYou can alternatively declare component inputs by adding the `@Input` decorator to a property:\n\n```\n      @Component({...})export class CustomSlider {  @Input() value = 0;}\n\n```\n\ncheck\n\nBinding to an input is the same in both signal-based and decorator-based inputs:\n\n```\n      <custom-slider [value]=\"50\" />\n\n```\n\ncheck\n\n### [Customizing decorator-based inputs](https://angular.dev/guide/components/inputs\\#customizing-decorator-based-inputs)\n\nThe `@Input` decorator accepts a config object that lets you change the way that input works.\n\n#### [Required inputs](https://angular.dev/guide/components/inputs\\#required-inputs-1)\n\nYou can specify the `required` option to enforce that a given input must always have a value.\n\n```\n      @Component({...})export class CustomSlider {  @Input({required: true}) value = 0;}\n\n```\n\ncheck\n\nIf you try to use a component without specifying all of its required inputs, Angular reports an error at build-time.\n\n#### [Input transforms](https://angular.dev/guide/components/inputs\\#input-transforms-1)\n\nYou can specify a `transform` function to change the value of an input when it's set by Angular. This transform function works identically to transform functions for signal-based inputs described above.\n\n```\n      @Component({  selector: 'custom-slider',  ...})export class CustomSlider {  @Input({transform: trimString}) label = '';}function trimString(value: string | undefined) { return value?.trim() ?? ''; }\n\n```\n\ncheck\n\n#### [Input aliases](https://angular.dev/guide/components/inputs\\#input-aliases-1)\n\nYou can specify the `alias` option to change the name of an input in templates.\n\n```\n      @Component({...})export class CustomSlider {  @Input({alias: 'sliderValue'}) value = 0;}\n\n```\n\ncheck\n\n```\n      <custom-slider [sliderValue]=\"50\" />\n\n```\n\ncheck\n\nThe `@Input` decorator also accepts the alias as its first parameter in place of the config object.\n\nInput aliases work the same way as for signal-based inputs described above.\n\n### [Inputs with getters and setters](https://angular.dev/guide/components/inputs\\#inputs-with-getters-and-setters)\n\nWhen using decorator-based inputs, a property implemented with a getter and setter can be an input:\n\n```\n      export class CustomSlider {  @Input()  get value(): number {    return this.internalValue;  }set value(newValue: number) { this.internalValue = newValue; }private internalValue = 0; }\n\n```\n\ncheck\n\nYou can even create a _write-only_ input by only defining a public setter:\n\n```\n      export class CustomSlider {  @Input()  set value(newValue: number) {    this.internalValue = newValue;  }private internalValue = 0; }\n\n```\n\ncheck\n\n**Prefer using input transforms instead of getters and setters** if possible.\n\nAvoid complex or costly getters and setters. Angular may invoke an input's setter multiple times, which may negatively impact application performance if the setter performs any costly behaviors, such as DOM manipulation.\n\n## [Specify inputs in the `@Component` decorator](https://angular.dev/guide/components/inputs\\#specify-inputs-in-the-component-decorator)\n\nIn addition to the `@Input` decorator, you can also specify a component's inputs with the `inputs` property in the `@Component` decorator. This can be useful when a component inherits a property from a base class:\n\n```\n      // `CustomSlider` inherits the `disabled` property from `BaseSlider`.@Component({  ...,  inputs: ['disabled'],})export class CustomSlider extends BaseSlider { }\n\n```\n\ncheck\n\nYou can additionally specify an input alias in the `inputs` list by putting the alias after a colon in the string:\n\n```\n      // `CustomSlider` inherits the `disabled` property from `BaseSlider`.@Component({  ...,  inputs: ['disabled: sliderDisabled'],})export class CustomSlider extends BaseSlider { }\n\n```\n\ncheck",
  "title": "Accepting data with input properties \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "input",
    "angular",
    "inputs",
    "value",
    "https",
    "dev",
    "guide",
    "component",
    "components",
    "model"
  ],
  "sourceURL": "https://angular.dev/guide/components/inputs"
}