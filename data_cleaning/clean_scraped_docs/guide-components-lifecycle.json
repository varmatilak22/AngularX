{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backComponents\n  - [Anatomy of components](https://angular.dev/guide/components)\n  - [Selectors](https://angular.dev/guide/components/selectors)\n  - [Styling](https://angular.dev/guide/components/styling)\n  - [Accepting data with input properties](https://angular.dev/guide/components/inputs)\n  - [Custom events with outputs](https://angular.dev/guide/components/outputs)\n  - [Content projection with ng-content](https://angular.dev/guide/components/content-projection)\n  - [Host elements](https://angular.dev/guide/components/host-elements)\n  - [Lifecycle](https://angular.dev/guide/components/lifecycle)\n  - [Referencing component children with queries](https://angular.dev/guide/components/queries)\n  - [Using DOM APIs](https://angular.dev/guide/components/dom-apis)\n  - [Inheritance](https://angular.dev/guide/components/inheritance)\n  - [Programmatically rendering components](https://angular.dev/guide/components/programmatic-rendering)\n  - [Advanced configuration](https://angular.dev/guide/components/advanced-configuration)\n  - [Custom Elements](https://angular.dev/guide/elements)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\n**TIP:** This guide assumes you've already read the [Essentials Guide](https://angular.dev/guide/components/essentials). Read that first if you're new to Angular.\n\nA component's **lifecycle** is the sequence of steps that happen between the component's creation\nand its destruction. Each step represents a different part of Angular's process for rendering\ncomponents and checking them for updates over time.\n\nIn your components, you can implement **lifecycle hooks** to run code during these steps.\nLifecycle hooks that relate to a specific component instance are implemented as methods on your\ncomponent class. Lifecycle hooks that relate the Angular application as a whole are implemented\nas functions that accept a callback.\n\nA component's lifecycle is tightly connected to how Angular checks your components for changes over\ntime. For the purposes of understanding this lifecycle, you only need to know that Angular walks\nyour application tree from top to bottom, checking template bindings for changes. The lifecycle\nhooks described below run while Angular is doing this traversal. This traversal visits each\ncomponent exactly once, so you should always avoid making further state changes in the middle of the\nprocess.\n\n## [Summary](https://angular.dev/guide/components/lifecycle\\#summary)\n\n|     |     |     |\n| --- | --- | --- |\n| **Phase** | **Method** | **Summary** |\n| Creation | `constructor` | [Standard JavaScript class constructor](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Classes/constructor). Runs when Angular instantiates the component. |\n| Change<br>Detection | `ngOnInit` | Runs once after Angular has initialized all the component's inputs. |\n| `ngOnChanges` | Runs every time the component's inputs have changed. |\n| `ngDoCheck` | Runs every time this component is checked for changes. |\n| `ngAfterContentInit` | Runs once after the component's _content_ has been initialized. |\n| `ngAfterContentChecked` | Runs every time this component content has been checked for changes. |\n| `ngAfterViewInit` | Runs once after the component's _view_ has been initialized. |\n| `ngAfterViewChecked` | Runs every time the component's view has been checked for changes. |\n| Rendering | `afterNextRender` | Runs once the next time that **all** components have been rendered to the DOM. |\n| `afterRender` | Runs every time **all** components have been rendered to the DOM. |\n| Destruction | `ngOnDestroy` | Runs once before the component is destroyed. |\n\n### [ngOnInit](https://angular.dev/guide/components/lifecycle\\#ngoninit)\n\nThe `ngOnInit` method runs after Angular has initialized all the components inputs with their\ninitial values. A component's `ngOnInit` runs exactly once.\n\nThis step happens _before_ the component's own template is initialized. This means that you can\nupdate the component's state based on its initial input values.\n\n### [ngOnChanges](https://angular.dev/guide/components/lifecycle\\#ngonchanges)\n\nThe `ngOnChanges` method runs after any component inputs have changed.\n\nThis step happens _before_ the component's own template is checked. This means that you can update\nthe component's state based on its initial input values.\n\nDuring initialization, the first `ngOnChanges` runs before `ngOnInit`.\n\n#### [Inspecting changes](https://angular.dev/guide/components/lifecycle\\#inspecting-changes)\n\nThe `ngOnChanges` method accepts one `SimpleChanges` argument. This object is\na [`Record`](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)\nmapping each component input name to a `SimpleChange` object. Each `SimpleChange` contains the\ninput's previous value, its current value, and a flag for whether this is the first time the input\nhas changed.\n\n```\n      @Component({  /* ... */})export class UserProfile {  @Input() name: string = '';  ngOnChanges(changes: SimpleChanges) {    for (const inputName in changes) {      const inputValues = changes[inputName];      console.log(`Previous ${inputName} == ${inputValues.previousValue}`);      console.log(`Current ${inputName} == ${inputValues.currentValue}`);      console.log(`Is first ${inputName} change == ${inputValues.firstChange}`);    }  }}\n\n```\n\ncheck\n\nIf you provide an `alias` for any input properties, the `SimpleChanges` Record still uses the\nTypeScript property name as a key, rather than the alias.\n\n### [ngOnDestroy](https://angular.dev/guide/components/lifecycle\\#ngondestroy)\n\nThe `ngOnDestroy` method runs once just before a component is destroyed. Angular destroys a\ncomponent when it is no longer shown on the page, such as being hidden by `@if` or upon navigating\nto another page.\n\n#### [DestroyRef](https://angular.dev/guide/components/lifecycle\\#destroyref)\n\nAs an alternative to the `ngOnDestroy` method, you can inject an instance of `DestroyRef`. You can\nregister a callback to be invoked upon the component's destruction by calling the `onDestroy` method\nof `DestroyRef`.\n\n```\n      @Component({  /* ... */})export class UserProfile {  constructor() {    inject(DestroyRef).onDestroy(() => {      console.log('UserProfile destruction');    });  }}\n\n```\n\ncheck\n\nYou can pass the `DestroyRef` instance to functions or classes outside your component. Use this\npattern if you have other code that should run some cleanup behavior when the component is\ndestroyed.\n\nYou can also use `DestroyRef` to keep setup code close to cleanup code, rather than putting\nall cleanup code in the `ngOnDestroy` method.\n\n### [ngDoCheck](https://angular.dev/guide/components/lifecycle\\#ngdocheck)\n\nThe `ngDoCheck` method runs before every time Angular checks a component's template for changes.\n\nYou can use this lifecycle hook to manually check for state changes outside of Angular's normal\nchange detection, manually updating the component's state.\n\nThis method runs very frequently and can significantly impact your page's performance. Avoid\ndefining this hook whenever possible, only using it when you have no alternative.\n\nDuring initialization, the first `ngDoCheck` runs after `ngOnInit`.\n\n### [ngAfterContentInit](https://angular.dev/guide/components/lifecycle\\#ngaftercontentinit)\n\nThe `ngAfterContentInit` method runs once after all the children nested inside the component (its\n_content_) have been initialized.\n\nYou can use this lifecycle hook to read the results of\n[content queries](https://angular.dev/guide/components/guide/components/queries#content-queries). While you can access the initialized\nstate of these queries, attempting to change any state in this method results in an\n[ExpressionChangedAfterItHasBeenCheckedError](https://angular.dev/guide/components/errors/NG0100)\n\n### [ngAfterContentChecked](https://angular.dev/guide/components/lifecycle\\#ngaftercontentchecked)\n\nThe `ngAfterContentChecked` method runs every time the children nested inside the component (its\n_content_) have been checked for changes.\n\nThis method runs very frequently and can significantly impact your page's performance. Avoid\ndefining this hook whenever possible, only using it when you have no alternative.\n\nWhile you can access the updated state\nof [content queries](https://angular.dev/guide/components/guide/components/queries#content-queries) here, attempting to\nchange any state in this method results in\nan [ExpressionChangedAfterItHasBeenCheckedError](https://angular.dev/guide/components/errors/NG0100).\n\n### [ngAfterViewInit](https://angular.dev/guide/components/lifecycle\\#ngafterviewinit)\n\nThe `ngAfterViewInit` method runs once after all the children in the component's template (its\n_view_) have been initialized.\n\nYou can use this lifecycle hook to read the results of\n[view queries](https://angular.dev/guide/components/guide/components/queries#view-queries). While you can access the initialized state of\nthese queries, attempting to change any state in this method results in an\n[ExpressionChangedAfterItHasBeenCheckedError](https://angular.dev/guide/components/errors/NG0100)\n\n### [ngAfterViewChecked](https://angular.dev/guide/components/lifecycle\\#ngafterviewchecked)\n\nThe `ngAfterViewChecked` method runs every time the children in the component's template (its\n_view_) have been checked for changes.\n\nThis method runs very frequently and can significantly impact your page's performance. Avoid\ndefining this hook whenever possible, only using it when you have no alternative.\n\nWhile you can access the updated state of [view queries](https://angular.dev/guide/components/guide/components/queries#view-queries)\nhere, attempting to\nchange any state in this method results in\nan [ExpressionChangedAfterItHasBeenCheckedError](https://angular.dev/guide/components/errors/NG0100).\n\n### [afterRender and afterNextRender](https://angular.dev/guide/components/lifecycle\\#afterrender-and-afternextrender)\n\nThe `afterRender` and `afterNextRender` functions let you register a **render callback** to be\ninvoked after Angular has finished rendering _all components_ on the page into the DOM.\n\nThese functions are different from the other lifecycle hooks described in this guide. Rather than a\nclass method, they are standalone functions that accept a callback. The execution of render\ncallbacks are not tied to any specific component instance, but instead an application-wide hook.\n\n`afterRender` and `afterNextRender` must be called in\nan [injection context](https://angular.dev/guide/components/guide/di/dependency-injection-context), typically a\ncomponent's constructor.\n\nYou can use render callbacks to perform manual DOM operations.\nSee [Using DOM APIs](https://angular.dev/guide/components/guide/components/dom-apis) for guidance on working with the DOM in Angular.\n\nRender callbacks do not run during server-side rendering or during build-time pre-rendering.\n\n#### [afterRender phases](https://angular.dev/guide/components/lifecycle\\#afterrender-phases)\n\nWhen using `afterRender` or `afterNextRender`, you can optionally split the work into phases. The\nphase gives you control over the sequencing of DOM operations, letting you sequence _write_\noperations before _read_ operations in order to minimize\n[layout thrashing](https://web.dev/avoid-large-complex-layouts-and-layout-thrashing). In order to\ncommunicate across phases, a phase function may return a result value that can be accessed in the\nnext phase.\n\n```\n      import {Component, ElementRef, afterNextRender} from '@angular/core';@Component({...})export class UserProfile {  private prevPadding = 0;  private elementHeight = 0;  constructor() {    private elementRef = inject(ElementRef);    const nativeElement = elementRef.nativeElement;    afterNextRender({      // Use the `Write` phase to write to a geometric property.      write: () => {        const padding = computePadding();        const changed = padding !== this.prevPadding;        if (changed) {          nativeElement.style.padding = padding;        }        return changed; // Communicate whether anything changed to the read phase.      },      // Use the `Read` phase to read geometric properties after all writes have occurred.      read: (didWrite) => {        if (didWrite) {          this.elementHeight = nativeElement.getBoundingClientRect().height;        }      }    });  }}\n\n```\n\ncheck\n\nThere are four phases, run in the following order:\n\n| Phase | Description |\n| --- | --- |\n| `earlyRead` | Use this phase to read any layout-affecting DOM properties and styles that are strictly necessary for subsequent calculation. Avoid this phase if possible, preferring the `write` and `read` phases. |\n| `mixedReadWrite` | Default phase. Use for any operations need to both read and write layout-affecting properties and styles. Avoid this phase if possible, preferring the explicit `write` and `read` phases. |\n| `write` | Use this phase to write layout-affecting DOM properties and styles. |\n| `read` | Use this phase to read any layout-affecting DOM properties. |\n\n## [Lifecycle interfaces](https://angular.dev/guide/components/lifecycle\\#lifecycle-interfaces)\n\nAngular provides a TypeScript interface for each lifecycle method. You can optionally import\nand `implement` these interfaces to ensure that your implementation does not have any typos or\nmisspellings.\n\nEach interface has the same name as the corresponding method without the `ng` prefix. For example,\nthe interface for `ngOnInit` is `OnInit`.\n\n```\n      @Component({  /* ... */})export class UserProfile implements OnInit {  ngOnInit() {    /* ... */  }}\n\n```\n\ncheck\n\n## [Execution order](https://angular.dev/guide/components/lifecycle\\#execution-order)\n\nThe following diagrams show the execution order of Angular's lifecycle hooks.\n\n### [During initialization](https://angular.dev/guide/components/lifecycle\\#during-initialization)\n\nRendering\n\nChange detection\n\nngOnChanges\n\nngOnInit\n\nngDoCheck\n\nngAfterContentInit\n\nngAfterViewInit\n\nngAfterContentChecked\n\nngAfterViewChecked\n\nconstructor\n\nafterRender\n\n### [Subsequent updates](https://angular.dev/guide/components/lifecycle\\#subsequent-updates)\n\nRendering\n\nChange detection\n\nngOnChanges\n\nngDoCheck\n\nngAfterContentChecked\n\nngAfterViewChecked\n\nafterRender\n\n### [Ordering with directives](https://angular.dev/guide/components/lifecycle\\#ordering-with-directives)\n\nWhen you put one or more directives on the same element as a component, either in a template or with\nthe `hostDirectives` property, the framework does not guarantee any ordering of a given lifecycle\nhook between the component and the directives on a single element. Never depend on an observed\nordering, as this may change in later versions of Angular.",
  "title": "Lifecycle \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "angular",
    "https",
    "components",
    "dev",
    "guide",
    "component",
    "lifecycle",
    "runs",
    "method",
    "queries"
  ],
  "sourceURL": "https://angular.dev/guide/components/lifecycle"
}