{
  "content": "Skip to main content\n\nmenu\n\nmenuDocs\n\n- Introduction\n\n  - [What is Angular?](https://angular.dev/overview)\n  - [Installation](https://angular.dev/installation)\n  - Essentials\n  - [Start coding! \ud83d\ude80](https://angular.dev/tutorials/learn-angular)\n- In-depth Guides\n\n  - Signals\n  - Components\n  - Templates\n  - Directives\n  - Dependency Injection\n  - Routing\n  - Forms\n  - HTTP Client\n  - Server-side & hybrid-rendering\n  - Testing\n  - Internationalization\n  - Experimental features\n- Developer Tools\n\n  - Angular CLI\n  - Libraries\n  - [DevTools](https://angular.dev/tools/devtools)\n  - [Language Service](https://angular.dev/tools/language-service)\n- Best Practices\n\n  - [Style Guide](https://angular.dev/style-guide)\n  - [Security](https://angular.dev/best-practices/security)\n  - [Accessibility](https://angular.dev/best-practices/a11y)\n  - Performance\n  - [Keeping up-to-date](https://angular.dev/update)\n- Extended Ecosystem\n\n  - [NgModules](https://angular.dev/guide/ngmodules/overview)\n  - Animations\n  - Using RxJS with Angular\n  - Service Workers & PWAs\n  - [Web workers](https://angular.dev/ecosystem/web-workers)\n  - [Custom build pipeline](https://angular.dev/ecosystem/custom-build-pipeline)\n  - [Angular Fire](https://github.com/angular/angularfire#readme)\n  - [Google Maps](https://github.com/angular/components/tree/main/src/google-maps#readme)\n  - [Google Pay](https://github.com/google-pay/google-pay-button#angular)\n  - [YouTube player](https://github.com/angular/components/blob/main/src/youtube-player/README.md)\n  - [Angular CDK](https://material.angular.io/cdk/categories)\n  - [Angular Material](https://material.angular.io/)\n\n- arrow\\_backAngular CLI\n  - [Overview](https://angular.dev/tools/cli)\n  - [Local set-up](https://angular.dev/tools/cli/setup-local)\n  - [Building Angular apps](https://angular.dev/tools/cli/build)\n  - [Serving Angular apps for development](https://angular.dev/tools/cli/serve)\n  - [Deployment](https://angular.dev/tools/cli/deployment)\n  - [End-to-End Testing](https://angular.dev/tools/cli/end-to-end)\n  - [Migrating to new build system](https://angular.dev/tools/cli/build-system-migration)\n  - [Build environments](https://angular.dev/tools/cli/environments)\n  - [Angular CLI builders](https://angular.dev/tools/cli/cli-builder)\n  - [Generating code using schematics](https://angular.dev/tools/cli/schematics)\n  - [Authoring schematics](https://angular.dev/tools/cli/schematics-authoring)\n  - [Schematics for libraries](https://angular.dev/tools/cli/schematics-for-libraries)\n  - [Template type checking](https://angular.dev/tools/cli/template-typecheck)\n  - [Ahead-of-time (AOT) compilation](https://angular.dev/tools/cli/aot-compiler)\n  - [AOT metadata errors](https://angular.dev/tools/cli/aot-metadata-errors)\n\nThis site uses cookies from Google to deliver its services and to analyze traffic.\n\n[Learn more](https://policies.google.com/technologies/cookies) Ok, Got it\n\nThe following are metadata errors you may encounter, with explanations and suggested corrections.\n\n## [Expression form not supported](https://angular.dev/tools/cli/aot-metadata-errors\\#expression-form-not-supported)\n\n**HELPFUL:** The compiler encountered an expression it didn't understand while evaluating Angular metadata.\n\nLanguage features outside of the compiler's [restricted expression syntax](https://angular.dev/tools/cli/tools/cli/aot-compiler#expression-syntax)\ncan produce this error, as seen in the following example:\n\n```\n      // ERRORexport class Fooish { \u2026 }\u2026const prop = typeof Fooish; // typeof is not valid in metadata  \u2026  // bracket notation is not valid in metadata  { provide: 'token', useValue: { [prop]: 'value' } };  \u2026\n\n```\n\ncheck\n\nYou can use `typeof` and bracket notation in normal application code.\nYou just can't use those features within expressions that define Angular metadata.\n\nAvoid this error by sticking to the compiler's [restricted expression syntax](https://angular.dev/tools/cli/tools/cli/aot-compiler#expression-syntax)\nwhen writing Angular metadata\nand be wary of new or unusual TypeScript features.\n\n## [Reference to a local (non-exported) symbol](https://angular.dev/tools/cli/aot-metadata-errors\\#reference-to-a-local-non-exported-symbol)\n\n**HELPFUL:** Reference to a local (non-exported) symbol 'symbol name'. Consider exporting the symbol.\n\nThe compiler encountered a reference to a locally defined symbol that either wasn't exported or wasn't initialized.\n\nHere's a `provider` example of the problem.\n\n```\n      // ERRORlet foo: number; // neither exported nor initialized@Component({  selector: 'my-component',  template: \u2026 ,  providers: [    { provide: Foo, useValue: foo }  ]})export class MyComponent {}\n\n```\n\ncheck\n\nThe compiler generates the component factory, which includes the `useValue` provider code, in a separate module. _That_ factory module can't reach back to _this_ source module to access the local (non-exported) `foo` variable.\n\nYou could fix the problem by initializing `foo`.\n\n```\n      let foo = 42; // initialized\n\n```\n\ncheck\n\nThe compiler will [fold](https://angular.dev/tools/cli/tools/cli/aot-compiler#code-folding) the expression into the provider as if you had written this.\n\n```\n      providers: [  { provide: Foo, useValue: 42 }]\n\n```\n\ncheck\n\nAlternatively, you can fix it by exporting `foo` with the expectation that `foo` will be assigned at runtime when you actually know its value.\n\n```\n      // CORRECTEDexport let foo: number; // exported@Component({  selector: 'my-component',  template: \u2026 ,  providers: [    { provide: Foo, useValue: foo }  ]})export class MyComponent {}\n\n```\n\ncheck\n\nAdding `export` often works for variables referenced in metadata such as `providers` and `animations` because the compiler can generate _references_ to the exported variables in these expressions. It doesn't need the _values_ of those variables.\n\nAdding `export` doesn't work when the compiler needs the _actual value_\nin order to generate code.\nFor example, it doesn't work for the `template` property.\n\n```\n      // ERRORexport let someTemplate: string; // exported but not initialized@Component({  selector: 'my-component',  template: someTemplate})export class MyComponent {}\n\n```\n\ncheck\n\nThe compiler needs the value of the `template` property _right now_ to generate the component factory.\nThe variable reference alone is insufficient.\nPrefixing the declaration with `export` merely produces a new error, \" [`Only initialized variables and constants can be referenced`](https://angular.dev/tools/cli/aot-metadata-errors#only-initialized-variables)\".\n\n## [Only initialized variables and constants](https://angular.dev/tools/cli/aot-metadata-errors\\#only-initialized-variables-and-constants)\n\n**HELPFUL:** _Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler._\n\nThe compiler found a reference to an exported variable or static field that wasn't initialized.\nIt needs the value of that variable to generate code.\n\nThe following example tries to set the component's `template` property to the value of the exported `someTemplate` variable which is declared but _unassigned_.\n\n```\n      // ERRORexport let someTemplate: string;@Component({  selector: 'my-component',  template: someTemplate})export class MyComponent {}\n\n```\n\ncheck\n\nYou'd also get this error if you imported `someTemplate` from some other module and neglected to initialize it there.\n\n```\n      // ERROR - not initialized there eitherimport { someTemplate } from './config';@Component({  selector: 'my-component',  template: someTemplate})export class MyComponent {}\n\n```\n\ncheck\n\nThe compiler cannot wait until runtime to get the template information.\nIt must statically derive the value of the `someTemplate` variable from the source code so that it can generate the component factory, which includes instructions for building the element based on the template.\n\nTo correct this error, provide the initial value of the variable in an initializer clause _on the same line_.\n\n```\n      // CORRECTEDexport let someTemplate = '<h1>Greetings from Angular</h1>';@Component({  selector: 'my-component',  template: someTemplate})export class MyComponent {}\n\n```\n\ncheck\n\n## [Reference to a non-exported class](https://angular.dev/tools/cli/aot-metadata-errors\\#reference-to-a-non-exported-class)\n\n**HELPFUL:** _Reference to a non-exported class `<class name>`._ _Consider exporting the class._\n\nMetadata referenced a class that wasn't exported.\n\nFor example, you may have defined a class and used it as an injection token in a providers array but neglected to export that class.\n\n```\n      // ERRORabstract class MyStrategy { }  \u2026  providers: [    { provide: MyStrategy, useValue: \u2026 }  ]  \u2026\n\n```\n\ncheck\n\nAngular generates a class factory in a separate module and that factory [can only access exported classes](https://angular.dev/tools/cli/tools/cli/aot-compiler#exported-symbols).\nTo correct this error, export the referenced class.\n\n```\n      // CORRECTEDexport abstract class MyStrategy { }  \u2026  providers: [    { provide: MyStrategy, useValue: \u2026 }  ]  \u2026\n\n```\n\ncheck\n\n## [Reference to a non-exported function](https://angular.dev/tools/cli/aot-metadata-errors\\#reference-to-a-non-exported-function)\n\n**HELPFUL:** _Metadata referenced a function that wasn't exported._\n\nFor example, you may have set a providers `useFactory` property to a locally defined function that you neglected to export.\n\n```\n      // ERRORfunction myStrategy() { \u2026 }  \u2026  providers: [    { provide: MyStrategy, useFactory: myStrategy }  ]  \u2026\n\n```\n\ncheck\n\nAngular generates a class factory in a separate module and that factory [can only access exported functions](https://angular.dev/tools/cli/tools/cli/aot-compiler#exported-symbols).\nTo correct this error, export the function.\n\n```\n      // CORRECTEDexport function myStrategy() { \u2026 }  \u2026  providers: [    { provide: MyStrategy, useFactory: myStrategy }  ]  \u2026\n\n```\n\ncheck\n\n## [Function calls are not supported](https://angular.dev/tools/cli/aot-metadata-errors\\#function-calls-are-not-supported)\n\n**HELPFUL:** _Function calls are not supported. Consider replacing the function or lambda with a reference to an exported function._\n\nThe compiler does not currently support [function expressions or lambda functions](https://angular.dev/tools/cli/tools/cli/aot-compiler#function-expression).\nFor example, you cannot set a provider's `useFactory` to an anonymous function or arrow function like this.\n\n```\n      // ERROR  \u2026  providers: [    { provide: MyStrategy, useFactory: function() { \u2026 } },    { provide: OtherStrategy, useFactory: () => { \u2026 } }  ]  \u2026\n\n```\n\ncheck\n\nYou also get this error if you call a function or method in a provider's `useValue`.\n\n```\n      // ERRORimport { calculateValue } from './utilities';  \u2026  providers: [    { provide: SomeValue, useValue: calculateValue() }  ]  \u2026\n\n```\n\ncheck\n\nTo correct this error, export a function from the module and refer to the function in a `useFactory` provider instead.\n\n```\n      // CORRECTEDimport { calculateValue } from './utilities';export function myStrategy() { \u2026 }export function otherStrategy() { \u2026 }export function someValueFactory() {  return calculateValue();}  \u2026  providers: [    { provide: MyStrategy, useFactory: myStrategy },    { provide: OtherStrategy, useFactory: otherStrategy },    { provide: SomeValue, useFactory: someValueFactory }  ]  \u2026\n\n```\n\ncheck\n\n## [Destructured variable or constant not supported](https://angular.dev/tools/cli/aot-metadata-errors\\#destructured-variable-or-constant-not-supported)\n\n**HELPFUL:** _Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring._\n\nThe compiler does not support references to variables assigned by [destructuring](https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring).\n\nFor example, you cannot write something like this:\n\n```\n      // ERRORimport { configuration } from './configuration';// destructured assignment to foo and barconst {foo, bar} = configuration;  \u2026  providers: [    {provide: Foo, useValue: foo},    {provide: Bar, useValue: bar},  ]  \u2026\n\n```\n\ncheck\n\nTo correct this error, refer to non-destructured values.\n\n```\n      // CORRECTEDimport { configuration } from './configuration';  \u2026  providers: [    {provide: Foo, useValue: configuration.foo},    {provide: Bar, useValue: configuration.bar},  ]  \u2026\n\n```\n\ncheck\n\n## [Could not resolve type](https://angular.dev/tools/cli/aot-metadata-errors\\#could-not-resolve-type)\n\n**HELPFUL:** _The compiler encountered a type and can't determine which module exports that type._\n\nThis can happen if you refer to an ambient type.\nFor example, the `Window` type is an ambient type declared in the global `.d.ts` file.\n\nYou'll get an error if you reference it in the component constructor, which the compiler must statically analyze.\n\n```\n      // ERROR@Component({ })export class MyComponent {  constructor (private win: Window) { \u2026 }}\n\n```\n\ncheck\n\nTypeScript understands ambient types so you don't import them.\nThe Angular compiler does not understand a type that you neglect to export or import.\n\nIn this case, the compiler doesn't understand how to inject something with the `Window` token.\n\nDo not refer to ambient types in metadata expressions.\n\nIf you must inject an instance of an ambient type,\nyou can finesse the problem in four steps:\n\n1. Create an injection token for an instance of the ambient type.\n2. Create a factory function that returns that instance.\n3. Add a `useFactory` provider with that factory function.\n4. Use `@Inject` to inject the instance.\n\nHere's an illustrative example.\n\n```\n      // CORRECTEDimport { Inject } from '@angular/core';export const WINDOW = new InjectionToken('Window');export function _window() { return window; }@Component({  \u2026  providers: [    { provide: WINDOW, useFactory: _window }  ]})export class MyComponent {  constructor (@Inject(WINDOW) private win: Window) { \u2026 }}\n\n```\n\ncheck\n\nThe `Window` type in the constructor is no longer a problem for the compiler because it\nuses the `@Inject(WINDOW)` to generate the injection code.\n\nAngular does something similar with the `DOCUMENT` token so you can inject the browser's `document` object (or an abstraction of it, depending upon the platform in which the application runs).\n\n```\n      import { Inject }   from '@angular/core';import { DOCUMENT } from '@angular/common';@Component({ \u2026 })export class MyComponent {  constructor (@Inject(DOCUMENT) private doc: Document) { \u2026 }}\n\n```\n\ncheck\n\n## [Name expected](https://angular.dev/tools/cli/aot-metadata-errors\\#name-expected)\n\n**HELPFUL:** _The compiler expected a name in an expression it was evaluating._\n\nThis can happen if you use a number as a property name as in the following example.\n\n```\n      // ERRORprovider: [{ provide: Foo, useValue: { 0: 'test' } }]\n\n```\n\ncheck\n\nChange the name of the property to something non-numeric.\n\n```\n      // CORRECTEDprovider: [{ provide: Foo, useValue: { '0': 'test' } }]\n\n```\n\ncheck\n\n## [Unsupported enum member name](https://angular.dev/tools/cli/aot-metadata-errors\\#unsupported-enum-member-name)\n\n**HELPFUL:** _Angular couldn't determine the value of the [enum member](https://www.typescriptlang.org/docs/handbook/enums.html) that you referenced in metadata._\n\nThe compiler can understand simple enum values but not complex values such as those derived from computed properties.\n\n```\n      // ERRORenum Colors {  Red = 1,  White,  Blue = \"Blue\".length // computed}  \u2026  providers: [    { provide: BaseColor,   useValue: Colors.White } // ok    { provide: DangerColor, useValue: Colors.Red }   // ok    { provide: StrongColor, useValue: Colors.Blue }  // bad  ]  \u2026\n\n```\n\ncheck\n\nAvoid referring to enums with complicated initializers or computed properties.\n\n## [Tagged template expressions are not supported](https://angular.dev/tools/cli/aot-metadata-errors\\#tagged-template-expressions-are-not-supported)\n\n**HELPFUL:** _Tagged template expressions are not supported in metadata._\n\nThe compiler encountered a JavaScript ES2015 [tagged template expression](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals) such as the following.\n\n```\n      // ERRORconst expression = 'funky';const raw = String.raw`A tagged template ${expression} string`; \u2026 template: '<div>' + raw + '</div>' \u2026\n\n```\n\ncheck\n\n[`String.raw()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/raw) is a _tag function_ native to JavaScript ES2015.\n\nThe AOT compiler does not support tagged template expressions; avoid them in metadata expressions.\n\n## [Symbol reference expected](https://angular.dev/tools/cli/aot-metadata-errors\\#symbol-reference-expected)\n\n**HELPFUL:** _The compiler expected a reference to a symbol at the location specified in the error message._\n\nThis error can occur if you use an expression in the `extends` clause of a class.",
  "title": "AOT metadata errors \u2022 Angular",
  "description": "The web development framework for building modern apps.",
  "keywords": [
    "angular",
    "https",
    "dev",
    "cli",
    "tools",
    "compiler",
    "metadata",
    "check",
    "provide",
    "aot"
  ],
  "sourceURL": "https://angular.dev/tools/cli/aot-metadata-errors"
}